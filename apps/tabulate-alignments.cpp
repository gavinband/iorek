
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "tabulate-alignments" ;
	std::string const program_version = svelte_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct AssessPositionOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_values_until_next_option()
		;
		options[ "-read-files" ]
			.set_description( "File containing paths of bam/cram files to operate on." )
			.set_takes_single_value()
		;

		options.option_excludes_option( "-reads", "-read-files" ) ;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description(
				"Range of positions to focus analysis on (in the form <chromosome>:<position>, or <chromosome>:<start>-<end>). "
				"Note " + globals::program_name + " uses 1-based coordinates with closed intervals." )
			.set_takes_values_until_next_option()
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 1000 )
		;

		options[ "-reference" ]
			.set_description( "Specify reference sequence (mandatory when using CRAM files)" )
			.set_takes_single_value() ;
		
		options.declare_group( "Options affecting behaviour" ) ;
		options[ "-mq-bins" ]
			.set_description( "Specify lower limits of bins of mapping quality to stratify results by. "
				"This must include 0 (zero).  Bins are left-closed and right-open and the last bin "
				"extends to positive infinity." )
			.set_takes_values_until_next_option()
			.set_default_value( 0 ) ;
	}
} ;

namespace impl {
	// Counts reads overlapping a given set of positions
	// stratified by mapping quality (in bins)
	// strand and allele
	struct ReadCounter: public boost::noncopyable {
		struct Record {
			public:
				enum Strand { eForwardStrand = 1, eReverseStrand = -1 } ;
				Record(
					std::string const& chromosome,
					int const position,
					char const allele,
					Strand const strand,
					int const mq_bin
				):
					m_chromosome( chromosome ),
					m_position( position),
					m_allele( allele ),
					m_strand( strand ),
					m_mq_bin( mq_bin )
				{}

				Record():
					m_chromosome( "" ),
					m_position(0),
					m_allele(0),
					m_strand( eForwardStrand ),
					m_mq_bin(0)
				{}

				Record( Record const& other ):
					m_chromosome( other.m_chromosome ),
					m_position( other.m_position ),
					m_allele( other.m_allele ),
					m_strand( other.m_strand ),
					m_mq_bin( other.m_mq_bin )
				{}

				Record& operator=( Record const& other ) {
					m_chromosome = other.m_chromosome ;
					m_position = other.m_position ;
					m_allele = other.m_allele ;
					m_strand = other.m_strand ;
					m_mq_bin = other.m_mq_bin ;
					return *this ;
				}

			private:
				std::string m_chromosome ;
				int m_position ;
				char m_allele ;
				int m_strand ;
				int m_mq_bin ;
			
				friend bool operator<( Record const& left, Record const& right ) ;
#if DEBUG
				friend std::ostream& operator<<( std::ostream& out, Record const& value ) ;
#endif
		} ;

	private:
		std::vector< int > m_mq_bins ; // first bin always starts at zero, last bin always reaches max.
		std::string const m_chromosome ;
		int const m_start ;
		int const m_end ;

		typedef std::map< Record, int > Store ;
		Store m_store ;

	public:
		ReadCounter(
			genfile::GenomePositionRange const& region,
			std::vector< int > mq_bins // must include zero
		):
			m_mq_bins( mq_bins ),
			m_chromosome( region.chromosome() ),
			m_start( region.start().position() ),
			m_end( region.end().position() ),
			m_store()
		{
			// sort so mq bins are in descending order.
			std::sort( m_mq_bins.begin(), m_mq_bins.end(), []( int const a, int const b ) { return b < a ; } ) ;
			// Check 0 is among the bins
			assert( m_mq_bins.size() > 0 && m_mq_bins.back() == 0 ) ;
			// Can now implement our policy by finding the first bin <= the mq value.
		}

		void add_read( seqlib::BamRecord const& read, seqlib::BamHeader const& header ) {
			add_read_impl( read, header ) ;
		}
	
		std::vector< int > mq_bins() const { return m_mq_bins ; }

		int lookup(
			std::string const& chromosome, int const position,
			char const allele,
			Record::Strand const strand,
			int const mq_bin
		) {
			Record r( chromosome, position, allele, strand, mq_bin ) ;

#if DEBUG
			std::cerr << "ReadCounter::lookup(): looking up: " << r << "..." ;
#endif
			
			Store::const_iterator where = m_store.find( r ) ;
			if( where == m_store.end() ) {
#if DEBUG
				std::cerr << "not found.\n" ;
#endif
				return 0 ;
			} else {
#if DEBUG
				std::cerr << "found with value " << where->second << "\n" ;
#endif
				return where->second ;
			}
		}
		
	private:
	
		void add_read_impl( seqlib::BamRecord const& read, seqlib::BamHeader const& header ) {
			assert( header.IDtoName( read.ChrID() ) == m_chromosome ) ;
			seqlib::Cigar const& cigar = read.GetCigar() ;
			std::string const sequence = read.Sequence() ;

			seqlib::Cigar::const_iterator i = cigar.begin(), end_i = cigar.end() ;
			int position = read.Position();
			std::size_t position_in_sequence = 0 ;

#if DEBUG
			std::cerr << "ReadCounter::add_read_impl(): Processing read: " << m_chromosome << ":" << position << ": \"" << sequence << "\"\n" ;
#endif

			for( ; i != end_i; ++i ) {
				char const type = i->Type() ;

				// The cigar ops are:
				// M    Alignment match (can be a sequence match or mismatch
				// I    Insertion to the reference
				// D    Deletion from the reference
				// N    Skipped region from the reference
				// S    Soft clip on the read (clipped sequence present in <seq>)
				// H    Hard clip on the read (clipped sequence NOT present in <seq>)
				// P    Padding (silent deletion from the padded reference sequence)
				// =    Sequence match
				// X    Sequence mismatch
				//
				// ...so we only need to handle aligned bases and skipped/deleted bases here.
				// (NB. 'skipped' bases probably only turn up in spliced RNA alignments).
				//

				switch( type ) {
					case 'M':
					case 'X':
					case '=':
						// consumes reference and query
						for( int k = 0; k < i->Length(); ++k, ++position, ++position_in_sequence ) {
							if( position >= m_start && position < m_end ) {
#if DEBUG
								std::cerr << "ReadCounter::add_read_impl(): adding record for "
									<< m_chromosome << ":" << position << " '"
									<< sequence[position_in_sequence] << "' "
									<< (read.ReverseFlag() ? '-' : '+' ) << " "
									<< find_bin_for_mq( read.MapQuality() )
									<< "\n" ;
#endif
								m_store[
									Record(
										m_chromosome,
										position,
										sequence[position_in_sequence],
										read.ReverseFlag() ? Record::eReverseStrand : Record::eForwardStrand,
										find_bin_for_mq( read.MapQuality() )
									)
								] += 1 ;
							}
						}
						break ;
					case 'D':
						// consumes reference, not query
						for( int k = 0; k < i->Length(); ++k, ++position ) {
							if( position >= m_start && position < m_end ) {
								m_store[
									Record(
										m_chromosome,
										position,
										'-',
										read.ReverseFlag() ? Record::eReverseStrand : Record::eForwardStrand,
										find_bin_for_mq( read.MapQuality() )
									)
								] += 1 ;
							}
						}
						break ;
					case 'N':
						// consumes reference, not query
						position += i->Length() ;
						break ;
					case 'I':
						// consumes query, not reference
						if( position >= m_start && position < m_end ) {
							m_store[
								Record(
									m_chromosome,
									position,
									'+',
									read.ReverseFlag() ? Record::eReverseStrand : Record::eForwardStrand,
									find_bin_for_mq( read.MapQuality() )
								)
							] += 1 ;
						}
						position_in_sequence += i->Length() ;
					break ;
					case 'S':
						// consumes query, not reference
						position_in_sequence += i->Length() ;
						break ;
					case 'H':
					case 'P':
						// consumes neither
					default:
						// shuld be no other cases... 9 cases in total.
						break ;
				}
			}
		}

		int find_bin_for_mq( int mq ) const {
			// bins are sorted in highest-to-smallest order of lower bin limits.
			// the smallest bin is zero
			// to find the bin we find the first mq_bin value <= the given mq.
			// if not found
			auto where = std::find_if( m_mq_bins.begin(), m_mq_bins.end(), [&mq]( int bin ) { return bin <= mq ; }) ;
			assert( where != m_mq_bins.end() ) ; // impossible if 0 is among bins.
			return *where ;
		}
	} ;
	
	bool operator<( ReadCounter::Record const& left, ReadCounter::Record const& right ) {
		return
			( left.m_chromosome < right.m_chromosome )
			|| (
				(left.m_chromosome == right.m_chromosome) && (
					(left.m_position < right.m_position)
					|| (
						(left.m_position == right.m_position) && (
							(left.m_allele < right.m_allele)
							|| (
								(left.m_allele == right.m_allele) && (
									(left.m_strand < right.m_strand)
									|| (
										(left.m_strand == right.m_strand) && (
											(left.m_mq_bin < right.m_mq_bin)
										)
									)
								)
							)
						)
					)
				)
			)
		;
	}
	
#if DEBUG
	std::ostream& operator<<( std::ostream& out, ReadCounter::Record const& value ) {
		return out << value.m_chromosome << ":" << value.m_position << " '" << value.m_allele << "' "
			<< (value.m_strand == ReadCounter::Record::eForwardStrand ? '+' : '-' ) << " "
			<< value.m_mq_bin ;
	}
#endif
	
}


struct AssessPositionApplication: public appcontext::ApplicationContext
{
public:
	AssessPositionApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new AssessPositionOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	
	typedef genfile::GenomePositionRange Region ;
	typedef std::vector< genfile::GenomePositionRange > Regions ;

	void unsafe_process() {
		std::vector< std::string > filenames ;
		if( options().check( "-reads" )) {
			filenames = options().get_values< std::string >( "-reads" ) ;
		} else if( options().check( "-read-files" )) {
			std::string const filename = options().get_value< std::string >( "-read-files" ) ;
			std::auto_ptr< std::istream > in = genfile::open_text_file_for_input( filename ) ;
			std::copy(
				std::istream_iterator< std::string >( *in ),
				std::istream_iterator< std::string >(),
				std::back_inserter< std::vector< std::string > >( filenames )
			) ;
		} else {
			throw appcontext::OptionProcessingException( "-reads", std::vector< std::string >(), "You must supply either -reads or -read-files." ) ;
		}
		unsafe_process(
			filenames,
			get_regions( options().get_values< std::string >( "-range" ) )
		) ;
	}
	
	Regions get_regions( std::vector< std::string > const& specs ) const {
		Regions result ;
		for( auto spec: specs ) {
			genfile::GenomePositionRange region = genfile::GenomePositionRange::parse( spec ).toZeroBased() ;
			if( !region.has_chromosome() ) {
				throw genfile::BadArgumentError(
					"AssessPositionApplication::get_regions()",
					"-training-regions=\"" + spec + "\"",
					"Regions must be specified with chromosome/contig identifiers."
				) ;
			}
			result.push_back( region ) ;
		}
		return result ;
	}
	
	void unsafe_process(
		std::vector< std::string > const& filenames,
		Regions const& regions
	) {
		using genfile::string_utils::to_string ;
		statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-o" ) ) ;
		std::vector< int > mq_bins = options().get_values< int > ( "-mq-bins" ) ;
		{
			*sink | "file" | "chromosome" | "position" ;
			for( std::size_t i = 0; i < mq_bins.size(); ++i ) {
				*sink | ("fwd:mq>=" + to_string(mq_bins[i]) + ":A") ;
				*sink | ("rev:mq>=" + to_string(mq_bins[i]) + ":A") ;
				*sink | ("fwd:mq>=" + to_string(mq_bins[i]) + ":C") ;
				*sink | ("rev:mq>=" + to_string(mq_bins[i]) + ":C") ;
				*sink | ("fwd:mq>=" + to_string(mq_bins[i]) + ":G") ;
				*sink | ("rev:mq>=" + to_string(mq_bins[i]) + ":G") ;
				*sink | ("fwd:mq>=" + to_string(mq_bins[i]) + ":T") ;
				*sink | ("rev:mq>=" + to_string(mq_bins[i]) + ":T") ;
				*sink | ("fwd:mq>=" + to_string(mq_bins[i]) + ":-") ;
				*sink | ("rev:mq>=" + to_string(mq_bins[i]) + ":-") ;
				*sink | ("fwd:mq>=" + to_string(mq_bins[i]) + ":+") ;
				*sink | ("rev:mq>=" + to_string(mq_bins[i]) + ":+") ;
			}
		}
		auto progress_context = ui().get_progress_context( "Processing samples" ) ;
		std::vector< std::string > const& names = get_names_from_filenames(filenames) ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			for( std::size_t region_i = 0; region_i < regions.size(); ++region_i ) {
				process_reads(
					filenames[i],
					regions[region_i],
					names[i],
					mq_bins,
					*sink
				) ;
			}
			progress_context( i+1, names.size() ) ;
		}
	}
	
	void process_reads(
		std::string const& filename,
		Region const& region,
		std::string const& name,
		std::vector< int > mq_bins,
		statfile::BuiltInTypeStatSink& sink
	) {
		try {
			process_reads_unsafe( filename, region, name, mq_bins, sink ) ;
		} catch( std::exception const& e ) {
			ui().logger() << "!! Error processing \"" << name << "\", results for this file will be zero.\n" ;
		}
	}

	void process_reads_unsafe(
		std::string const& filename,
		Region const& region,
		std::string const& name,
		std::vector< int > mq_bins,
		statfile::BuiltInTypeStatSink& sink
	) {
		seqlib::BamReader reader;
		
		if( options().check( "-reference" )) {
			reader.SetCramReference( options().get< std::string >( "-reference" )) ;
		}

		if( !reader.Open( filename )) {
			assert( "Failed to open file" ) ;
		}

		
		impl::ReadCounter read_counter( region, mq_bins ) ;

		try {
			seqlib::BamHeader const& header = reader.Header() ;
			reader.SetRegion( seqlib::GenomicRegion( region.toString(), header )) ;

			seqlib::BamRecord alignment ;
			while( reader.GetNextRecord( alignment ) ) {
				if(
					!alignment.SecondaryFlag()
					&& !alignment.DuplicateFlag()
					&& !alignment.QCFailFlag()
					&& alignment.MappedFlag()
				) {
					read_counter.add_read( alignment, header ) ;
				}
			}
		} catch( std::exception const& e ) {
			ui().logger() << "!! Error processing \"" << name << "\", results for this file will be zero.\n" ;
		}

		for( int position = region.start().position(); position < region.end().position(); ++position ) {
			sink << name
				<< region.chromosome()
				<< (position+1) // reconvert to 1-based coords
			;
			for( std::size_t i = 0; i < mq_bins.size(); ++i ) {
				sink << read_counter.lookup( region.chromosome(), position, 'A', impl::ReadCounter::Record::eForwardStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, 'A', impl::ReadCounter::Record::eReverseStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, 'C', impl::ReadCounter::Record::eForwardStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, 'C', impl::ReadCounter::Record::eReverseStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, 'G', impl::ReadCounter::Record::eForwardStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, 'G', impl::ReadCounter::Record::eReverseStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, 'T', impl::ReadCounter::Record::eForwardStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, 'T', impl::ReadCounter::Record::eReverseStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, '-', impl::ReadCounter::Record::eForwardStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, '-', impl::ReadCounter::Record::eReverseStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, '+', impl::ReadCounter::Record::eForwardStrand, mq_bins[i] )
					<< read_counter.lookup( region.chromosome(), position, '+', impl::ReadCounter::Record::eReverseStrand, mq_bins[i] )
				;
			}
			sink << statfile::end_row() ;
		}
	}
	
	std::vector< std::string > get_names_from_filenames( std::vector< std::string > const& filenames ) {
		std::vector< std::string > result ;
		for( auto s: filenames ) {
			boost::filesystem::path p( s ) ;
			result.push_back( p.stem().string() ) ;
		}
		return result ;
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		AssessPositionApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
