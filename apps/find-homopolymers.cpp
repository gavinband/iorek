
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <boost/filesystem.hpp>

#include "appcontext/appcontext.hpp"
#include "appcontext/get_current_time_as_string.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/Error.hpp"
#include "genfile/find_homopolymers_and_short_repeats.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#define DEBUG 0

namespace globals {
	std::string const program_name = "find-homopolymers" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct IorekOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-fasta" ]
			.set_description( "Path of FASTA file(s) to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-max-repeat-unit-length" ]
			.set_description( "max length of nucleotide repeat to look for. Must be <= 3 currently." )
			.set_takes_single_value()
			.set_default_value( 3 )
		;
		options[ "-minimum-tract-length" ]
			.set_description( "minimum length of repeat tract to report." )
			.set_takes_single_value()
			.set_default_value( 3 )
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
	}
} ;

struct IorekApplication: public appcontext::ApplicationContext
{
public:
	IorekApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new IorekOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	
	void unsafe_process() {
		genfile::Fasta::UniquePtr fasta = genfile::Fasta::create() ;
		{
			std::vector< std::string > fasta_filenames = options().get_values< std::string >( "-fasta" ) ;
			for( auto filename: fasta_filenames ) {
				auto progress_context = ui().get_progress_context( "Loading \"" + filename + "\"" ) ;
				fasta->add_sequences_from_file( filename, progress_context ) ;
			}
		}
		statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-o" )) ;
		process( *fasta, *sink ) ;
	}

	void process( genfile::Fasta const& fasta, statfile::BuiltInTypeStatSink& sink ) const {
		std::vector< std::string > const& sequence_ids = fasta.sequence_ids() ;
		std::size_t const max_repeat_unit_length = options().get< int >( "-max-repeat-unit-length" ) ;
		std::size_t const minimum_tract_length = options().get_value< std::size_t >( "-minimum-tract-length" ) ;
		assert( max_repeat_unit_length <= 3 ) ;
		sink.write_metadata(
				"Computed by find-homopolymers " + appcontext::get_current_time_as_string() + "\n"
				+ "Coordinates are 1-based, closed."
		) ;
		sink | "sequence_id" | "start" | "end" | "repeat" | "length" ;
		for( auto sequence_id: sequence_ids ) {
			auto progress_context = ui().get_progress_context( "Processing \"" + sequence_id + "\"" ) ;
			genfile::Fasta::PositionedSequenceRange const& contig = fasta.get_sequence( sequence_id ) ;
			genfile::find_homopolymers_and_short_repeats(
				contig.sequence().begin(),
				contig.sequence().end(),
				0,
				minimum_tract_length,
				max_repeat_unit_length,
				[&]( uint32_t start, uint32_t end, std::string const& repeat ) {
					sink << sequence_id << (start+1) << end << repeat << (end-start) << statfile::end_row() ;
				},
				progress_context
			) ;
		}
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		IorekApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
