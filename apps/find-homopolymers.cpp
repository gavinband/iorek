
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <boost/filesystem.hpp>

#include "appcontext/appcontext.hpp"
#include "appcontext/get_current_time_as_string.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/Error.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#define DEBUG 0

namespace globals {
	std::string const program_name = "find-homopolymers" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct IorekOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-fasta" ]
			.set_description( "Path of FASTA file(s) to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-max-length" ]
			.set_description( "max length of nucleotide repeat to look for." )
			.set_default_value( 3 )
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
	}
} ;

struct IorekApplication: public appcontext::ApplicationContext
{
public:
	IorekApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new IorekOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	
	void unsafe_process() {
		genfile::Fasta::UniquePtr fasta = genfile::Fasta::create() ;
		{
			std::vector< std::string > fasta_filenames = options().get_values< std::string >( "-fasta" ) ;
			for( auto filename: fasta_filenames ) {
				auto progress_context = ui().get_progress_context( "Loading \"" + filename + "\"" ) ;
				fasta->add_sequences_from_file( filename, progress_context ) ;
			}
		}
		uint32_t max_length = options().get< int >( "-max-length" ) ;
		assert( max_length > 0 ) ;
		statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-o" )) ;
		
		
		process( *fasta, max_length, *sink ) ;
	}

	void process( genfile::Fasta const& fasta, uint32_t const max_length, statfile::BuiltInTypeStatSink& sink ) const {
		std::vector< std::string > const& sequence_ids = fasta.sequence_ids() ;
		sink.write_metadata(
				"Computed by find-homopolymers " + appcontext::get_current_time_as_string() + "\n"
				+ "Coordinates are 1-based, closed."
		) ;
		sink | "sequence" | "start" | "end" | "repeat" | "length" ;
		for( auto sequence_id: sequence_ids ) {
			process(
				sequence_id,
				fasta.get_sequence( sequence_id ),
				max_length,
				[&]( std::string const& sequence_id, uint32_t start, uint32_t end, std::string const& repeat ) {
					sink << sequence_id << (start+1) << end << repeat << (end-start) << statfile::end_row() ;
				}
			) ;
		}
	}

	void process(
		std::string const& sequence_id,
		genfile::Fasta::PositionedSequenceRange const& sequence,
		uint32_t const max_length,
		std::function< void( std::string const&, uint32_t const, uint32_t const, std::string const& ) > callback
	) const {
		auto progress_context = ui().get_progress_context( "Processing \"" + sequence_id + "\"" ) ;
		std::vector< std::vector< char > > repeats ;
		std::vector< std::size_t > counters ;
		std::vector< std::size_t > starts ;
		std::vector< std::string > repeat_units ;
		for( uint32_t i = 0; i < max_length; ++i ) {
			repeats.push_back( std::vector< char >( i+1, ' ' )) ;
			counters.push_back( 0 ) ;
			starts.push_back( 0 ) ;
			repeat_units.push_back( std::string( i+1, ' ' )) ;
		}
		
		std::size_t const sequence_length = std::distance( sequence.second.first, sequence.second.second ) ;
		genfile::Fasta::ConstSequenceIterator const sequence_begin = sequence.second.first ;
		for( std::size_t x = 0; x < sequence_length; ++x ) {
			char base = ::toupper( *(sequence_begin + x)) ;
			for( uint32_t i = 0; i < max_length; ++i ) {
				// if counter < repeat unit length, then this is the first view of the repeat.
				// if counter >= repeat unit length, then we are repeating.
				auto& repeat = repeats[i] ;
				std::size_t const repeat_unit_length = i+1 ;
				auto& counter = counters[i] ;
				auto& start = starts[i] ;
				std::size_t const current_length = counter - start ;

				// Algorithm example: take sequence
				// A T G A T G A C T A C  T ...
				// 0 1 2 3 4 5 6 7 8 9 10 11
				// with repeat unit length L = 3.
				// We accumulate sequence until the repeat length is filled.
				// At this point we test the next base against the next repeat base.
				// If they differ, the potential repeat is over.  If it is a genuine repeat (more than two copies) we output.
				// To start a new repeat, we set start to (L-1) bases back to account for possible
				// overlapping repeats, as in the example.
				if( (current_length >= repeat_unit_length) && (base != repeat[counter % repeat_unit_length]) ) {
					if( current_length >= 2 * repeat_unit_length ) {
						std::copy( repeat.begin() + start, repeat.end(), repeat_units[i].begin() ) ;
						std::copy( repeat.begin(), repeat.begin() + start, repeat_units[i].begin() + repeat_unit_length - start ) ;
						// Avoid sequences of Ns or other missing base data
						bool only_proper_nucleotides = ( repeat_units[i].find_first_not_of( "ACGT" ) == std::string::npos ) ;
						// Avoid listing homopolymers as di- or tri-nucleotide repeats
						// TODO: fix the following line to work for arbitrary repeat length.
						bool valid = (
							(repeat_unit_length == 1 )
							|| ( repeat_unit_length == 2 && repeat[1] != repeat[0] )
							|| ( repeat_unit_length == 3 && ( repeat[1] != repeat[0] || repeat[2] != repeat[0] ))
						) ;
						if( valid && only_proper_nucleotides ) {
							// report in 0-based, half open coords
							callback( sequence_id, x - current_length, x, repeat_units[i] ) ;
						}
					}
					start = (counter + 1) % repeat_unit_length ;
					counter = repeat_unit_length-1 ;
				}
				repeat[counter % repeat_unit_length] = base ;
				++counter ;
			}
			progress_context( x+1, sequence_length ) ;
		}
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		IorekApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
