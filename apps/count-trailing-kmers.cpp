
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <functional>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#include "genfile/kmer/KmerHashIterator.hpp"
#include "parallel_hashmap/phmap.h"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "count-trailing-kmers" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct CountTrailingKmerOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options.declare_group( "Algorithm options" ) ;
		options[ "-l" ]
			.set_description( "Length to track at read ends." )
			.set_takes_single_value()
			.set_default_value( 50 ) ;

		options[ "-k" ]
			.set_description( "Kmer size.  Must be <= 31" )
			.set_takes_single_value()
			.set_default_value( 10 ) ;

		options[ "-compress-homopolymers" ]
			.set_description( "If specified, homopolymers will be compressed before analysis." ) ;

		options[ "-max-reads" ]
			.set_description( "Stop processing reads after seeing this many records from the input files.  Zero means process all reads" )
			.set_takes_single_value()
			.set_default_value( 0 )
		;
		
	}
} ;

struct CountTrailingKmerApplication: public appcontext::ApplicationContext
{
public:
	CountTrailingKmerApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new CountTrailingKmerOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:

	typedef phmap::flat_hash_map<std::string, std::string> TailMap ;
	typedef phmap::flat_hash_map<uint64_t, uint64_t> KmerCounts ;
	TailMap m_tails ;
	KmerCounts m_counts ;

	void unsafe_process() {
		std::size_t k = options().get< std::size_t >( "-k" ) ;
		std::size_t tail_length = options().get< std::size_t >( "-l" ) ;
		compute_read_tails(
			options().get_values< std::string >( "-reads" ),
			tail_length,
			options().check( "-compress-homopolymers" ),
			options().get< std::size_t >( "-max-reads" ),
			&m_tails
		) ;

		//for( auto k: m_tails ) {
		//	std::cerr << k.first << ": " << k.second << "\n" ;
		//}

		compute_trailing_kmers(
			m_tails,
			k,
			&m_counts
		) ;

		std::map< uint64_t, uint64_t, std::greater<uint64_t> > ordered ;
		{
			auto progress = ui().get_progress_context( "Sorting by count." ) ;
			std::size_t count = 0 ;
			for( auto r: m_counts ) {
				ordered[r.second] = r.first ;
				progress( ++count, m_counts.size() ) ;
			}
		}

		{
			std::string const& output_filename = options().get< std::string >( "-o" ) ;
			auto progress = ui().get_progress_context( "Outputting to \"" + output_filename + "\"" ) ;
			auto sink = statfile::BuiltInTypeStatSink::open( output_filename ) ;
			(*sink) | "kmer" | "count" ;
			std::size_t count = 0 ;
			for( auto kv: ordered ) {
				(*sink) << genfile::kmer::decode_hash( kv.second, k ) << kv.first << statfile::end_row() ;
				progress( ++count, ordered.size() ) ;
			}
		}

	}
	
	void compute_read_tails(
		std::vector< std::string > const& filenames,
		std::size_t const l, // how much of end of read to look at?
		bool const compress_homopolymers,
		std::size_t const max_reads,
		TailMap* result
	) const {
		assert( result != 0 ) ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			seqlib::BamReader reader;
			if( !reader.Open( filenames[i] )) {
				assert( "Failed to open file" ) ;
			}
			// seqlib::BamHeader const& header = reader.Header() ;
			compute_read_tails( filenames[i], reader, l, compress_homopolymers, max_reads, result ) ;
		}
	}

	void compute_read_tails(
		std::string const& filename,
		seqlib::BamReader& reader,
		std::size_t const l,
		bool const compress_homopolymers,
		std::size_t max_reads,
		TailMap* result
	) const {
		auto progress = ui().get_progress_context( "Computing read tails from \"" + filename + "\"...\n" ) ;
		std::size_t count = 0 ;
		seqlib::BamRecord alignment ;
		if( max_reads == 0 ) {
			max_reads = std::numeric_limits< std::size_t >::max() ;
		}
		while( reader.GetNextRecord( alignment ) && count < max_reads ) {
			std::string subread_id = alignment.Qname() ;
			std::size_t where = subread_id.rfind( "/" ) ;
			std::string read_id = subread_id ;
			if( where != std::string::npos ) {
				read_id = subread_id.substr( 0, where ) ;
			}
			//std::cerr << "READ: " << subread_id << " " << where << " " << subread_id << ".\n" ;
			std::string const sequence = compress_homopolymers ? homopolymer_compress( alignment.Sequence() ) : alignment.Sequence() ;
			std::string const tail = sequence.substr( sequence.size() - std::min( sequence.size(), l ), l ) ;
			(*result)[read_id] = tail ;

			progress( ++count ) ;
		}
	}

	std::string homopolymer_compress( std::string sequence ) const {
		std::string result( ' ', sequence.size() ) ;
		if( sequence.size() > 0 ) {
			std::size_t count = 0 ;
			result[0] = sequence[0] ;
			for( std::size_t i = 1; i < sequence.size(); ++i ) {
				if( sequence[i] != result[count] ) {
					result[++count] = sequence[i] ;
				}
			}
			result.resize( count+1 ) ;
		}
		return result ;
	}

	void compute_trailing_kmers(
		TailMap const& tails,
		std::size_t k,
		KmerCounts* result
	) const {
		typedef genfile::kmer::KmerHashIterator< std::string::const_iterator > KmerIterator ;
		auto progress = ui().get_progress_context( "Computing kmer counts..." ) ;
		std::size_t count = 0 ;
		for( auto kv: tails ) {
			for( 
				KmerIterator i( kv.second.begin(), kv.second.end(), k );
				1;
				++i
			) {
				uint64_t const hash = i.hash() ;
				if( result->find(hash) == result->end() ) {
					(*result)[hash] = 1 ;
				} else {
					++(*result)[hash] ;
				}
				if( i.finished() ) {
					break ;
				}
			}
			progress( ++count, tails.size() ) ;
		}
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		CountTrailingKmerApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
