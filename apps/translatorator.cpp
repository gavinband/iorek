
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <boost/optional.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/reverse_complement.hpp"
#include "genfile/translate.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "translatorator" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct TranslatoratorOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on.  Note that this program expects to see "
			"long DNA sequences that cover the full translated length of the target protain" )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description(
				"Ignore reads that don't overlap the this range of positions (in the form <chromosome>:<position>, or <chromosome>:<start>-<end>). "
				"(Note " + globals::program_name + " uses 1-based coordinates with closed intervals.)" )
			.set_takes_values_until_next_option()
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 1000 )
		;

		options[ "-reference" ]
			.set_description( "Specify reference sequence (mandatory when using CRAM files)" )
			.set_takes_single_value() ;
		
		options[ "-output-read-ids" ]
			.set_description( "Output the read IDs as well as the counts." ) ;

		options.declare_group( "Coding sequence options" ) ;
		options[ "-cds-kmers" ]
			.set_description(
				"Specify a pair of DNA kmers, on the *translation strand*, that represent the start and end of a CDS segment."
				" If the gene has multiple exons, specify this option multiple times."
			)
			.set_takes_values_until_next_option()
			.set_minimum_multiplicity(1)
			.set_minimum_multiplicity(1000) ;
	}
} ;

namespace impl {
	struct KmerPair {
		KmerPair() {}

		KmerPair( KmerPair const& other ):
			m_start( other.m_start ),
			m_end( other.m_end )
		{}

		KmerPair( std::string const& a, std::string const& b ):
			m_start(a),
			m_end(b)
		{}

		KmerPair& operator=( KmerPair const& pair ) {
			m_start = pair.m_start ;
			m_end = pair.m_end ;
			return *this ;
		}

		std::string const& first() const { return m_start ; }
		std::string const& second() const { return m_end ; }

		private:

		std::string m_start ;
		std::string m_end ;
	} ;

	boost::optional< std::string > load_fragmented_dna_sequence(
		std::string const& sequence,
		std::vector< KmerPair > const& kmer_pairs
	) {
		boost::optional< std::string > result ;
		std::string result_sequence ;
		std::vector< std::pair< std::size_t, std::size_t > > positions ;
		for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
#if DEBUG > 1
			std::cerr << " sequence: \"" << sequence << "\".\n" ;
			std::cerr << "kmer pair: \"" << kmer_pairs[i].first() << "\", \"" << kmer_pairs[i].second() << "\".\n" ;
#endif
			std::size_t la = kmer_pairs[i].first().size() ;
			std::size_t lb = kmer_pairs[i].second().size() ;
			// ensure kmers are each found exactly once
			int const a = sequence.find( kmer_pairs[i].first() ) ;
			int const b = sequence.find( kmer_pairs[i].second() ) ;
#if DEBUG > 1
			std::cerr << a << "(" << la << "), " << b << "(" << lb << ").\n" ;
#endif
			if( a == -1 || sequence.find( kmer_pairs[i].first(), a+1 ) != -1 ) {
				return result ;
			};
			if( b == -1 || sequence.find( kmer_pairs[i].second(), b+1 ) != -1 ) {
				return result ;
			};
#if DEBUG > 1
			std::cerr << "OK\n" ;
#endif
			// ensure b lies to the right of a,
			// and a..b lies to the right of anything seen previously.
			if(
				( b < (a+la))
				|| ((i>0) && a < ( positions[i-1].second ))
			) {
				return result ;
			} else {
				result_sequence += sequence.substr( a, b+lb-a ) ;
				positions.push_back( std::make_pair( a, b+lb ) ) ;
			}
		}
		result = result_sequence ;
#if DEBUG > 1
			std::cerr << "RESULT: \"" << result_sequence << "\".\n" ;
#endif
		return result ;
	}

	void test_load_fragmented_dna_sequence() {
		std::string sequence = "ACGTAACCGGTTAAACCCGGGTTTAAAACCCCGGGGTTTT" ;
		std::vector< KmerPair > pairs ;
		pairs.push_back( KmerPair( "CGTA", "GTTA" )) ;
		assert( !load_fragmented_dna_sequence( "", pairs ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTA", pairs ) ) ;
		assert( load_fragmented_dna_sequence( "CGTAGTTA", pairs ) ) ;
		assert( load_fragmented_dna_sequence( "CGTAGTTA", pairs )->size() == 8 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGTTAAAAA", pairs ) ) ;
		assert( load_fragmented_dna_sequence( "CGTAGTTAAAAA", pairs )->size() == 8 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGCGCGCGCGGTTA", pairs ) ) ;
		assert( load_fragmented_dna_sequence( "CGTAGCGCGCGCGGTTA", pairs )->size() == 17 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGCGCGCGCGGTTAAAAA", pairs ) ) ;
		assert( load_fragmented_dna_sequence( "CGTAGCGCGCGCGGTTAAAAA", pairs )->size() == 17 ) ;
		assert( !load_fragmented_dna_sequence( "CGTACGTAGTTA", pairs ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGTTAGTTA", pairs ) ) ;
		assert( !load_fragmented_dna_sequence( "GTTACGTA", pairs ) ) ;

		pairs.push_back( KmerPair( "GGTA", "GCTA" )) ;
		assert( !load_fragmented_dna_sequence( "CGTANGTTA", pairs ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTANGTTANGGTA", pairs ) ) ;
		assert( load_fragmented_dna_sequence( "CGTANGTTANGGTANGCTA", pairs ) ) ;
		assert( load_fragmented_dna_sequence( "CGTANGTTANGGTANGCTA", pairs )->size() == 9+9 ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGGTAGTTAGCTA", pairs ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGCTAGTTAGGTA", pairs ) ) ;
	}
}

struct TranslatoratorApplication: public appcontext::ApplicationContext
{
public:
	TranslatoratorApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new TranslatoratorOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			impl::test_load_fragmented_dna_sequence() ;
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	
	typedef genfile::GenomePositionRange Region ;
	typedef std::vector< genfile::GenomePositionRange > Regions ;
	typedef std::map< std::string, std::vector< std::string > > SequencesToReads ;
	typedef impl::KmerPair KmerPair ;

	void unsafe_process() {
		std::vector< std::string > kmers = options().get_values< std::string >( "-cds-kmers" ) ;
		{
			if( kmers.size() % 2 != 0 ) {
				throw genfile::BadArgumentError(
					"TranslatoratorApplication::unsafe_process()",
					"-cda-kmers",
					"Expected a multiple of two kmers."
				) ;
			}
		}

		std::vector< impl::KmerPair > kmer_pairs ;
		for( std::size_t i = 0; i < kmers.size(); i += 2 ) {
			kmer_pairs.push_back( impl::KmerPair( kmers[i], kmers[i+1] )) ;
		}

		SequencesToReads dna_sequences ;
		std::vector< std::string > filenames = options().get_values< std::string >( "-reads" ) ;
		load_dna_sequences(
			filenames,
			get_regions( options().get_values< std::string >( "-range" ) ),
			kmer_pairs,
			&dna_sequences
		) ;

		SequencesToReads aa_sequences ;

		for( auto kv: dna_sequences ) {
			std::cerr << kv.first << ":" ;
			for( auto read_id: kv.second ) {
				std::cerr << " \"" << read_id << "\"" ;
			}
			std::cerr << ".\n" ;
			std::string const aa_sequence = (
				((kv.first == "no_match") || (kv.first == "ambiguous_strand")) ? kv.first : genfile::translate( kv.first )
			) ;
			aa_sequences[aa_sequence].insert( aa_sequences[aa_sequence].end(), kv.second.begin(), kv.second.end() ) ;
		}

		statfile::BuiltInTypeStatSink::UniquePtr
			output = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-o" ) ) ;
		if( options().check( "-output-read-ids" )) {
			(*output) | "type" | "number_of_reads" | "sequence" | "read_ids" ;
			for( auto kv: dna_sequences ) {
				(*output) << "DNA" << kv.first << genfile::string_utils::join( kv.second, "," )  << uint64_t(kv.second.size()) << statfile::end_row() ;
			}
			for( auto kv: aa_sequences ) {
				(*output) << "AA" << kv.first << genfile::string_utils::join( kv.second, "," ) << uint64_t(kv.second.size()) << statfile::end_row() ;
			}
		} else {
			(*output) | "type" | "number_of_reads" | "sequence" ;
			for( auto kv: dna_sequences ) {
				(*output) << "DNA" << uint64_t(kv.second.size()) << kv.first << statfile::end_row() ;
			}
			for( auto kv: aa_sequences ) {
				(*output) << "AA" << uint64_t(kv.second.size()) << kv.first << statfile::end_row() ;
			}
		}
	}
	
	Regions get_regions( std::vector< std::string > const& specs ) const {
		Regions result ;
		for( auto spec: specs ) {
			genfile::GenomePositionRange region = genfile::GenomePositionRange::parse( spec ).toZeroBased() ;
			if( !region.has_chromosome() ) {
				throw genfile::BadArgumentError(
					"TranslatoratorApplication::get_regions()",
					"-training-regions=\"" + spec + "\"",
					"Regions must be specified with chromosome/contig identifiers."
				) ;
			}
			result.push_back( region ) ;
		}
		return result ;
	}
	
	void load_dna_sequences(
		std::vector< std::string > const& filenames,
		Regions const& regions,
		std::vector< impl::KmerPair > const& kmer_pairs,
		SequencesToReads* result
	) {
		using genfile::string_utils::to_string ;
		auto progress_context = ui().get_progress_context( "Processing reads" ) ;
		std::vector< std::string > const& names = get_names_from_filenames(filenames) ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			for( std::size_t region_i = 0; region_i < regions.size(); ++region_i ) {
				load_dna_sequences(
					filenames[i],
					regions[region_i],
					names[i],
					kmer_pairs,
					result
				) ;
			}
			progress_context( i+1, names.size() ) ;
		}
	}
	
	void load_dna_sequences(
		std::string const& filename,
		Region const& region,
		std::string const& name,
		std::vector< impl::KmerPair > kmer_pairs,
		SequencesToReads* result
	) const {
		try {
			load_dna_sequences_unsafe( filename, region, kmer_pairs, result ) ;
		} catch( std::exception const& e ) {
			ui().logger() << "!! Error processing \"" << name << "\", there will be no results for this file.\n" ;
		}
	}

	void load_dna_sequences_unsafe(
		std::string const& filename,
		Region const& region,
		std::vector< impl::KmerPair > kmer_pairs,
		SequencesToReads* result
	) const {
		seqlib::BamReader reader;
		
		if( options().check( "-reference" ) && filename.substr( filename.size() - 5, 5 ) == ".cram" ) {
			reader.SetCramReference( options().get< std::string >( "-reference" )) ;
		}

		if( !reader.Open( filename )) {
			assert( "Failed to open file" ) ;
		}

		{
			seqlib::BamHeader const& header = reader.Header() ;

			// Note: seqlib takes 1-baed coordinates here and holds them 1-based internally
			// But it converts to 0-based to talk to htslib under the hood.
			// The alignments also come back as 0-based.
			reader.SetRegion( seqlib::GenomicRegion( region.toString(), header )) ;

			seqlib::BamRecord alignment ;
			while( reader.GetNextRecord( alignment ) ) {
				if(
					!alignment.SecondaryFlag()
					&& !alignment.DuplicateFlag()
					&& !alignment.QCFailFlag()
					&& alignment.MappedFlag()
				) {
					std::string const& read_sequence = alignment.Sequence() ;
					boost::optional< std::string > fwd_sequence = load_fragmented_dna_sequence( read_sequence, kmer_pairs ) ;
					boost::optional< std::string > rc_sequence = load_fragmented_dna_sequence( genfile::reverse_complement( read_sequence ), kmer_pairs ) ;
					if( fwd_sequence && ! rc_sequence ) {
						(*result)[ *fwd_sequence ].push_back( alignment.Qname() ) ;
					} else if( rc_sequence && ! fwd_sequence ) {
						(*result)[ *rc_sequence ].push_back( alignment.Qname() ) ;
					} else if( fwd_sequence && rc_sequence ) {
						(*result)[ "ambiguous_strand" ].push_back( alignment.Qname() ) ;
					} else {
						(*result)[ "no_match" ].push_back( alignment.Qname() ) ;
					}
				}
			}
		}
	}
	
	std::vector< std::string > get_names_from_filenames( std::vector< std::string > const& filenames ) {
		std::vector< std::string > result ;
		for( auto s: filenames ) {
			boost::filesystem::path p( s ) ;
			result.push_back( p.stem().string() ) ;
		}
		return result ;
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		TranslatoratorApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
