
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <set>
#include <memory>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <boost/optional.hpp>
#include <boost/function.hpp>
#include <boost/format.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

// Alignment
#include "bindings/cpp/WFAligner.hpp"
#include "ssw_cpp.h"

//
#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/reverse_complement.hpp"
#include "genfile/translate.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#define DEBUG 1

namespace globals {
	std::string const program_name = "translatorator" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct TranslatoratorOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-sequences" ]
			.set_description( "Path of FASTA file, or of BAM/CRAM files to operate on.  Note that this program expects to see "
			"long DNA sequences that cover the full translated length of the target protain" )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Path of main output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-or" ]
			.set_description( "Path of per-read output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-summary" ]
			.set_description( "Path to per-sample summary output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-dna-fasta" ]
			.set_description( "Path to FASTA output file for DNA sequences." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-aa-fasta" ]
			.set_description( "Path to FASTA output file for AA sequences." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description(
				"Ignore reads that don't overlap the this range of positions (in the form <chromosome>:<position>, or <chromosome>:<start>-<end>). "
				"(Note " + globals::program_name + " uses 1-based coordinates with closed intervals.)"
				" This option implies using an indexed BAM, SAM or CRAM file as input to -sequences." )
			.set_takes_values_until_next_option()
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 1000 )
		;

		options[ "-reference" ]
			.set_description( "Specify reference sequence (mandatory when using CRAM files)" )
			.set_takes_single_value() ;
		
		options.declare_group( "Coding sequence options" ) ;
		options[ "-cds-kmers" ]
			.set_description(
				"Specify a pair of DNA kmers, on the *translation strand*, that represent the start and end of a CDS segment."
				" If the gene has multiple exons, specify this option multiple times."
			)
			.set_takes_values_until_next_option()
			.set_minimum_multiplicity(1)
			.set_minimum_multiplicity(1000) ;

		options.declare_group( "Algorithm options" ) ;
		options[ "-cluster" ]
			.set_description( "Generate a list of candidate correct sequences, and align all reads back to candidates to cluster them. "
			"Then output corrected DNA and amino acid sequences" )
		;
		options[ "-min-obs-per-sample" ]
			.set_description( "The minimum number of times a sequence must be observed in one sample, "
			" before it is treated as a candidate for clustering." )
			.set_takes_single_value()
			.set_default_value( 5 )
		;
		options[ "-min-fraction-per-sample" ]
			.set_description( "The minimum fraction of sequences must be observed in one sample, "
			" before it is treated as a candidate for clustering." )
			.set_takes_single_value()
			.set_default_value( 0.01 )
		;
		options[ "-min-obs-samples" ]
			.set_description( "The minimum number of samples a sequence must be observed in,"
			" before it is treated as a candidate for clustering." )
			.set_takes_single_value()
			.set_default_value( 1 )
		;
		options[ "-only-translatable" ]
			.set_description( "Only use sequences that are a multiple of 3 in length to cluster." )
		;
		options[ "-truncate-at-stops" ]
			.set_description( "Specify that aa sequences will be truncated at stop codons." )
		;
		options[ "-compress-homopolymers-over-length" ]
			.set_description( "Specify a homopolymer length.  All homopolymers in reads greater than this length "
			"will be truncated to the specified length before identifying common reads.  Each set of identical reads "
			"after compression will be used to form a single consensus sequence for the clustering steps." )
		;
		options[ "-min-alignment-identity" ]
			.set_description( "When summarising reads aligned to candidate correct sequences, "
			" only accept alignments with this minimum proportion of matching bases compared to alignment length" )
			.set_takes_single_value()
			.set_default_value( 0.95 )
		;

		options.option_implies_option( "-min-obs-per-sample", "-cluster" ) ;
		options.option_implies_option( "-min-obs-samples", "-cluster" ) ;
		options.option_implies_option( "-min-fraction-per-sample", "-cluster" ) ;

		options.option_excludes_option( "-only-translatable", "-truncate-at-stops" ) ;
	}
} ;

namespace impl {
	struct SequenceProvider: public boost::noncopyable {
		typedef std::unique_ptr< SequenceProvider > UniquePtr ;
		static UniquePtr open( std::string const& filename ) ;
		virtual ~SequenceProvider() {}

		virtual bool next(
			std::string* name,
			std::string* sequence,
			boost::optional< std::string >* qualities = 0
		) = 0 ;
	} ;

	struct BamSequenceProvider: public SequenceProvider {
	public:
		typedef std::unique_ptr< BamSequenceProvider > UniquePtr ;
	public:
		static UniquePtr open( std::string const& filename ) {
			return UniquePtr(
				new BamSequenceProvider( filename )
			) ;
		}

		static UniquePtr open( std::string const& filename, std::string const& reference ) {
			return UniquePtr(
				new BamSequenceProvider( filename, reference )
			) ;
		}

		BamSequenceProvider( std::string const& filename ):
			m_filename( filename )
		{
			open_bam( filename ) ;
		}

		BamSequenceProvider( std::string const& filename, std::string const& reference ):
			m_filename( filename )
		{
			// assert if not CRAM file
			// This is because SeqLib has a dangerous crashing bug in that case.
			assert( filename.substr( filename.size() - 5, 5 ) == ".cram" ) ;
			m_reader.SetCramReference( reference ) ;
			open_bam( filename ) ;
		}

		void set_region( genfile::GenomePositionRange region ) {
			// Note: seqlib takes 1-baed coordinates here and holds them 1-based internally
			// But it converts to 0-based to talk to htslib under the hood.
			// The alignments also come back as 0-based.
			m_reader.SetRegion( seqlib::GenomicRegion( region.toString(), m_header )) ;
		}

		bool next(
			std::string* name,
			std::string* sequence,
			boost::optional< std::string >* qualities
		) {
			bool result = false ;
			while(
				(result = m_reader.GetNextRecord( m_alignment ))
				&& (
					m_alignment.SecondaryFlag()
					|| m_alignment.DuplicateFlag()
					|| m_alignment.QCFailFlag()
				)
			) {}
	
			if( result ) {
				name->assign( m_alignment.Qname() ) ;
				sequence->assign( m_alignment.Sequence() ) ;
				if( qualities ) {
					(*qualities) = m_alignment.Qualities() ;
				}
			}
			return result ;
		}

	private:
		std::string m_filename ;
		seqlib::BamReader m_reader ;
		seqlib::BamHeader m_header ;
		seqlib::BamRecord m_alignment ;

		void open_bam( std::string const& filename ) {
			if( !m_reader.Open( filename )) {
				throw genfile::BadArgumentError(
					"::BamSequenceProvider::open()",
					"filename=\"" + filename + "\"",
					"Failed to open BAM file."
				) ;
			}
			m_header = m_reader.Header() ;
		}
	} ;

	struct FastaSequenceProvider: public SequenceProvider {
	public:
		typedef std::unique_ptr< FastaSequenceProvider > UniquePtr ;
		static UniquePtr open( std::string const& filename ) {
			return UniquePtr(
				new FastaSequenceProvider( filename )
			) ;
		}

		FastaSequenceProvider( std::string const& filename ):
			m_filename( filename ),
			m_i(0)
		{
			m_fasta.add_sequences_from_file( filename ) ;
		}

		bool next(
			std::string* name,
			std::string* sequence,
			boost::optional< std::string >* qualities
		) {
			if( m_i >= m_fasta.number_of_sequences() ) {
				return false ;
			}
			std::string sequence_name = m_fasta.sequence_ids()[m_i] ;
			m_fasta.get_sequence( sequence_name, &m_data ) ;
			name->assign( sequence_name ) ;
			sequence->assign( m_data.begin(), m_data.end() ) ;
			if( qualities ) {
				qualities->reset() ;
			}
			++m_i ;
			return true ;
		}

		private:
			std::string m_filename ;
			std::size_t m_i ;
			genfile::Fasta m_fasta ;
			std::deque< char > m_data ;
	} ;

	SequenceProvider::UniquePtr SequenceProvider::open( std::string const& filename ) {
		SequenceProvider::UniquePtr result ;
		auto uf = genfile::uniformise( filename ) ;
		if( uf.first == "bam" || uf.first == "sam" || uf.first == "cram" ) {
			result = BamSequenceProvider::open( filename ) ;
		} else if( uf.first == "fasta" ) {
			result = FastaSequenceProvider::open( filename ) ;
		} else {
			throw genfile::BadArgumentError(
				"impl::SequenceProvider::open()",
				"filename=\"" + filename + "\"",
				"This doesn't look like a FASTA or BAM/SAM/CRAM file!"
			) ;
		}
		return result ;
	}

	struct KmerPair {
		KmerPair() {}

		KmerPair( KmerPair const& other ):
			m_start( other.m_start ),
			m_end( other.m_end )
		{}

		KmerPair( std::string const& a, std::string const& b ):
			m_start(a),
			m_end(b)
		{}

		KmerPair& operator=( KmerPair const& pair ) {
			m_start = pair.m_start ;
			m_end = pair.m_end ;
			return *this ;
		}

		std::string const& first() const { return m_start ; }
		std::string const& second() const { return m_end ; }

		private:

		std::string m_start ;
		std::string m_end ;
	} ;

	struct Segmentation {
		public:
			enum Strand { eAmbiguousStrand = '?', eFwdStrand = '+', eRevStrand = '-', eNeitherStrand = '.' } ;
			typedef std::vector< std::pair< std::size_t, std::size_t > > SegmentationRanges ;

			Segmentation() {}

			Segmentation(
				std::string const& name,
				std::string const& sequence_name,
				Strand const strand,
				std::string const& sequence,
				std::vector< std::pair< std::size_t, std::size_t > > positions
			):
				m_name( name ),
				m_sequence_name( sequence_name ),
				m_strand( strand ),
				m_sequence( sequence ),
				m_positions( positions )
			{}

			Segmentation( Segmentation const& other ):
				m_name( other.m_name ),
				m_sequence_name( other.m_sequence_name ),
				m_strand( other.m_strand ),
				m_sequence( other.m_sequence ),
				m_positions( other.m_positions )
			{}

			std::string const& sample_id() const { return m_name ; }
			std::string const& sequence_id() const { return m_sequence_name ; }
			Strand const strand() const { return m_strand ; }
			std::string const& matching_sequence() const { return m_sequence ; }
			SegmentationRanges const& positions() const { return m_positions ; }

		private:
			std::string m_name ;
			std::string m_sequence_name ;
			Strand m_strand ;
			std::string m_sequence ;
			SegmentationRanges m_positions ;
	} ;

	struct AlignmentDetail {
		std::string a ;
		std::string b ;
		int score ;
		double identity ;
		std::string long_form_cigar ;
		std::string cigar ;
		std::string aligned_a ;
		std::string aligned_b ;
		std::size_t matches ;
		std::size_t mismatches ;
		std::size_t insertions ;
		std::size_t insertion_extensions ;
		std::size_t deletions ;
		std::size_t deletion_extensions ;
		std::size_t homopolymer_expansions ;
		std::size_t homopolymer_expansion_extensions ;
		std::size_t homopolymer_contractions ;
		std::size_t homopolymer_contraction_extensions ;

		AlignmentDetail():
			score(0),
			identity(0.0),
			matches(0),
			mismatches(0),
			insertions(0),
			insertion_extensions(0),
			deletions(0),
			deletion_extensions(0),
			homopolymer_expansions(0),
			homopolymer_expansion_extensions(0),
			homopolymer_contractions(0),
			homopolymer_contraction_extensions(0)
		 {}

		AlignmentDetail(
			std::string const& _a,
			std::string const& _b,
			int _score,
			std::string const& _cigar
		):
			a( _a ),
			b( _b ),
			score( _score ),
			identity( 0.0 ),
			long_form_cigar( _cigar ),
			cigar( runlength_encode(_cigar) ),
			matches(0),
			mismatches(0),
			insertions(0),
			insertion_extensions(0),
			deletions(0),
			deletion_extensions(0),
			homopolymer_expansions(0),
			homopolymer_expansion_extensions(0),
			homopolymer_contractions(0),
			homopolymer_contraction_extensions(0)
		{
			aligned_a.reserve( a.size() + 25 ) ;
			aligned_b.reserve( a.size() + 25 ) ;
			std::size_t sa = 0, sb = 0 ;

			struct HomopolymerTract {
				HomopolymerTract(): start(0), end(0) {}
				HomopolymerTract(
					std::string const& sequence,
					std::size_t start_
				):
					start( start_ ),
					end( 0 )
				{
					for(
						end = start ;
						sequence[end] == sequence[start];
						++end
					) ;
				}
				std::size_t start ;
				std::size_t end ;
				std::size_t length() const { return end - start ; }
			} ;
			HomopolymerTract left_homopolymer, right_homopolymer( b, 0 ) ;
			char previous_op = '*' ;
			for( std::size_t i = 0; i < long_form_cigar.size(); ++i ) {
				if( b[sb] != b[right_homopolymer.start] ) {
					left_homopolymer = right_homopolymer ;
					right_homopolymer = HomopolymerTract( b, sb ) ;
				}
				char op = long_form_cigar[i] ;
				switch( op ) {
					case 'M':
					case '=':
						++matches ;
						identity += 1.0 ;
						aligned_a.push_back( a[sa++] ) ;
						aligned_b.push_back( b[sb++] ) ;
						break ;
					case 'X':
						++mismatches ;
						aligned_a.push_back( a[sa++] ) ;
						aligned_b.push_back( b[sb++] ) ;
						break ;
					case 'D':
						if( right_homopolymer.length() > 1 && b[sb] == b[right_homopolymer.start] ) {
							long_form_cigar[i] = 'd' ;
							++homopolymer_contractions ;
							if( previous_op == 'd' ) {
								++homopolymer_contraction_extensions ;
							}
						} else {
							++deletions ;
							if( previous_op == 'D' ) {
								++deletion_extensions ;
							}
						}
						aligned_a.push_back( '-' ) ;
						aligned_b.push_back( b[sb++] ) ;
						break ;
					case 'I':
						if(
							(left_homopolymer.length() > 1 && a[sa] == b[left_homopolymer.start])
							|| (right_homopolymer.length() > 1 && a[sa] == b[right_homopolymer.start])
						) {
							long_form_cigar[i] = 'i' ;
							++homopolymer_expansions ;
							if( previous_op == 'i' ) {
								++homopolymer_contraction_extensions ;
							}
						} else {
							if( previous_op == 'I' ) {
								++insertion_extensions ;
							}
							++insertions ;
						}
						aligned_a.push_back( a[sa++] ) ;
						aligned_b.push_back( '-' ) ;
						break ;
					default:
						assert(0) ;
				}
				assert( sa <= a.size() ) ;
				assert( sb <= b.size() ) ;
			}
//			identity /= _cigar.size() ;
			cigar = runlength_encode( long_form_cigar ) ;
		}

	private:

		std::string runlength_encode( std::string const& long_form_cigar ) {
			std::string result ;
			if( long_form_cigar.size() == 0 ) {
				return long_form_cigar ;
			}
			char op = long_form_cigar[0] ;
			std::size_t i = 0 ;
			std::size_t count = 1 ;
			using genfile::string_utils::to_string ;
			for( i = 0; i < long_form_cigar.size(); ++i ) {
				if( long_form_cigar[i] == op ) {
					++count ;
				} else {
					result += to_string( count ) + op ;
					op = long_form_cigar[i] ;
					count = 1 ;
				}
			}
			result += to_string( count ) + op ;
			return result ;
		}
	} ;

	std::ostream& operator<<( std::ostream& out, AlignmentDetail const& a ) {
		return
		out << "len(A):" << a.a.size()
		<< " len(B):" << a.b.size()
		<< " AS:" << a.score
		<< " cigar:" << a.cigar
		<< " identity:" << a.identity
		<< " matches:" << a.matches
		<< " mismatches:" << a.mismatches
		<< " insertions:" << a.insertions
		<< " deletions:" << a.deletions
		<< " homopolymer expansions:" << a.homopolymer_expansions
		<< " homopolymer contractions:" << a.homopolymer_contractions ;
	}

	std::ostream& operator<<( std::ostream& out, Segmentation const& match ) {
		out
		<< "M[ "
		<< "\"" << match.sample_id() << "\" "
		<< "\"" << match.sequence_id() << "\" "
		<< std::string( 1, match.strand()) << " "
		;
		for( std::size_t i = 0; i < match.positions().size(); ++i ) {
			out
				<< ((i>0) ? "," : "")
				<< match.positions()[i].first
				<< "-"
				<< match.positions()[i].second
			;
		}
		out << " ]" ;
		return out ;
	}

	void to_lower_inplace( std::string& s ) {
		std::transform(
			s.begin(), s.end(),
			s.begin(), [](unsigned char c) { return std::tolower(c) ; }
		) ;
	}

	void to_upper_inplace( std::string& s ) {
		std::transform(
			s.begin(), s.end(),
			s.begin(), [](unsigned char c) { return std::toupper(c) ; }
		) ;
	}
	std::string to_upper( std::string const& s ) {
		std::string result = s ;
		to_upper_inplace(result) ;
		return( result ) ;
	}

	bool load_fragmented_dna_sequence(
		std::string const& sequence,
		std::vector< KmerPair > const& kmer_pairs,
		std::string* result = 0,
		std::vector< std::pair< std::size_t, std::size_t > >* ranges = 0
	) {
		std::string result_sequence ;
		std::vector< std::pair< std::size_t, std::size_t > > positions ;
		// 
		for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
#if DEBUG > 1
			std::cerr << " sequence: \"" << sequence << "\".\n" ;
			std::cerr << "kmer pair: \"" << kmer_pairs[i].first() << "\", \"" << kmer_pairs[i].second() << "\".\n" ;
#endif
			std::size_t la = kmer_pairs[i].first().size() ;
			std::size_t lb = kmer_pairs[i].second().size() ;

			// Structural variants can create extra copies of exons that 
			// aren't part of transcribed genes. (E.g  exon 6/7 of Pf3D7_1127000 in Pf FUP/H).
			// Therefore, we only look downstream of the last found kmer pair.
			std::size_t const search_start_at = ( (i>0) ? positions[i-1].second + 1 : 0 ) ;

			int const a = sequence.find( kmer_pairs[i].first(), search_start_at ) ;
			int const b = sequence.find( kmer_pairs[i].second(), search_start_at ) ;
#if DEBUG > 1
			std::cerr << a << "(" << la << "), " << b << "(" << lb << ").\n" ;
#endif
			if( a == -1 || sequence.find( kmer_pairs[i].first(), a+1 ) != -1 ) {
				return false ;
			};
			if( b == -1 || sequence.find( kmer_pairs[i].second(), b+1 ) != -1 ) {
				return false ;
			};
#if DEBUG > 1
			std::cerr << "OK\n" ;
#endif
			// ensure b lies to the right of a,
			// and a..b lies to the right of anything seen previously.
			if(
				( b < (a+la))
				|| ((i>0) && a < ( positions[i-1].second ))
			) {
				return false ;
			} else {
				result_sequence += sequence.substr( a, b+lb-a ) ;
				positions.push_back( std::make_pair( a, b+lb ) ) ;
			}
		}
		if( result ) {
			*result = result_sequence ;
		}
		if( ranges ) {
			*ranges = positions ;
		}

#if DEBUG > 1
			std::cerr << "RESULT: \"" << result_sequence << "\".\n" ;
#endif
		return true ;
	}

	void test_load_fragmented_dna_sequence() {
		std::string sequence = "ACGTAACCGGTTAAACCCGGGTTTAAAACCCCGGGGTTTT" ;
		std::vector< KmerPair > pairs ;
		std::string result ;
		std::vector< std::pair< std::size_t, std::size_t > > positions ;
		pairs.push_back( KmerPair( "CGTA", "GTTA" )) ;
		assert( !load_fragmented_dna_sequence( "", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTA", pairs, &result, &positions ) ) ;
		assert( load_fragmented_dna_sequence( "CGTAGTTA", pairs, &result, &positions ) ) ;
		assert( result.size() == 8 ) ;
		assert( positions.size() == 1 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGTTAAAAA", pairs, &result, &positions ) ) ;
		assert( result.size() == 8 ) ;
		assert( positions.size() == 1 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGCGCGCGCGGTTA", pairs, &result, &positions ) ) ;
		assert( result.size() == 17 ) ;
		assert( positions.size() == 1 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGCGCGCGCGGTTAAAAA", pairs, &result, &positions ) ) ;
		assert( result.size() == 17 ) ;
		assert( positions.size() == 1 ) ;
		assert( !load_fragmented_dna_sequence( "CGTACGTAGTTA", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGTTAGTTA", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "GTTACGTA", pairs, &result, &positions ) ) ;

		pairs.push_back( KmerPair( "GGTA", "GCTA" )) ;
		assert( !load_fragmented_dna_sequence( "CGTANGTTA", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTANGTTANGGTA", pairs, &result, &positions ) ) ;
		assert( load_fragmented_dna_sequence( "CGTANGTTANGGTANGCTA", pairs, &result, &positions ) ) ;
		assert( result.size() == 18 ) ;
		assert( positions.size() == 2 ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGGTAGTTAGCTA", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGCTAGTTAGGTA", pairs, &result, &positions ) ) ;
	}
}

struct TranslatoratorApplication: public appcontext::ApplicationContext
{
public:
	TranslatoratorApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new TranslatoratorOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			impl::test_load_fragmented_dna_sequence() ;
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	
	typedef genfile::GenomePositionRange Region ;
	typedef std::vector< genfile::GenomePositionRange > Regions ;
	typedef impl::KmerPair KmerPair ;
	typedef impl::AlignmentDetail AlignmentDetail ;
	typedef std::string Sequence ;
	typedef std::string SampleId ;
	typedef impl::Segmentation Segmentation ;

	typedef std::size_t SequenceIndex ;
	typedef uint32_t SequenceCount ;
	struct Totals {
		Totals(): total(0), matched(0) {}
		SequenceCount total ;
		SequenceCount matched ;
	} ;
	typedef std::unordered_map< SampleId, Totals > PerSampleTotals ;
	typedef std::unordered_map< SequenceIndex, SequenceCount > SegmentationCounts ;
	typedef std::unordered_map< SampleId, std::unordered_map< SequenceIndex, SequenceCount > > PerSampleSequenceCounts ;
	typedef std::vector< std::vector< impl::Segmentation > > SegmentationsBySequence ;

	struct AlgorithmData {
		AlgorithmData( std::vector< Segmentation > const& segmentations ) {
			std::map< std::string, std::vector< impl::Segmentation > > by_sequence_impl ;
			for( auto s: segmentations ) {
				++(this->per_sample_totals)[ s.sample_id() ].total ;
				if( s.strand() == impl::Segmentation::eFwdStrand || s.strand() == impl::Segmentation::eRevStrand ) {
					++(this->per_sample_totals)[ s.sample_id() ].matched ;
					by_sequence_impl[ s.matching_sequence() ].push_back( s ) ;
				}
			}

			// typedef std::unordered_map<
			//	 SampleId,
			// 	 std::unordered_map< SequenceIndex, SequenceCount >
			// > PerSampleSequenceCounts ;

			this->distinct_sequences.reserve( by_sequence_impl.size() ) ;
			this->by_sequence.reserve( by_sequence_impl.size() ) ;
			for( auto const& kv: by_sequence_impl ) {
				std::size_t const index = this->distinct_sequences.size() ;
				this->distinct_sequences.push_back( kv.first ) ;
				this->by_sequence.push_back( kv.second ) ;
				for( auto s: kv.second ) {
					++(this->per_sample_sequence_counts)[ s.sample_id() ][ index ] ;
				}
			}
		}

		std::ostream& operator<<( std::ostream& out ) {
			return out << "AlgorithmData: " << distinct_sequences.size() << " distinct sequences." ;
		}

		std::vector< Sequence > distinct_sequences ;
		SegmentationsBySequence by_sequence ;
		PerSampleTotals per_sample_totals ;
		PerSampleSequenceCounts per_sample_sequence_counts ;
	} ;

	struct PairwiseAlignments {
		struct SequencePair {
			SequencePair( SequenceIndex from_ = 0, SequenceIndex to_ = 0 ):
				from( from_ ),
				to( to_ )
			{}
			SequenceIndex from ;
			SequenceIndex to ;

			bool operator<( SequencePair const& other ) const {
				return (from < other.from) || (from == other.from && to < other.to) ;
			}
		} ;
		typedef std::map< SequencePair, AlignmentDetail > Alignments ;

		void add_sequences(
			std::vector< Sequence > sequences,
			boost::function< bool( std::size_t ) > inclusion_filter,
			boost::function< void( std::size_t, std::size_t ) > progress = 0
		) {
			// These costs are from pbmm2 defaults https://github.com/PacificBiosciences/pbmm2:
			// - "CCS" or "HIFI" 
			// --mismatch-score 1
			// --mismatch-penalty 4 
			// --gap-open-1 6 
			// --gap-extend-1 2 
			// --gap-open-2 26 
			// --gap-extend-2 1
			wfa::WFAlignerGapAffine2Pieces aligner(
				-1, // match
				4, 	// mismatch
				6, 	// gap1 open
				2,	// gap1 extend
				26, // gap2 open
				1,	// gap2 extend
				wfa::WFAligner::Alignment,
				wfa::WFAligner::MemoryHigh
			) ;
			std::size_t alignment_count = 0 ;
			for( std::size_t j = 0; j < sequences.size(); ++j ) {
				if( inclusion_filter(j)) {
					m_targets.push_back(j) ;
				}
			}
			for( std::size_t i = 0; i < sequences.size(); ++i ) {
				for( std::size_t t = 0; t < m_targets.size(); ++t ) {
					std::size_t j = m_targets[t] ;
					auto from   = sequences[i] ;
					auto to     = sequences[j] ;
					auto status = aligner.alignEnd2End( to, from ) ;
					assert( status == WF_STATUS_SUCCESSFUL ) ;
					int score = aligner.getAlignmentScore() ;
					m_alignments[ SequencePair(i,j) ] = AlignmentDetail(
						from,
						to,
						score,
						aligner.getAlignmentCigar()
					) ;
					if( progress ) {
						progress( ++alignment_count, m_targets.size() * sequences.size() ) ;
					}
				}
			}
		}

		std::vector< SequenceIndex > const& alignment_targets() const { return m_targets ; }

		AlignmentDetail const& alignment(
			SequenceIndex from,
			SequenceIndex to
		) const {
			Alignments::const_iterator where = m_alignments.find( SequencePair( from, to )) ;
			assert( where != m_alignments.end() ) ;
			return where->second ;
		}

	private:
		Alignments m_alignments ;
		std::vector< SequenceIndex > m_targets ;
	} ;

	struct AlgorithmOptions {
		bool use_clustering ;
		bool only_translatable ;
		bool truncate_at_stops ;
	} ;

	void unsafe_process() {
		AlgorithmOptions algorithm_options = {
			options().check( "-cluster" ),
			options().check( "-only-translatable" ),
			options().check( "-truncate-at-stops" ),
		} ;
		unsafe_process( algorithm_options ) ;
	}

	void unsafe_process( AlgorithmOptions const& algorithm_options ) {
		std::vector< impl::KmerPair > kmer_pairs = load_kmer_pairs( options().get_values< std::string >( "-cds-kmers" ) ) ;

		// A 'segmentation' means a set of sub-ranges of a sequence
		// which Segmentation the given kmer pairs.
		std::vector< Segmentation > segmentations ;
		find_segmentations(
			options().get_values< std::string >( "-sequences" ),
			kmer_pairs,
			&segmentations
		) ;

		ui().logger() << "++ There were " << segmentations.size() << " total sequences...\n" ;

		if( options().check( "-or" )) {
			output_translated_sequences(
				segmentations,
				options().get< std::string >( "-or" ),
				kmer_pairs,
				algorithm_options.truncate_at_stops
			) ;
		}

		if( !algorithm_options.use_clustering ) {
			return ;
		}

		// Build data structure of sequences and sequence counts per sample
		// The indices of this vector are used throughout the algorithm.

		// For likelihood computation purposes, we count the number of reads per sample
		// and also the number of each sequence observed per sample
		AlgorithmData data( segmentations ) ;
		std::cerr << "++ ...and " << data.distinct_sequences.size() << " distinct sequences.\n" ;
		PairwiseAlignments alignments ;
		{
			auto progress = ui().get_progress_context( "Pairwise aligning" ) ;
			alignments.add_sequences(
				data.distinct_sequences,
				// Only align to sequences seen at least twice
				[&data](std::size_t i)->bool { return data.by_sequence[i].size() > 1 ; },
				[&progress](std::size_t i, std::size_t j)->void { progress(i,j) ; }
			) ;
		}

		

		return ;

#if 0
		// From here on in we are clustering.
		// Find all pairwise alignments between reads.

		std::vector< std::string > representatives ;
		typedef std::unordered_map< std::string, AlignmentDetail > BestAlignments ;
		BestAlignments aligned ;

		if( use_clustering ) {
			std::size_t const min_obs_per_sample = options().get_value< std::size_t >( "-min-obs-per-sample" ) ;
			double const min_fraction_per_sample = options().get_value< double >( "-min-fraction-per-sample" ) ;
			std::size_t const min_obs_samples = options().get_value< std::size_t >( "-min-obs-samples" ) ;

			// clustering
			// First, we group everything by sequence and count reads per sample.
			// by_sequence maps from sequence to sequence matches

			// Now generate candidate sequences for alignment
			// taken as anything:
			// - seen at least a certain number of times (min_obs_per_sample)
			// - seen in at least a certain fraction of reads per sample (min_fraction_per_sample) 
			for( auto kv: by_sequence ) {
				// Figure out if this sequence has been seen enough to be a candidate
				// for clustering
				std::unordered_map< std::string, std::size_t > sequence_sample_counts ;
				std::size_t number_above_threshold = 0 ;
				for( auto const& s: kv.second ) {
					// keep track of the total number of times this sequence
					// is seen in this sample
					std::size_t& n = sequence_sample_counts[ s.sample_id() ] ;
					++n ;

					// Accumulate sample count for this sequence if it has been seen enough times
					// in this sample.
					if( n == std::max( min_obs_per_sample, std::size_t(std::ceil( min_fraction_per_sample * total_read_counts[s.sample_id()] )))) {
						++number_above_threshold ;
						if( number_above_threshold >= min_obs_samples ) {
							std::cerr << "!! accepting read with count " << n << " of " << total_read_counts[s.sample_id()] << ".\n" ;
							break ;
						}
					}
				}
				bool sequence_is_candidate = (
					(number_above_threshold >= min_obs_samples)
					&& ( (!only_translatable) || (kv.first.size() % 3 == 0) )
				) ;
				if( sequence_is_candidate ) {
					representatives.push_back( kv.first ) ;
				}
			}
			std::cerr << "++ There were " << representatives.size() << " representative sequences\n" ;
			std::cerr << "++ meeting these conditions:\n" ;
			std::cerr
				<< "   - seen in at least "
				<< min_obs_per_sample
				<< " sequence(s),\n"
				<< "   - and at least "
				<< (min_fraction_per_sample*100)
				<< "% of reads,\n"
				<< "   - in at least " << min_obs_samples << " sample(s).\n" ;
			;

			// Now all reads are mapped to the candidates
			{
				auto progress = ui().get_progress_context( "Aligning" ) ;
				// re-alignment
				// These costs are from pbmm2 defaults https://github.com/PacificBiosciences/pbmm2:
				// - "CCS" or "HIFI" --mismatch-score 1 --mismatch-penalty 4 --gap-open-1 6 --gap-extend-1 2 --gap-open-2 26 --gap-extend-2 1
	//			wfa::WFAlignerGapAffine aligner(
				wfa::WFAlignerGapAffine2Pieces aligner(
					-1, // match
					4, 	// mismatch
					6, 	// gap1 open
					2,	// gap1 extend
					26, // gap2 open
					1,	// gap2 extend
					wfa::WFAligner::Alignment,
					wfa::WFAligner::MemoryHigh
				) ;
				std::size_t alignment_count = 0 ;
				for( auto& kv: by_sequence ) {
					for( std::size_t i = 0; i < representatives.size(); ++i ) {
						std::string const& r = representatives[i] ;
						std::string sequence = kv.first ;
						std::string reference = r ;

						auto status = aligner.alignEnd2End( reference, sequence ) ;
						assert( status == WF_STATUS_SUCCESSFUL ) ;
						int score = aligner.getAlignmentScore() ;

						BestAlignments::iterator where = aligned.find( kv.first ) ;
						if( where == aligned.end() || score > where->second.score ) {
							aligned[ kv.first ] = AlignmentDetail(
								sequence,
								reference,
								score,
								aligner.getAlignmentCigar()
							) ;
						}
					}
					progress( ++alignment_count, by_sequence.size() ) ;
				}
			}
		}

		// Output reads and 'corrected'' reads
		using genfile::string_utils::to_string ;
		statfile::BuiltInTypeStatSink::UniquePtr
			output = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-o" ) ) ;
		{
			output->write_comment( "Written by translatorator" ) ;
			output->write_comment( "Kmer pairs are:" ) ;
			for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
				output->write_comment( to_string(i+1) + ": " + kmer_pairs[i].first() + " / " + kmer_pairs[i].second() ) ;
			}
			(*output) | "file" | "read_id" | "strand" ;
			for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
				(*output) | ("start_" + to_string(i+1)) | ("end_" + to_string(i+1)) ;
			}
			(*output) | "dna_sequence" ;
			if( use_clustering ) {
				(*output) | "best_alignment_score" | "best_alignment_cigar" | "best_alignment_identity" | "corrected_dna_sequence" ;
			}
			(*output) | "aa_sequence" ;
		}
		AlignmentDetail const* alignment ;
		for( auto s: result ) {
#if DEBUG > 1
			std::cerr << "kmer pairs size: " << kmer_pairs.size() << ".\n" ;
			std::cerr << s << "\n" ;
#endif
			(*output)
				<< s.sample_id()
				<< s.sequence_id()
				<< std::string( 1, s.strand() ) ;

			if( s.strand() == impl::Segmentation::eFwdStrand || s.strand() == impl::Segmentation::eRevStrand ) {
				BestAlignments::const_iterator where = aligned.find( s.matching_sequence() ) ;
				for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
					(*output)
						<< uint64_t(s.positions()[i].first + 1)
						<< uint64_t(s.positions()[i].second) ;
				}
				if( use_clustering && where != aligned.end() ) {
					(*output) << where->second.aligned_a ;
				} else {
					(*output) << s.matching_sequence() ;
				}
				if( use_clustering ) {
					if( where != aligned.end() ) {
						(*output)
							<< where->second.score
							<< where->second.cigar
							<< where->second.identity
							<< where->second.aligned_b
							<< genfile::translate( where->second.b, truncate_at_stops ) ;
					} else {
						(*output)
							<< "NA"
							<< "NA"
							<< "NA"
							<< "NA"
							<< "NA" ;
					}
				} else {
					(*output) << genfile::translate( s.matching_sequence(), truncate_at_stops ) ;
				}
			} else {
				while( output->current_column() < output->number_of_columns() ) {
					(*output) << "NA" ;
				}
			}

			(*output) << statfile::end_row() ;
		}

		// Now let's work out a per-sample summary of reads
		if( options().check( "-summary" ) || options().check( "-dna-fasta" ) || options().check( "-aa-fasta" )) {
			double const min_identity = options().get< double >( "-min-alignment-identity" ) ;
			std::map< std::string, std::map< std::string, double > > aa_sequence_summary ;
			std::map< std::string, std::map< std::string, double > > dna_sequence_summary ;
			std::map< std::string, std::size_t > dna_sequence_counts ;
			std::map< std::string, std::size_t > aa_sequence_counts ;
			for( auto s: result ) {
				if( s.strand() == impl::Segmentation::eFwdStrand || s.strand() == impl::Segmentation::eRevStrand ) {
					BestAlignments::const_iterator where = aligned.find( s.matching_sequence() ) ;
					if( use_clustering && where != aligned.end() && where->second.identity >= min_identity ) {
						std::string const& sequence =  where->second.b ;
						++dna_sequence_summary[s.sample_id()][sequence] ;
						++dna_sequence_counts[s.sample_id()] ;
						std::string translated = genfile::translate( sequence, truncate_at_stops ) ;
						if( translated != "?" ) {
							++aa_sequence_summary[s.sample_id()][translated] ;
							++aa_sequence_counts[s.sample_id()] ;
						}
						//std::cerr << "!! " << s.sample_id() << ": " << where->second.aligned_b << "\n" ;
					}
				}
			}
			if( options().check( "-summary" )) {
				statfile::BuiltInTypeStatSink::UniquePtr
					output = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-summary" ) ) ;
				{
					output->write_comment( "Written by translatorator" ) ;
					output->write_comment( "Kmer pairs are:" ) ;
					for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
						output->write_comment( to_string(i+1) + ": " + kmer_pairs[i].first() + " / " + kmer_pairs[i].second() ) ;
					}
					(*output) | "file" | "type" | "count" | "proportion" | "dna_sequence" ;
				}
				for( auto& kv: dna_sequence_summary ) {
					for( auto& sc: kv.second ) {
						(*output)
							<< kv.first
							<< "dna"
							<< sc.second
							<< sc.second / dna_sequence_counts[kv.first]
							<< sc.first
							<< statfile::end_row()
						;
					}
				}
				for( auto& kv: aa_sequence_summary ) {
					for( auto& sc: kv.second ) {
						(*output)
							<< kv.first
							<< "aa"
							<< sc.second
							<< sc.second / aa_sequence_counts[kv.first]
							<< sc.first
							<< statfile::end_row()
						;
					}
				}
			}
			if( options().check( "-dna-fasta" )) {
				std::auto_ptr< std::ostream > fasta = genfile::open_text_file_for_output( options().get< std::string >( "-dna-fasta" )) ;
				for( auto& kv: dna_sequence_summary ) {
					std::size_t const total = dna_sequence_counts[kv.first] ;
					std::size_t indicator = 1 ;
					for( auto& sc: kv.second ) {
						(*fasta)
							<< (boost::format( ">%s-%d/%d-%.1f%%-%d" ) % kv.first % sc.second % total % (100.0 * sc.second / total ) % (indicator++) )
							<< "\n"
							<< genfile::string_utils::replace_all( sc.first, "-", "" )
							<< "\n"
						;
					}
				}
			}
			if( options().check( "-aa-fasta" )) {
				std::auto_ptr< std::ostream > fasta = genfile::open_text_file_for_output( options().get< std::string >( "-aa-fasta" )) ;
				for( auto& kv: aa_sequence_summary ) {
					std::size_t const total = aa_sequence_counts[kv.first] ;
					std::size_t indicator = 1 ;
					for( auto& sc: kv.second ) {
						(*fasta)
							<< (boost::format( ">%s-%d/%d-%.1f%%-%d" ) % kv.first % sc.second % total % (100.0 * sc.second / total ) % (indicator++) )
							<< "\n"
							<< genfile::string_utils::replace_all( sc.first, "-", "" )
							<< "\n"
						;
					}
				}
			}
		}
		#endif
	}

	std::vector< impl::KmerPair > load_kmer_pairs( std::vector< std::string > const& kmers ) const {
		std::vector< impl::KmerPair > result ;

		using genfile::string_utils::to_string ;
		if( kmers.size() % 2 != 0 ) {
			throw genfile::BadArgumentError(
				"TranslatoratorApplication::load_kmer_pairs()",
				"kmers",
				"Expected there to be an even number of kmers (found " + to_string(kmers.size()) + ")"
			) ;
		}

		for( std::size_t i = 0; i < kmers.size(); i += 2 ) {
			result.push_back( impl::KmerPair( impl::to_upper(kmers[i]), impl::to_upper(kmers[i+1]) )) ;
		}
		return result ;
	}

	void output_translated_sequences(
		std::vector< Segmentation > const& result,
		std::string const& filename,
		std::vector< impl::KmerPair > kmer_pairs,
		bool truncate_at_stops
	) const {
		using genfile::string_utils::to_string ;
		statfile::BuiltInTypeStatSink::UniquePtr
			output = statfile::BuiltInTypeStatSink::open( filename ) ;
		{
			output->write_comment( "Written by translatorator" ) ;
			output->write_comment( "Kmer pairs are:" ) ;
			for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
				output->write_comment( to_string(i+1) + ": " + kmer_pairs[i].first() + " / " + kmer_pairs[i].second() ) ;
			}
			(*output) | "file" | "read_id" | "strand" ;
			for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
				(*output) | ("start_" + to_string(i+1)) | ("end_" + to_string(i+1)) ;
			}
			(*output) | "dna_sequence" ;
			(*output) | "aa_sequence" ;
		}

		for( auto s: result ) {
#if DEBUG > 1
			std::cerr << "kmer pairs size: " << kmer_pairs.size() << ".\n" ;
			std::cerr << s << "\n" ;
#endif
			(*output)
				<< s.sample_id()
				<< s.sequence_id()
				<< std::string( 1, s.strand() ) ;

			if( s.strand() == impl::Segmentation::eFwdStrand || s.strand() == impl::Segmentation::eRevStrand ) {
				for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
					(*output)
						<< uint64_t(s.positions()[i].first + 1)
						<< uint64_t(s.positions()[i].second) ;
				}
				(*output) << s.matching_sequence() ;
				(*output) << genfile::translate( s.matching_sequence(), truncate_at_stops ) ;
			} else {
				while( output->current_column() < output->number_of_columns() ) {
					(*output) << "NA" ;
				}
			}

			(*output) << statfile::end_row() ;
		}
	}

	Regions get_regions( std::vector< std::string > const& specs ) const {
		Regions result ;
		for( auto spec: specs ) {
			genfile::GenomePositionRange region = genfile::GenomePositionRange::parse( spec ).toZeroBased() ;
			if( !region.has_chromosome() ) {
				throw genfile::BadArgumentError(
					"TranslatoratorApplication::get_regions()",
					"-training-regions=\"" + spec + "\"",
					"Regions must be specified with chromosome/contig identifiers."
				) ;
			}
			result.push_back( region ) ;
		}
		return result ;
	}
	
	void find_segmentations(
		std::vector< std::string > const& filenames,
		std::vector< impl::KmerPair > const& kmer_pairs,
		std::vector< Segmentation >* result
	) {
		using genfile::string_utils::to_string ;
		auto progress_context = ui().get_progress_context( "Loading sequences" ) ;
		std::vector< std::string > const& names = get_names_from_filenames(filenames) ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			if( options().check( "-range" )) {
				Regions regions = get_regions( options().get_values< std::string >( "-range" ) ) ;
				// Only bam/sam/cram files are supported if -range is given
				impl::BamSequenceProvider::UniquePtr sequences ;
				if( options().check( "-reference" )) {
					sequences = impl::BamSequenceProvider::open( filenames[i], options().get< std::string >( "-reference" )) ;
				} else {
					sequences = impl::BamSequenceProvider::open( filenames[i] ) ;
				}
				for( auto const& region: regions ) {
					sequences->set_region( region ) ;
					find_segmentations(
						*sequences,
						names[i],
						kmer_pairs,
						result
					) ;
				}
			} else {
				impl::SequenceProvider::UniquePtr sequences = impl::SequenceProvider::open( filenames[i] ) ;
				find_segmentations(
					*sequences,
					names[i],
					kmer_pairs,
					result
				) ;
			}
			progress_context( i+1, names.size() ) ;
		}
	}
	
	void find_segmentations(
		impl::SequenceProvider& sequences,
		std::string const& name,
		std::vector< impl::KmerPair > kmer_pairs,
		std::vector< Segmentation >* result
	) const {
		try {
			find_segmentations_unsafe( name, sequences, kmer_pairs, result ) ;
		} catch( std::exception const& e ) {
			ui().logger() << "!! Error processing \"" << name << "\", there will be no results for this file.\n" ;
		}
	}

	void find_segmentations_unsafe(
		std::string const& name,
		impl::SequenceProvider& sequences,
		std::vector< impl::KmerPair > const& kmer_pairs,
		std::vector< Segmentation >* result
	) const {
		std::string sequence_name ;
		std::string sequence ;
		std::string fwd_sequence, rc_sequence ;
		impl::Segmentation::SegmentationRanges fwd_positions, rc_positions ;
		while( sequences.next( &sequence_name, &sequence )) {
			impl::to_upper_inplace( sequence ) ;
			bool fwd = load_fragmented_dna_sequence( sequence, kmer_pairs, &fwd_sequence, &fwd_positions ) ;
			bool rev = load_fragmented_dna_sequence( genfile::reverse_complement( sequence ), kmer_pairs, &rc_sequence, &rc_positions ) ;
			if( fwd ) {
				result->push_back(
					impl::Segmentation(
						name,
						sequence_name,
						impl::Segmentation::eFwdStrand,
						fwd_sequence,
						fwd_positions
					)
				) ;
			}
			if( rev ) {
				result->push_back(
					impl::Segmentation(
						name,
						sequence_name,
						impl::Segmentation::eRevStrand,
						rc_sequence,
						rc_positions
					)
				) ;
			}
			if( !fwd && !rev ) {
				result->push_back(
					impl::Segmentation(
						name,
						sequence_name,
						impl::Segmentation::eNeitherStrand,
						"",
						impl::Segmentation::SegmentationRanges()
					)
				) ;
			}
		}
	}
	
	std::vector< std::string > get_names_from_filenames( std::vector< std::string > const& filenames ) {
		std::vector< std::string > result ;
		for( auto s: filenames ) {
			boost::filesystem::path p( s ) ;
			result.push_back( p.stem().string() ) ;
		}
		return result ;
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		TranslatoratorApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
