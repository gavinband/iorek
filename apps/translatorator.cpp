
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <set>
#include <memory>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <boost/optional.hpp>
#include <boost/format.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

// Alignment
#include "bindings/cpp/WFAligner.hpp"
#include "ssw_cpp.h"

//
#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/reverse_complement.hpp"
#include "genfile/translate.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "translatorator" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct TranslatoratorOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-sequences" ]
			.set_description( "Path of bam/cram files to operate on.  Note that this program expects to see "
			"long DNA sequences that cover the full translated length of the target protain" )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-summary" ]
			.set_description( "Path to per-sample summary output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-fasta" ]
			.set_description( "Path to FASTA output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description(
				"Ignore reads that don't overlap the this range of positions (in the form <chromosome>:<position>, or <chromosome>:<start>-<end>). "
				"(Note " + globals::program_name + " uses 1-based coordinates with closed intervals.)"
				" This option implies using an indexed BAM, SAM or CRAM file as input to -sequences." )
			.set_takes_values_until_next_option()
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 1000 )
		;

		options[ "-reference" ]
			.set_description( "Specify reference sequence (mandatory when using CRAM files)" )
			.set_takes_single_value() ;
		
		options.declare_group( "Coding sequence options" ) ;
		options[ "-cds-kmers" ]
			.set_description(
				"Specify a pair of DNA kmers, on the *translation strand*, that represent the start and end of a CDS segment."
				" If the gene has multiple exons, specify this option multiple times."
			)
			.set_takes_values_until_next_option()
			.set_minimum_multiplicity(1)
			.set_minimum_multiplicity(1000) ;

		options.declare_group( "Algorithm options" ) ;
		options[ "-cluster" ]
			.set_description( "Output corrected DNA and amino acid sequences, by clustering sequences"
			" and finding the highest-scoring alignments." )
		;
		options[ "-min-obs-per-sample" ]
			.set_description( "The minimum number of times a sequence must be observed in one sample, "
			" before it is treated as a candidate for clustering." )
			.set_takes_single_value()
			.set_default_value( 5 )
		;
		options[ "-min-fraction-per-sample" ]
			.set_description( "The minimum fraction of sequences must be observed in one sample, "
			" before it is treated as a candidate for clustering." )
			.set_takes_single_value()
			.set_default_value( 0.01 )
		;
		options[ "-min-obs-samples" ]
			.set_description( "The minimum number of samples a sequence must be observed in,"
			" before it is treated as a candidate for clustering." )
			.set_takes_single_value()
			.set_default_value( 1 )
		;
		options[ "-only-translatable" ]
			.set_description( "Only take sequences that are a multiple of 3 in length to cluster." )
		;

		options.option_implies_option( "-min-obs-per-sample", "-cluster" ) ;
		options.option_implies_option( "-min-obs-samples", "-cluster" ) ;
		options.option_implies_option( "-min-fraction-per-sample", "-cluster" ) ;

	}
} ;

namespace impl {
	struct SequenceProvider: public boost::noncopyable {
		typedef std::unique_ptr< SequenceProvider > UniquePtr ;
		static UniquePtr open( std::string const& filename ) ;
		virtual ~SequenceProvider() {}

		virtual bool next(
			std::string* name,
			std::string* sequence,
			boost::optional< std::string >* qualities = 0
		) = 0 ;
	} ;

	struct BamSequenceProvider: public SequenceProvider {
	public:
		typedef std::unique_ptr< BamSequenceProvider > UniquePtr ;
	public:
		static UniquePtr open( std::string const& filename ) {
			return UniquePtr(
				new BamSequenceProvider( filename )
			) ;
		}

		static UniquePtr open( std::string const& filename, std::string const& reference ) {
			return UniquePtr(
				new BamSequenceProvider( filename, reference )
			) ;
		}

		BamSequenceProvider( std::string const& filename ):
			m_filename( filename )
		{
			open_bam( filename ) ;
		}

		BamSequenceProvider( std::string const& filename, std::string const& reference ):
			m_filename( filename )
		{
			// assert if not CRAM file
			// This is because SeqLib has a dangerous crashing bug in that case.
			assert( filename.substr( filename.size() - 5, 5 ) == ".cram" ) ;
			m_reader.SetCramReference( reference ) ;
			open_bam( filename ) ;
		}

		void set_region( genfile::GenomePositionRange region ) {
			// Note: seqlib takes 1-baed coordinates here and holds them 1-based internally
			// But it converts to 0-based to talk to htslib under the hood.
			// The alignments also come back as 0-based.
			m_reader.SetRegion( seqlib::GenomicRegion( region.toString(), m_header )) ;
		}

		bool next(
			std::string* name,
			std::string* sequence,
			boost::optional< std::string >* qualities
		) {
			bool result = false ;
			while(
				(result = m_reader.GetNextRecord( m_alignment ))
				&& (
					m_alignment.SecondaryFlag()
					|| m_alignment.DuplicateFlag()
					|| m_alignment.QCFailFlag()
				)
			) {}
	
			if( result ) {
				name->assign( m_alignment.Qname() ) ;
				sequence->assign( m_alignment.Sequence() ) ;
				if( qualities ) {
					(*qualities) = m_alignment.Qualities() ;
				}
			}
			return result ;
		}

	private:
		std::string m_filename ;
		seqlib::BamReader m_reader ;
		seqlib::BamHeader m_header ;
		seqlib::BamRecord m_alignment ;

		void open_bam( std::string const& filename ) {
			if( !m_reader.Open( filename )) {
				throw genfile::BadArgumentError(
					"::BamSequenceProvider::open()",
					"filename=\"" + filename + "\"",
					"Failed to open BAM file."
				) ;
			}
			m_header = m_reader.Header() ;
		}
	} ;

	struct FastaSequenceProvider: public SequenceProvider {
	public:
		typedef std::unique_ptr< FastaSequenceProvider > UniquePtr ;
		static UniquePtr open( std::string const& filename ) {
			return UniquePtr(
				new FastaSequenceProvider( filename )
			) ;
		}

		FastaSequenceProvider( std::string const& filename ):
			m_filename( filename ),
			m_i(0)
		{
			m_fasta.add_sequences_from_file( filename ) ;
		}

		bool next(
			std::string* name,
			std::string* sequence,
			boost::optional< std::string >* qualities
		) {
			if( m_i >= m_fasta.number_of_sequences() ) {
				return false ;
			}
			std::string sequence_name = m_fasta.sequence_ids()[m_i] ;
			m_fasta.get_sequence( sequence_name, &m_data ) ;
			name->assign( sequence_name ) ;
			sequence->assign( m_data.begin(), m_data.end() ) ;
			if( qualities ) {
				qualities->reset() ;
			}
			++m_i ;
			return true ;
		}

		private:
			std::string m_filename ;
			std::size_t m_i ;
			genfile::Fasta m_fasta ;
			std::deque< char > m_data ;
	} ;

	SequenceProvider::UniquePtr SequenceProvider::open( std::string const& filename ) {
		SequenceProvider::UniquePtr result ;
		auto uf = genfile::uniformise( filename ) ;
		if( uf.first == "bam" || uf.first == "sam" || uf.first == "cram" ) {
			result = BamSequenceProvider::open( filename ) ;
		} else if( uf.first == "fasta" ) {
			result = FastaSequenceProvider::open( filename ) ;
		} else {
			throw genfile::BadArgumentError(
				"impl::SequenceProvider::open()",
				"filename=\"" + filename + "\"",
				"This doesn't look like a FASTA or BAM/SAM/CRAM file!"
			) ;
		}
		return result ;
	}

	struct KmerPair {
		KmerPair() {}

		KmerPair( KmerPair const& other ):
			m_start( other.m_start ),
			m_end( other.m_end )
		{}

		KmerPair( std::string const& a, std::string const& b ):
			m_start(a),
			m_end(b)
		{}

		KmerPair& operator=( KmerPair const& pair ) {
			m_start = pair.m_start ;
			m_end = pair.m_end ;
			return *this ;
		}

		std::string const& first() const { return m_start ; }
		std::string const& second() const { return m_end ; }

		private:

		std::string m_start ;
		std::string m_end ;
	} ;

	struct Match {
		public:
			enum Strand { eAmbiguousStrand = '?', eFwdStrand = '+', eRevStrand = '-', eNeitherStrand = '.' } ;
			typedef std::vector< std::pair< std::size_t, std::size_t > > MatchRanges ;

			Match() {}

			Match(
				std::string const& name,
				std::string const& sequence_name,
				Strand const strand,
				std::string const& sequence,
				std::vector< std::pair< std::size_t, std::size_t > > positions
			):
				m_name( name ),
				m_sequence_name( sequence_name ),
				m_strand( strand ),
				m_sequence( sequence ),
				m_positions( positions )
			{}

			Match( Match const& other ):
				m_name( other.m_name ),
				m_sequence_name( other.m_sequence_name ),
				m_strand( other.m_strand ),
				m_sequence( other.m_sequence ),
				m_positions( other.m_positions )
			{}

			std::string const& name() const { return m_name ; }
			std::string const& sequence_name() const { return m_sequence_name ; }
			Strand const strand() const { return m_strand ; }
			std::string const& sequence() const { return m_sequence ; }
			MatchRanges const& positions() const { return m_positions ; }

		private:
			std::string m_name ;
			std::string m_sequence_name ;
			Strand m_strand ;
			std::string m_sequence ;
			MatchRanges m_positions ;
	} ;

	std::ostream& operator<<( std::ostream& out, Match const& match ) {
		out
		<< "M[ "
		<< "\"" << match.name() << "\" "
		<< "\"" << match.sequence_name() << "\" "
		<< std::string( 1, match.strand()) << " "
		;
		for( std::size_t i = 0; i < match.positions().size(); ++i ) {
			out
				<< ((i>0) ? "," : "")
				<< match.positions()[i].first
				<< "-"
				<< match.positions()[i].second
			;
		}
		out << " ]" ;
		return out ;
	}

	bool load_fragmented_dna_sequence(
		std::string const& sequence,
		std::vector< KmerPair > const& kmer_pairs,
		std::string* result = 0,
		std::vector< std::pair< std::size_t, std::size_t > >* ranges = 0
	) {
		std::string result_sequence ;
		std::vector< std::pair< std::size_t, std::size_t > > positions ;
		for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
#if DEBUG > 1
			std::cerr << " sequence: \"" << sequence << "\".\n" ;
			std::cerr << "kmer pair: \"" << kmer_pairs[i].first() << "\", \"" << kmer_pairs[i].second() << "\".\n" ;
#endif
			std::size_t la = kmer_pairs[i].first().size() ;
			std::size_t lb = kmer_pairs[i].second().size() ;
			// ensure kmers are each found exactly once
			int const a = sequence.find( kmer_pairs[i].first() ) ;
			int const b = sequence.find( kmer_pairs[i].second() ) ;
#if DEBUG > 1
			std::cerr << a << "(" << la << "), " << b << "(" << lb << ").\n" ;
#endif
			if( a == -1 || sequence.find( kmer_pairs[i].first(), a+1 ) != -1 ) {
				return false ;
			};
			if( b == -1 || sequence.find( kmer_pairs[i].second(), b+1 ) != -1 ) {
				return false ;
			};
#if DEBUG > 1
			std::cerr << "OK\n" ;
#endif
			// ensure b lies to the right of a,
			// and a..b lies to the right of anything seen previously.
			if(
				( b < (a+la))
				|| ((i>0) && a < ( positions[i-1].second ))
			) {
				return false ;
			} else {
				result_sequence += sequence.substr( a, b+lb-a ) ;
				positions.push_back( std::make_pair( a, b+lb ) ) ;
			}
		}
		if( result ) {
			*result = result_sequence ;
		}
		if( ranges ) {
			*ranges = positions ;
		}

#if DEBUG > 1
			std::cerr << "RESULT: \"" << result_sequence << "\".\n" ;
#endif
		return true ;
	}

	void test_load_fragmented_dna_sequence() {
		std::string sequence = "ACGTAACCGGTTAAACCCGGGTTTAAAACCCCGGGGTTTT" ;
		std::vector< KmerPair > pairs ;
		std::string result ;
		std::vector< std::pair< std::size_t, std::size_t > > positions ;
		pairs.push_back( KmerPair( "CGTA", "GTTA" )) ;
		assert( !load_fragmented_dna_sequence( "", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTA", pairs, &result, &positions ) ) ;
		assert( load_fragmented_dna_sequence( "CGTAGTTA", pairs, &result, &positions ) ) ;
		assert( result.size() == 8 ) ;
		assert( positions.size() == 1 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGTTAAAAA", pairs, &result, &positions ) ) ;
		assert( result.size() == 8 ) ;
		assert( positions.size() == 1 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGCGCGCGCGGTTA", pairs, &result, &positions ) ) ;
		assert( result.size() == 17 ) ;
		assert( positions.size() == 1 ) ;
		assert( load_fragmented_dna_sequence( "CGTAGCGCGCGCGGTTAAAAA", pairs, &result, &positions ) ) ;
		assert( result.size() == 17 ) ;
		assert( positions.size() == 1 ) ;
		assert( !load_fragmented_dna_sequence( "CGTACGTAGTTA", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGTTAGTTA", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "GTTACGTA", pairs, &result, &positions ) ) ;

		pairs.push_back( KmerPair( "GGTA", "GCTA" )) ;
		assert( !load_fragmented_dna_sequence( "CGTANGTTA", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTANGTTANGGTA", pairs, &result, &positions ) ) ;
		assert( load_fragmented_dna_sequence( "CGTANGTTANGGTANGCTA", pairs, &result, &positions ) ) ;
		assert( result.size() == 18 ) ;
		assert( positions.size() == 2 ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGGTAGTTAGCTA", pairs, &result, &positions ) ) ;
		assert( !load_fragmented_dna_sequence( "CGTAGCTAGTTAGGTA", pairs, &result, &positions ) ) ;
	}
}

struct TranslatoratorApplication: public appcontext::ApplicationContext
{
public:
	TranslatoratorApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new TranslatoratorOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			impl::test_load_fragmented_dna_sequence() ;
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	
	typedef genfile::GenomePositionRange Region ;
	typedef std::vector< genfile::GenomePositionRange > Regions ;
	typedef std::vector< impl::Match > SequencesToReads ;
	typedef impl::KmerPair KmerPair ;
	struct AlignmentDetail {
		std::string a ;
		std::string b ;
		int score ;
		std::string cigar ;
		std::string aligned_a ;
		std::string aligned_b ;

		AlignmentDetail() {}

		AlignmentDetail(
			std::string const& _a,
			std::string const& _b,
			int _score,
			std::string const& _cigar
		):
			a( _a ),
			b( _b ),
			score( _score ),
			cigar( runlength_encode(_cigar) )
		{
			aligned_a.reserve( a.size() + 25 ) ;
			aligned_b.reserve( a.size() + 25 ) ;
			std::size_t sa = 0, sb = 0 ;
			for( std::size_t i = 0; i < _cigar.size(); ++i ) {
				switch( _cigar[i] ) {
					case 'M':
					case '=':
					case 'X':
						aligned_a.push_back( a[sa++] ) ;
						aligned_b.push_back( b[sb++] ) ;
						break ;
					case 'D':
						aligned_a.push_back( '-' ) ;
						aligned_b.push_back( b[sb++] ) ;
						break ;
					case 'I':
						aligned_a.push_back( a[sa++] ) ;
						aligned_b.push_back( '-' ) ;
						break ;
				}
				assert( sa <= a.size() ) ;
				assert( sb <= b.size() ) ;
			}
		}
		private:

		std::string runlength_encode( std::string const& cigar ) {
			std::string result ;
			if( cigar.size() == 0 ) {
				return cigar ;
			}
			char op = cigar[0] ;
			std::size_t i = 0 ;
			std::size_t count = 1 ;
			using genfile::string_utils::to_string ;
			for( i = 0; i < cigar.size(); ++i ) {
				if( cigar[i] == op ) {
					++count ;
				} else {
					result += to_string( count ) + op ;
					op = cigar[i] ;
					count = 1 ;
				}
			}
			result += to_string( count ) + op ;
			return result ;
		}
	} ;
	

	void unsafe_process() {
		std::vector< std::string > kmers = options().get_values< std::string >( "-cds-kmers" ) ;
		{
			if( kmers.size() % 2 != 0 ) {
				throw genfile::BadArgumentError(
					"TranslatoratorApplication::unsafe_process()",
					"-cda-kmers",
					"Expected a multiple of two kmers."
				) ;
			}
		}

		std::vector< impl::KmerPair > kmer_pairs ;
		for( std::size_t i = 0; i < kmers.size(); i += 2 ) {
			kmer_pairs.push_back( impl::KmerPair( kmers[i], kmers[i+1] )) ;
		}

		SequencesToReads result ;
		std::vector< std::string > filenames = options().get_values< std::string >( "-sequences" ) ;
		load_dna_sequences(
			filenames,
			kmer_pairs,
			&result
		) ;

		ui().logger() << "++ There were " << result.size() << " total sequences.\n" ;
		std::vector< std::string > representatives ;
		typedef std::unordered_map< std::string, AlignmentDetail > BestAlignments ;
		BestAlignments aligned ;

		bool const use_clustering = options().check( "-cluster" ) ;
		if( use_clustering ) {
			std::size_t const min_obs_per_sample = options().get_value< std::size_t >( "-min-obs-per-sample" ) ;
			double const min_fraction_per_sample = options().get_value< double >( "-min-fraction-per-sample" ) ;
			std::size_t const min_obs_samples = options().get_value< std::size_t >( "-min-obs-samples" ) ;
			bool const only_translatable = options().check( "-only-translatable" ) ;

			// clustering
			// First, we group everything by sequence and count reads per sample:
			std::map< std::string, std::vector< impl::Match > > by_sequence ;
			std::unordered_map< std::string, std::size_t > total_read_counts ;
			for( auto s: result ) {
				if( s.strand() == impl::Match::eFwdStrand || s.strand() == impl::Match::eRevStrand ) {
					by_sequence[s.sequence()].push_back( s ) ;
					++total_read_counts[s.name()] ;
				}
			}
			std::cerr << "++ There were " << by_sequence.size() << " distinct sequences.\n" ;

			// Now generate candidate sequences for alignment
			// taken as anything:
			// - seen at least a certain number of times (min_obs_per_sample)
			// - seen in at least a certain fraction of reads per sample (min_fraction_per_sample) 
			for( auto kv: by_sequence ) {
				// Figure out if this sequence has been seen enough to be a candidate
				// for clustering
				std::unordered_map< std::string, std::size_t > sequence_sample_counts ;
				std::size_t number_above_threshold = 0 ;
				for( auto const& s: kv.second ) {
					// keep track of the total number of reads seen for this sequ
					std::size_t& n = sequence_sample_counts[ s.name() ] ;
					++n ;

					// If this sequence has been seen in this sample enough times, which means
					if( n == std::max( min_obs_per_sample, std::size_t(std::ceil( min_fraction_per_sample * total_read_counts[s.name()] )))) {
						++number_above_threshold ;
						if( number_above_threshold >= min_obs_samples ) {
							std::cerr << "!! accepting read with count " << n << " of " << total_read_counts[s.name()] << ".\n" ;
							break ;
						}
					}
				}
				bool sequence_is_candidate = (number_above_threshold >= min_obs_samples) ;
				if( sequence_is_candidate ) {
					representatives.push_back( kv.first ) ;
				}
			}
			std::cerr << "++ There were " << representatives.size() << " representative sequences\n" ;
			std::cerr << "++ meeting these conditions:\n" ;
			std::cerr
				<< "   - seen in at least "
				<< min_obs_per_sample
				<< " sequence(s),\n"
				<< "   - and at least "
				<< (min_fraction_per_sample*100)
				<< "% of reads,\n"
				<< "   - in at least " << min_obs_samples << " sample(s).\n" ;
			;

			// Now all reads are mapped to the candidates
			{
				auto progress = ui().get_progress_context( "Aligning" ) ;
				// re-alignment
				// These costs are from pbmm2 defaults https://github.com/PacificBiosciences/pbmm2:
				// - "CCS" or "HIFI" --mismatch-score 1 --mismatch-penalty 4 --gap-open-1 6 --gap-extend-1 2 --gap-open-2 26 --gap-extend-2 1
	//			wfa::WFAlignerGapAffine aligner(
				wfa::WFAlignerGapAffine2Pieces aligner(
					-1, // match
					4, 	// mismatch
					6, 	// gap1 open
					2,	// gap1 extend
					26, // gap2 open
					1,	// gap2 extend
					wfa::WFAligner::Alignment,
					wfa::WFAligner::MemoryHigh
				) ;
				std::size_t alignment_count = 0 ;
				for( auto& kv: by_sequence ) {
					for( std::size_t i = 0; i < representatives.size(); ++i ) {
						std::string const& r = representatives[i] ;
						std::string sequence = kv.first ;
						std::string reference = r ;

						auto status = aligner.alignEnd2End( reference, sequence ) ;
						assert( status == WF_STATUS_SUCCESSFUL ) ;
						int score = aligner.getAlignmentScore() ;

						BestAlignments::iterator where = aligned.find( kv.first ) ;
						if( where == aligned.end() || score > where->second.score ) {
							aligned[ kv.first ] = AlignmentDetail(
								sequence,
								reference,
								score,
								aligner.getAlignmentCigar()
							) ;
						}
					}
					progress( ++alignment_count, by_sequence.size() ) ;
				}
			}
		}

		// Output reads and clustered reads
		using genfile::string_utils::to_string ;
		statfile::BuiltInTypeStatSink::UniquePtr
			output = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-o" ) ) ;
		{
			output->write_comment( "Written by translatorator" ) ;
			output->write_comment( "Kmer pairs are:" ) ;
			for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
				output->write_comment( to_string(i+1) + ": " + kmer_pairs[i].first() + " / " + kmer_pairs[i].second() ) ;
			}
			(*output) | "file" | "read_id" | "strand" | "dna_sequence" ;
			for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
				(*output) | ("start_" + to_string(i+1)) | ("end_" + to_string(i+1)) ;
			}
			if( use_clustering ) {
				(*output) | "best_alignment_score" | "alignment_cigar" | "corrected_dna_sequence" ;
			}
			(*output) | "aa_sequence" ;
		}
		AlignmentDetail const* alignment ;
		for( auto s: result ) {
#if DEBUG > 1
			std::cerr << "kmer pairs size: " << kmer_pairs.size() << ".\n" ;
			std::cerr << s << "\n" ;
#endif
			(*output)
				<< s.name()
				<< s.sequence_name()
				<< std::string( 1, s.strand() ) ;

			if( s.strand() == impl::Match::eFwdStrand || s.strand() == impl::Match::eRevStrand ) {
				BestAlignments::const_iterator where = aligned.find( s.sequence() ) ;
				if( use_clustering && where != aligned.end() ) {
					(*output) << where->second.aligned_a ;
				} else {
					(*output) << s.sequence() ;
				}
				for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
					(*output)
						<< uint64_t(s.positions()[i].first + 1)
						<< uint64_t(s.positions()[i].second) ;
				}
				if( use_clustering ) {
					if( where != aligned.end() ) {
						(*output)
							<< where->second.score
							<< where->second.cigar
							<< where->second.aligned_b
							<< genfile::translate( where->second.b ) ;
					} else {
						(*output)
							<< "NA"
							<< "NA"
							<< "NA"
							<< "NA" ;
					}
				} else {
					(*output) << genfile::translate( s.sequence() ) ;
				}
			} else {
				while( output->current_column() < output->number_of_columns() ) {
					(*output) << "NA" ;
				}
			}

			(*output) << statfile::end_row() ;
		}

		// Now let's work out a per-sample summary of reads
		if( options().check( "-summary" ) || options().check( "-fasta" ) ) {
			std::map< std::string, std::map< std::string, double > > summary ;
			std::map< std::string, std::size_t > counts ;
			for( auto s: result ) {
				if( s.strand() == impl::Match::eFwdStrand || s.strand() == impl::Match::eRevStrand ) {
					BestAlignments::const_iterator where = aligned.find( s.sequence() ) ;
					if( use_clustering && where != aligned.end() ) {
						std::string sequence = genfile::string_utils::replace_all( where->second.aligned_b, "-", "" ) ;
						++summary[s.name()][sequence] ;
						++counts[s.name()] ;
						//std::cerr << "!! " << s.name() << ": " << where->second.aligned_b << "\n" ;
					}
				}
				if( options().check( "-summary" )) {
					statfile::BuiltInTypeStatSink::UniquePtr
						output = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-summary" ) ) ;
					{
						output->write_comment( "Written by translatorator" ) ;
						output->write_comment( "Kmer pairs are:" ) ;
						for( std::size_t i = 0; i < kmer_pairs.size(); ++i ) {
							output->write_comment( to_string(i+1) + ": " + kmer_pairs[i].first() + " / " + kmer_pairs[i].second() ) ;
						}
						(*output) | "file" | "count" | "proportion" | "dna_sequence" ;
					}
					for( auto& kv: summary ) {
						for( auto& sc: kv.second ) {
							(*output)
								<< kv.first
								<< sc.second
								<< sc.second / counts[kv.first]
								<< sc.first
								<< statfile::end_row()
							;
						}
					}
				}
				if( options().check( "-fasta" )) {
					std::auto_ptr< std::ostream > fasta = genfile::open_text_file_for_output( options().get< std::string >( "-fasta" )) ;
					for( auto& kv: summary ) {
						std::size_t const total = counts[kv.first] ;
						for( auto& sc: kv.second ) {
							(*fasta)
								<< (boost::format( ">%s-%d/%d-%.1f%%" ) % kv.first % sc.second % total % (100.0 * sc.second / total ) )
								<< "\n"
								<< genfile::string_utils::replace_all( sc.first, "-", "" )
								<< "\n"
							;
						}
					}
				}
			}
		}
	}

	Regions get_regions( std::vector< std::string > const& specs ) const {
		Regions result ;
		for( auto spec: specs ) {
			genfile::GenomePositionRange region = genfile::GenomePositionRange::parse( spec ).toZeroBased() ;
			if( !region.has_chromosome() ) {
				throw genfile::BadArgumentError(
					"TranslatoratorApplication::get_regions()",
					"-training-regions=\"" + spec + "\"",
					"Regions must be specified with chromosome/contig identifiers."
				) ;
			}
			result.push_back( region ) ;
		}
		return result ;
	}
	
	void load_dna_sequences(
		std::vector< std::string > const& filenames,
		std::vector< impl::KmerPair > const& kmer_pairs,
		SequencesToReads* result
	) {
		using genfile::string_utils::to_string ;\
		auto progress_context = ui().get_progress_context( "Loading sequences" ) ;
		std::vector< std::string > const& names = get_names_from_filenames(filenames) ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			if( options().check( "-range" )) {
				Regions regions = get_regions( options().get_values< std::string >( "-range" ) ) ;
				// Only bam/sam/cram files are supported if -range is given
				impl::BamSequenceProvider::UniquePtr sequences ;
				if( options().check( "-reference" )) {
					sequences = impl::BamSequenceProvider::open( filenames[i], options().get< std::string >( "-reference" )) ;
				} else {
					sequences = impl::BamSequenceProvider::open( filenames[i] ) ;
				}
				for( auto const& region: regions ) {
					sequences->set_region( region ) ;
					load_dna_sequences(
						*sequences,
						names[i],
						kmer_pairs,
						result
					) ;
				}
			} else {
				impl::SequenceProvider::UniquePtr sequences = impl::SequenceProvider::open( filenames[i] ) ;
				load_dna_sequences(
					*sequences,
					names[i],
					kmer_pairs,
					result
				) ;
			}
			progress_context( i+1, names.size() ) ;
		}
	}
	
	void load_dna_sequences(
		impl::SequenceProvider& sequences,
		std::string const& name,
		std::vector< impl::KmerPair > kmer_pairs,
		SequencesToReads* result
	) const {
		try {
			load_dna_sequences_unsafe( name, sequences, kmer_pairs, result ) ;
		} catch( std::exception const& e ) {
			ui().logger() << "!! Error processing \"" << name << "\", there will be no results for this file.\n" ;
		}
	}

	void load_dna_sequences_unsafe(
		std::string const& name,
		impl::SequenceProvider& sequences,
		std::vector< impl::KmerPair > const& kmer_pairs,
		SequencesToReads* result
	) const {
		std::string sequence_name ;
		std::string sequence ;
		std::string fwd_sequence, rc_sequence ;
		impl::Match::MatchRanges fwd_positions, rc_positions ;
		while( sequences.next( &sequence_name, &sequence )) {
			bool fwd = load_fragmented_dna_sequence( sequence, kmer_pairs, &fwd_sequence, &fwd_positions ) ;
			bool rev = load_fragmented_dna_sequence( genfile::reverse_complement( sequence ), kmer_pairs, &rc_sequence, &rc_positions ) ;
			if( fwd ) {
				result->push_back(
					impl::Match(
						name,
						sequence_name,
						impl::Match::eFwdStrand,
						fwd_sequence,
						fwd_positions
					)
				) ;
			}
			if( rev ) {
				result->push_back(
					impl::Match(
						name,
						sequence_name,
						impl::Match::eRevStrand,
						rc_sequence,
						rc_positions
					)
				) ;
			}
			if( !fwd && !rev ) {
				result->push_back(
					impl::Match(
						name,
						sequence_name,
						impl::Match::eNeitherStrand,
						"",
						impl::Match::MatchRanges()
					)
				) ;
			}
		}
	}
	
	std::vector< std::string > get_names_from_filenames( std::vector< std::string > const& filenames ) {
		std::vector< std::string > result ;
		for( auto s: filenames ) {
			boost::filesystem::path p( s ) ;
			result.push_back( p.stem().string() ) ;
		}
		return result ;
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		TranslatoratorApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
