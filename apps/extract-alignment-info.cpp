
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <unordered_map>
#include <unordered_set>
#include <set>
#include <algorithm>
#include <boost/filesystem.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "appcontext/get_current_time_as_string.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "extract-alignment-info" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct IorekOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_single_value()
			.set_is_required()
		;
		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description( "Genomic regions (expressed in the form <chromosome>:<start>-<end>)"
				" to process.  Regions are expressed in 1-based, right-closed coordinates."
				" (These regions should have few copy number variants)" 
				" Alternatively this can be the name of a file containing a list of regions."
			)
			.set_takes_single_value()
		;
		options[ "-tags" ]
			.set_description( "Specify reference sequence" )
			.set_takes_values_until_next_option()
			.set_is_required()
			.set_default_value( "NM" )
			.set_default_value( "AS" )
		;

		options[ "-cigar" ]
			.set_description( "Specify that the CIGAR string should be included in output." )
		;
	}
} ;

namespace {
	enum MismatchType {
		eMatch = '=',
		eMismatch = 'X',
		eDeletion = 'D',
		eInsertion = 'I'
	} ;
}

struct IorekApplication: public appcontext::ApplicationContext
{
public:
	IorekApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new IorekOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:

	void unsafe_process() {
		unsafe_process(
			options().get_value< std::string >( "-reads" )
		) ;
	}

	void unsafe_process(
		std::string const& filename
	) {
		statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open(
			options().get< std::string >( "-o" )
		) ;
		sink->write_metadata(
			"Computed by " + globals::program_name + " at " + appcontext::get_current_time_as_string() + "\n"
		) ;
		
		process_reads( filename, *sink ) ;
	}
	
	void process_reads(
		std::string const& filename,
		statfile::BuiltInTypeStatSink& sink
	) {
		seqlib::BamReader reader;
		if( options().check( "-reference" )) {
			reader.SetCramReference( options().get< std::string >( "-reference" )) ;
		}
		if( !reader.Open( filename )) {
			assert( "Failed to open file" ) ;
		}
		seqlib::BamHeader const& header = reader.Header() ;
		if( options().check( "-range" )) {
			//std::string const range = options().get< std::string >( "-range" ) ;
			genfile::GenomePositionRange range = genfile::GenomePositionRange::parse( options().get< std::string >( "-range" )) ;
			try {
				// note:  SeqLib is a bit weird on positions.
				// htslib uses 0-based, half-open positions throughout.  See e.g. the hts_parse_reg function which SeqLib uses here under the hood.
				// However, SeqLib changes this back into a 1-based, closed position internally.
				// I found that to correctly capture all reads covering range positions in the range
				// an expanded range is needed.  Therefore I extend both leftwards and rightwards by one.
				// This is ok here because actual precise filtering of positions is done in process_reads() below.
				std::string const range_as_string = (
					std::string(range.chromosome())
					+ ":"
					+ genfile::string_utils::to_string( std::max( int( range.start().position() ) -1, 0 ))
					+ "-"
					+ genfile::string_utils::to_string( range.end().position() + 1 )
				) ;
				seqlib::GenomicRegion R( range_as_string, header) ;
				std::cerr << "Setting range: " << range.toString() << ", " << range_as_string << ": " << R << "\n" ;
				if( !reader.SetRegion( seqlib::GenomicRegion( range_as_string, header ))) {
					throw genfile::BadArgumentError(
						"seqlib::GenomicRegion()",
						"-range",
						"A BAM/CRAM index file (.bai/.crai) must be available to use -range."
					) ;
				}
			} catch( std::invalid_argument const& e ) {
				throw genfile::BadArgumentError(
					"seqlib::GenomicRegion()",
					"region=\"" + range.toString() + "\"",
					"Failed for file \"" + filename + "\""
				) ;
			}
		}
		
		auto progress_context = ui().get_progress_context( "Processing \"" + filename + "\"" ) ;
		process_reads( reader, header, sink, [&] ( std::size_t count ) { progress_context( count ) ; } ) ;
	}

	struct TagSpec {
		TagSpec() {}
		TagSpec(
			std::string const& _tag_name,
			std::string const& _name
		):
			tag_name( _tag_name ),
			human_readable_name( _name )
		{}
		TagSpec( TagSpec const& other ):
			tag_name( other.tag_name ),
			human_readable_name( other.human_readable_name )
		{}
		TagSpec& operator=( TagSpec const& other ) {
			tag_name = other.tag_name ;
			human_readable_name = other.human_readable_name ;
			return *this ;
		}
		std::string tag_name ;
		std::string human_readable_name ;
	} ;

	void process_reads(
		seqlib::BamReader reader,
		seqlib::BamHeader header,
		statfile::BuiltInTypeStatSink& sink,
		std::function< void( std::size_t ) > progress_callback
	) {
		std::vector< TagSpec > tags = parse_tag_specs( options().get_values< std::string >( "-tags" ) ) ;

		sink
			| "read_id"
			| "chromosome" | "position"
			| "is_primary" | "is_supplementary" | "is_secondary"
			| "is_aligned"
			| "mapping_quality"
			| "query_length"
			| "aligned_length"
			| "query_clipped"
			| "inserted_bases"
			| "deleted_bases" ;

		bool output_cigar = options().check( "-cigar" ) ;

		if( output_cigar ) {
			sink | "CIGAR" ;
		} ;
		for( auto& tag: tags ) {
			sink | tag.human_readable_name ;
		}

		seqlib::BamRecord alignment ;
		std::size_t count = 0 ;
		std::string tag_value ;
		while( reader.GetNextRecord( alignment ) ) {
			seqlib::Cigar const& cigar = alignment.GetCigar() ;
			int64_t clipped = 0 ;
			if( cigar.size() > 0 && cigar.front().Type() == 'S' ) {
				clipped += cigar.front().Length() ;
			}
			if( cigar.size() > 1 && cigar.back().Type() == 'S' ) {
				clipped += cigar.back().Length() ;
			}
			int64_t insertions = 0, deletions = 0 ;
			compute_indels( cigar, &insertions, &deletions ) ;
			sink
				<< alignment.Qname()
				<< alignment.ChrName(header)
				<< (alignment.AlignmentPosition()+1) // convert back to 1-based
				<< int32_t( !alignment.SecondaryFlag() && !alignment.SupplementaryFlag() )
				<< int32_t( alignment.SecondaryFlag() )
				<< int32_t( alignment.SupplementaryFlag() )
				<< int32_t( alignment.MappedFlag() )
				<< alignment.MapQuality()
				<< alignment.Length()
				<< alignment.NumAlignedBases()
				<< clipped
				<< insertions
				<< deletions ;
			if( output_cigar ) {
				sink << genfile::string_utils::to_string(cigar) ;
			}
			;
			for( auto& tag: tags ) {
				if( alignment.GetTag( tag.tag_name, tag_value ) ) {
					sink << tag_value ;
				} else {
					sink << genfile::MissingValue() ;
				}
			}
			sink << statfile::end_row() ;
			progress_callback( ++count ) ;
		}
	}

	std::vector< TagSpec > parse_tag_specs( std::vector< std::string > const& specs ) {
		std::vector< TagSpec > result ;
		using namespace genfile::string_utils ;
		for( auto spec: specs ) {
			std::vector< slice> elts = slice(spec).split( "=" ) ;
			if( elts.size() == 1 ) {
				result.push_back( TagSpec( elts[0], elts[0] )) ;
			} else if( elts.size() == 2 ) {
				result.push_back( TagSpec( elts[1], elts[0] )) ;
			} else {
				throw genfile::BadArgumentError(
					"IorekApplication::parse_tag_specs()",
					"spec=\"" + spec + "\"",
					"Expected a single string or a string of the form <human readable name>=<SAM tag name>"
				) ;
			}
			std::cerr << (result.back().human_readable_name + ":" + result.back().tag_name) << "\n" ;
		}
		return result ;
	}

	void compute_indels( seqlib::Cigar const& cigar, int64_t* insertions, int64_t* deletions ) const {
		seqlib::Cigar::const_iterator i = cigar.begin(), end_i = cigar.end() ;
		for( ; i != end_i; ++i ) {
			char const type = i->Type() ;
			switch( type ) {
				case 'I':
					(*insertions) += i->Length() ;
					break ;
				case 'D': 
					(*deletions) += i->Length() ;
				default:
					break ;
			} ;
		}
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		IorekApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}



