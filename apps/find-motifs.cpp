
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <boost/filesystem.hpp>

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/Error.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#define DEBUG 0

namespace globals {
	std::string const program_name = "find-motifs" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct IorekOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-fasta" ]
			.set_description( "Path of FASTA file(s) to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-motif" ]
			.set_description( "motif(s) to look for.  Non case-sensitive." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-no-reverse-complement" ]
			.set_description( "Don't automatically look for the reverse complement of specified motifs." )
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
	}
} ;

struct IorekApplication: public appcontext::ApplicationContext
{
public:
	IorekApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new IorekOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	
	void unsafe_process() {
		genfile::Fasta::UniquePtr fasta = genfile::Fasta::create() ;
		{
			std::vector< std::string > fasta_filenames = options().get_values< std::string >( "-fasta" ) ;
			for( auto filename: fasta_filenames ) {
				auto progress_context = ui().get_progress_context( "Loading \"" + filename + "\"" ) ;
				fasta->add_sequences_from_file( filename, progress_context ) ;
			}
		}
		std::vector< std::string > motifs = options().get_values< std::string >( "-motif" ) ;
		{
			// convert to upper case
			for( std::string& motif: motifs ) {
				std::transform(motif.begin(), motif.end(), motif.begin(), ::toupper);
			}
			if( !options().check( "-no-reverse-complement" )) {
				std::size_t const n = motifs.size() ;
				for( std::size_t i = 0; i < n; ++ i ) {
					motifs.push_back( reverse_complement( motifs[i] )) ;
				}
			}
			std::sort( motifs.begin(), motifs.end() ) ;
			auto where = std::unique( motifs.begin(), motifs.end() ) ;
			motifs.resize( where - motifs.begin() ) ;
		}
		
		statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-o" )) ;
		process( *fasta, motifs, *sink ) ;
	}

	std::string reverse_complement( std::string const& sequence ) const {
		std::vector< char > map( 256, 'N' ) ;
		map['A'] = 'T' ;
		map['T'] = 'A' ;
		map['a'] = 'T' ;
		map['t'] = 'A' ;
		map['C'] = 'G' ;
		map['G'] = 'c' ;
		map['c'] = 'G' ;
		map['g'] = 'C' ;
		std::string result = sequence ;
		for( std::size_t i = 0; i < result.size(); ++i ) {
			result[i] = map[ result[i] ] ;
		}
		std::reverse( result.begin(), result.end() ) ;
		return result ;
	}
	
	void process(
		genfile::Fasta const& fasta,
		std::vector< std::string > const& motifs,
		statfile::BuiltInTypeStatSink& sink
	) {
		std::vector< std::string > const& sequence_ids = fasta.sequence_ids() ;
		sink | "sequence" | "length" | "motif" | "start" | "end" ;
		for( auto sequence_id: sequence_ids ) {
			auto progress_context = ui().get_progress_context( "Processing \"" + sequence_id + "\"" ) ;
			genfile::Fasta::ContigRange contig = fasta.get_sequence( sequence_id ) ;
			std::size_t const sequence_length = std::distance( contig.sequence().begin(), contig.sequence().end() ) ;
			genfile::Fasta::ConstSequenceIterator const sequence_begin = contig.sequence().begin() ;
			std::size_t const zero_based_start = contig.positions().start().position() - 1 ;
			for( std::size_t x = 0; x < sequence_length; ++x ) {
				for( auto motif: motifs ) {
					if( x + motif.size() <= sequence_length ) {
						bool match = true ;
						for( std::size_t i = 0; i < motif.size(); ++i ) {
							if( motif[i] != ::toupper( *(sequence_begin + x + i)) ) {
								match = false ;
								break ;
							}
						}
						if( match ) {
							sink << sequence_id ;
							sink << int(sequence_length) ;
							sink << motif ;
							sink << int(zero_based_start + x ) ;
							sink << int(zero_based_start + x + motif.size() ) ;
							sink << statfile::end_row() ;
						}
					}
				}
				progress_context( x+1, sequence_length ) ;
			}
		}
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		IorekApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
