
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include "boost/regex.hpp"
#include <boost/algorithm/string/replace.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/annotation/GFFRecord.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"
#include "statfile/BuiltInTypeStatSource.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "seemsa" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct PlotMSAOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-msa" ]
			.set_description( "Path of FASTA file(s) (or gzipped FASTA file(s)) containing the multiple sequence alignment." )
			.set_is_required()
			.set_takes_values_until_next_option()
		;
		
		options[ "-o" ]
			.set_description( "Path of output HTML file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
		
		options[ "-highlight" ]
			.set_description( "Specify sequences to highlight in the resulting visualisation" )
			.set_takes_values_until_next_option() ;
		
		options[ "-distinguish" ]
			.set_description( "Specify the names sequences to distinguish. "
				" These will be displayed prominently in the output (e.g. by placing them at the bottom). "
				"The *last value* specified here represents a 'reference' sequence against which genes will be plotted." )
			.set_takes_values_until_next_option() ;

		options[ "-genes" ]
			.set_description( "Specific a gff file of genes to load" )
			.set_takes_single_value() ;
		
		options.option_implies_option( "-genes", "-distinguish" ) ;
		
		options[ "-annotate-bed4" ]
			.set_description( "Specify one or more bed4 files to annotate with."
				" Value must be one or more key=filename pair(s)." )
			.set_takes_values_until_next_option() ;

		options.declare_group( "URL options" ) ;
		options[ "-url-base" ]
			.set_description(
				"Specify the base used to construct the urls containing the viewer implementation. "
				"By default this points to my server, but you can point to a local copy of the javascript and css code, "
				" or place a copy elsewhere on the web, if desired." )
			.set_takes_single_value()
			.set_default_value( "https://www.well.ox.ac.uk/~gav/projects/msa_viewer" ) ;
	}
} ;

typedef genfile::annotation::GFFRecord GFFRecord ;

struct PlotMSAApplication: public appcontext::ApplicationContext
{
public:
	PlotMSAApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new PlotMSAOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( appcontext::OptionProcessingException const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		} catch( genfile::DuplicateKeyError const& e ) {
			// this 
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:

	// This class handles a specification of a subsequence of a larger contig.
	// The subsequence exists at a given (1-based) coordinate range on the larger contig
	// Additionally, it can represent a forward or a reverse-complement portion.
	struct ContigSubsequenceSpec {
		typedef enum { eForward = 0, eReverse = 1 } Orientation ;
		
		// Spec should be of the form:
		// contig:start-end
		// and we expect one-based, closed coordinates.
		ContigSubsequenceSpec( std::string spec ):
			m_spec( spec ),
			m_range( genfile::GenomePositionRange::parse( spec )),
			m_id( m_range.chromosome() )
		{}

		ContigSubsequenceSpec( std::string spec, genfile::GenomePositionRange const& range ):
			m_spec(spec),
			m_range( range ),
			m_id( spec )
		{}	

		ContigSubsequenceSpec( ContigSubsequenceSpec const& other ):
			m_spec( other.m_spec ),
			m_range( other.m_range ),
			m_id( other.m_id )
		{}

		ContigSubsequenceSpec& operator=( ContigSubsequenceSpec const& other ) {
			m_id = other.m_id ;
			m_spec = other.m_spec ;
			m_range = other.m_range ;
			return *this ;
		}
		
		std::string const& spec() const { return m_spec ; }
		std::string const& id() const { return m_id ; }
		genfile::GenomePositionRange const& range() const { return m_range ; }
		Orientation const orientation() {
			return (m_range.start().position() >= m_range.end().position()) ? eForward : eReverse ;
		}

	private:
		ContigSubsequenceSpec() ;
		
	private:
		std::string m_spec ;
		genfile::GenomePositionRange m_range ;
		std::string m_id ;
	} ;

	struct RegionValue {
		//RegionValue() {} ;
		RegionValue( genfile::GenomePositionRange const& range, double value ):
			m_range( range ),
			m_value( value )
		{}
		RegionValue( RegionValue const& other ):
			m_range( other.m_range ),
			m_value( other.m_value )
		{}
		RegionValue& operator=( RegionValue const& other ) {
			m_range = other.m_range ;
			m_value = other.m_value ;
			return *this ;
		}

		genfile::GenomePositionRange const range() const { return m_range ; }
		double value() const { return m_value ; }

	private:
		genfile::GenomePositionRange m_range ;
		double m_value ;
	} ;

	
	struct Annotations {
		// Annotation: map of annotation name to start / end / value.
		typedef std::map< std::string, std::vector< RegionValue > > Annotation ;
		// map of sequence ID to Annotation.
		typedef std::map< std::string, Annotation > Map ;
			
		std::vector< std::string > const& names() const { return m_names ; }
		std::vector< std::string > const sequence_ids() const {
			std::vector< std::string > result ;
			for( Map::const_iterator i = m_data.begin(); i != m_data.end(); ++i ) {
				result.push_back( i->first ) ;
			}
			return result ;
		} ;
		void add_annotation( std::string const& name ) {
			m_names.push_back( name ) ;
		}

		void add_annotation_value( std::string const& sequence_id, RegionValue const& value ) {
			m_data[sequence_id][m_names.back()].push_back( value ) ;
		}
		
		std::size_t number_of_annotations() const { return m_names.size() ; }

		bool has(
			std::string const& sequence_id,
			std::string const& annotation_name
		) const {
			Map::const_iterator w1 = m_data.find( sequence_id ) ;
			if( w1 == m_data.end()) {
				return false ;
			}
			Annotation const& a = w1->second ;
			Annotation::const_iterator w2 = a.find( annotation_name ) ;
			return( w2 != a.end() ) ;
		}

		std::vector< RegionValue > const& find(
			std::string const& sequence_id,
			std::string const& annotation_name
		) const {
			Map::const_iterator w1 = m_data.find( sequence_id ) ;
			Annotation const& a = w1->second ;
			Annotation::const_iterator w2 = a.find( annotation_name ) ;
			assert( w2 != a.end() ) ;
			return w2->second ;
		}

	private:
		std::vector< std::string > m_names ;
		Map m_data ;
	} ;
	
private:
	
	void unsafe_process() {
		genfile::Fasta::UniquePtr fasta = load_fasta(
			options().get_values< std::string >( "-msa" )
		) ;
		check_sequence_lengths( *fasta ) ;

		auto sequence_ids = parse_sequence_ids( *fasta ) ;

		if( options().check( "-distinguish" )) {
			std::vector< std::string > const& distinguished = options().get_values< std::string >( "-distinguish" ) ;
			for( auto& id: distinguished ) {
				std::size_t i = 0 ;
				for( ; i < sequence_ids.size(); ++i ) {
					if( sequence_ids[i].id() == id ) {
						break ;
					}
				}
				if( i == sequence_ids.size() ) {
					throw genfile::BadArgumentError(
						"PlotMSAApplication::unsafe_process()",
						"-distinguish",
						"ID \"" + id + "\" is not among the sequence IDs in the alignment."
					) ;
				}
				ContigSubsequenceSpec tmp = sequence_ids[i] ;
				sequence_ids.erase( sequence_ids.begin() + i ) ;
				sequence_ids.insert( sequence_ids.begin(), tmp ) ;
			}
		}

		ui().logger() << "Loaded MSA with " << fasta->number_of_sequences() << " sequences.\n" ;

		genfile::Fasta::UniquePtr highlights ;
		if( options().check( "-highlight" )) {
			highlights = load_highlights( options().get< std::string >( "-highlight" )) ;
		}
		
		Annotations annotations ;
		if( options().check( "-annotate-bed4" )) {
			annotations = load_annotations( options().get_values< std::string >( "-annotate-bed4" ), sequence_ids ) ;
		}

		std::vector< GFFRecord > genes ;
		if( options().check( "-genes" )) {
			genes = load_genes(
				options().get_value< std::string >( "-genes" ),
				sequence_ids[0].range()
			) ;
		}
		

		std::string const& output = options().get< std::string >( "-o" ) ;
		ui().logger() << "Writing output to \"" << output << "\"....\n" ;
		std::auto_ptr< std::ostream > ostr = genfile::open_text_file_for_output( output ) ;
		write_html( *ostr, *fasta, sequence_ids, genes, highlights, annotations ) ;
	}
	
	genfile::Fasta::UniquePtr load_fasta( std::vector< std::string > const& filenames ) const {
		genfile::Fasta::UniquePtr result = genfile::Fasta::create() ;
		for( auto& filename: filenames ) {
			auto progress_context = ui().get_progress_context( "Loading \"" + filename + "\"" ) ;
			result->add_sequences_from_file( filename, progress_context ) ;
		}
		return result ;
	}
	
	void check_sequence_lengths( genfile::Fasta const& fasta ) const {
		using genfile::string_utils::to_string ;
		std::size_t sequence_length = 0 ;
		std::vector< std::string > const& sequence_ids = fasta.sequence_ids() ;
		for( std::size_t i = 0; i < sequence_ids.size(); ++i ) {
			genfile::Fasta::ContigRange p = fasta.get_sequence( sequence_ids[i] ) ;
			std::string sequence( p.sequence().begin(), p.sequence().end() ) ; 
			if( i == 0 ) {
				sequence_length = sequence.size() ;
			} else {
				if( sequence_length != sequence.size() ) {
					throw genfile::BadArgumentError(
						"PlotMSAApplication::unsafe_process()",
						"-msa",
						"Sequences \"" + sequence_ids[0] + "\" and \"" + sequence_ids[i] + "\" have different lengths "
						"(" + to_string(sequence_length) + " vs. " + to_string(sequence.size()) + ")"
					) ;
				}
			}
		}
	}
	
	std::vector< ContigSubsequenceSpec > parse_sequence_ids( genfile::Fasta const& fasta ) const {
		std::vector< ContigSubsequenceSpec > result ;
		fasta.sequence_ids( [&result,&fasta]( std::string const& id ) {
			try {
				// Try to match sequence ID of the form contig:start-end
				// e.g. as output by samtools view with a range.
				result.push_back( ContigSubsequenceSpec( id )) ;
			}
			catch( genfile::string_utils::StringConversionError const& e ) {
				// if that failed, assume the range is 1-length
				std::size_t length = 0 ;
				auto range = fasta.get_sequence( id ) ;
				genfile::Fasta::ConstSequenceIterator i = range.sequence().begin() ;
				for( ; i != range.sequence().end(); ++i ) {
					if( *i != '-' ) {
						++length ;
					}
				} ;
				
				result.push_back( 
					ContigSubsequenceSpec(
						id,
						genfile::GenomePositionRange(
							id, 1, length
						)
					)
				) ;
			}
		}) ;

		return result ;
	}
	
	std::vector< GFFRecord > load_genes(
		std::string const& filename,
		genfile::GenomePositionRange const& range
	) const {
		std::vector< GFFRecord > result ;
		auto input = genfile::open_text_file_for_input( filename ) ;
		genfile::Position const a = std::min(
			range.start().position(),
			range.end().position()
		),
		b = std::max(
			range.start().position(),
			range.end().position()
		) ;
		
		{
			auto progress_context = ui().get_progress_context( "Loading genes" ) ;
			genfile::annotation::parse_gff( *input, [&]( GFFRecord const& record ) {
				progress_context.notify_progress() ;
				if(
					(record.sequence() == range.chromosome())
					&& (record.end() >= a)
					&& (record.start() <= b)
				) {
					result.push_back( record ) ;
				}
			}) ;
		}
		ui().logger() << "++ Loaded "
			<< result.size()
			<< " records in range "
			<< range << ".\n" ;
		return result ;
	}
	
	genfile::Fasta::UniquePtr load_highlights( std::string const& filename ) {
		auto result = genfile::Fasta::create() ;

		auto source = statfile::BuiltInTypeStatSource::open( filename ) ;
		{
			auto progress_context = ui().get_progress_context( "Loading highlights" ) ;
			std::size_t const nameIndex = source->index_of_column( "primer_name" ) ;
			std::size_t const sequenceIndex = source->index_of_column( "sequence" ) ;
			std::cerr << "COLUMN INDEX: " << nameIndex << ", " << sequenceIndex << ".\n" ;
			assert( nameIndex < sequenceIndex ) ; // TODO: allow this either way.
			std::string name, sequence ;
			while(
				(*source)
					>> statfile::ignore( nameIndex )
					>> name
					>> statfile::ignore( sequenceIndex - nameIndex - 1 )
					>> sequence
			) {
				result->add_sequence( name, sequence ) ;
				progress_context.notify_progress() ;
				(*source) >> statfile::ignore_all() ;
			}
		}
		ui().logger() << "++ Loaded "
			<< result->number_of_sequences()
			<< " from \"" << filename << "\".\n" ;
		return result ;
	}
	
	Annotations load_annotations(
		std::vector< std::string > const& specs,
		std::vector< ContigSubsequenceSpec > const& sequence_ids
	) {
		Annotations result ;
		using genfile::string_utils::slice ;
		for( std::string const& spec: specs ) {
			std::vector< slice > elts = slice( spec ).split( "=" );
			if( elts.size() != 2 ) {
				throw genfile::BadArgumentError(
					"load_annotations()",
					"spec=\"" + spec + "\"",
					"Expected name=value pair."
				) ;
			}
			result.add_annotation( elts[0] ) ;
			load_bed4_annotation(
				elts[1],
				[&] ( RegionValue const& value ) {
					for( ContigSubsequenceSpec const& sequence_id: sequence_ids ) {
						genfile::Position const a = std::min(
							sequence_id.range().start().position(),
							sequence_id.range().end().position()
						),
						b = std::max(
							sequence_id.range().start().position(),
							sequence_id.range().end().position()
						) ;
						if(
							(value.range().chromosome() == sequence_id.id())
							&& (value.range().end().position() >= a )
							&& (value.range().start().position() <= b )
						) {
							result.add_annotation_value( value.range().chromosome(), value ) ;
						}
					}
				}
			) ;
		}
		return result ;
	}

	void load_bed4_annotation(
		std::string const& filename,
		boost::function< void( RegionValue const& ) > callback
	) {
		using genfile::string_utils::slice ;
		using genfile::string_utils::to_string ;
		using genfile::string_utils::to_repr ;
		auto input = genfile::open_text_file_for_input( filename ) ;
		{
			auto progress_context = ui().get_progress_context( "Loading annotations from \"" + filename + "\"" ) ;
			std::string line ;
			std::vector< slice > elts ;
			std::size_t count = 0 ;
			while( std::getline( *input, line )) {
				elts = slice( line ).split( "\t" ) ;
				if( elts.size() != 4 ) {
					throw genfile::MalformedInputError(
						filename,
						"Line " + to_string( count+1 ) + " contains wrong number of values (" + to_string( elts.size()) + ", should be 4).",
						count + 1
					) ;
				}
				
				callback(
					RegionValue(
						genfile::GenomePositionRange(
							genfile::Chromosome( elts[0] ),
							to_repr< genfile::Position >( elts[1] ),
							to_repr< genfile::Position >( elts[2] )
						),
						to_repr< double >( elts[3] )
					)
				) ;
				progress_context.notify_progress() ;
				++count ;
			}
		}
	}
	
	
	void write_html(
		std::ostream& out,
		genfile::Fasta const& fasta,
		std::vector< ContigSubsequenceSpec > const& sequence_ids,
		std::vector< GFFRecord > const& genes,
		genfile::Fasta::UniquePtr const& highlights,
		Annotations const& annotations
	) const {
		// This is a C++11 raw string literal
		std::string preamble = R""""(<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Multiple sequence alignment viewer</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.3.0/d3.min.js"></script>
	<script src="[URLBASE]/js/assert.js"></script>
	<script src="[URLBASE]/js/GeneView.js"></script>
	<script src="[URLBASE]/js/MSA.js"></script>
	<script src="[URLBASE]/js/AlignmentTrackScale.js"></script>
	<script src="[URLBASE]/js/MSAView.js"></script>
	<script src="[URLBASE]/js/MSAController.js"></script>
	<script src="[URLBASE]/js/run_msa_viewer.js"></script>
	<link href="[URLBASE]/css/msa_viewer.css" rel="stylesheet" >
</head>
<body>
	<section class="figure">
		<svg class = "names" width=900 height=600></svg>
		<svg class = "controls" width=900 height=200></svg>
		<canvas class = "sequences" width=900 height=600></canvas>
		<svg class = "genes" width=900 height=200></svg>
	</section>
</body>
<script>
	data = )"""" ;
		boost::algorithm::replace_all( preamble, "[URLBASE]", options().get< std::string >( "-url-base" )) ;
		out
			<< preamble
			<< "{\n"
			<< "  \"alignment\": "
			<< sequencesToJSON( fasta, sequence_ids )
			<< ",\n"
			<< "  \"ranges\": "
			<< rangesToJSON( sequence_ids )
			<< ",\n  \"genes\": "
			<< genesToJSON( genes )
			<< ",\n" ;
		if( highlights.get() ) { 
			out
				<< "  \"highlights\": "
				<< sequencesToJSON( *highlights )
				<< ",\n" ;
		} else {
			out
				<< "  \"highlights\": {}"
				<< ",\n" ;
		}
		if( annotations.number_of_annotations() > 0 ) {
			out
 				<< "  \"annotations\": "
				<< annotationsToJSON( annotations )
				<< "\n" ;
		} else {
			out
				<< "  \"annotations\": {}\n" ;
		}
		out
			<< "};\n"
			<< "run_msa_viewer( data ) ;\n"
			<< "</script>\n"
			<< "</html>\n" ;
	}

	std::string sequencesToJSON(
		genfile::Fasta const& fasta,
		std::vector< ContigSubsequenceSpec > const& sequence_ids
	) const {
		std::ostringstream s ;
		s << "[\n" ;
		std::size_t count = 0 ;
		std::deque< char > sequence ;
		for( auto& sequence_id: sequence_ids ) {
			genfile::Fasta::ContigRange p = fasta.get_sequence( sequence_id.spec() ) ;
			s << (count>0 ? ",\n" : "" )
				<< "{ \"name\": \""
				<< sequence_id.id()
				<< "\", \"sequence\": \""
				<< std::string( p.sequence().begin(), p.sequence().end() )
				<< "\" }" ;
			++count ;
		}
		s << "\n]" ;
		return s.str() ;
	}
	
	std::string sequencesToJSON(
		genfile::Fasta const& fasta
	) const {
		return sequencesToJSON( fasta, parse_sequence_ids( fasta )) ;
	}
	

	std::string genesToJSON( std::vector< GFFRecord > const& genes ) const {
		std::ostringstream s ;
		s << "[\n" ;
		for( std::size_t i = 0; i < genes.size(); ++i ) {
			GFFRecord const& gene = genes[i] ;
			genfile::VariantEntry const display = (gene.gene_name().is_missing() ? gene.ID() : gene.gene_name() ) ;
			s << ((i>0) ? ",\n" : "") ;
			s << "{ "
				<< "\"ID\": \"" << gene.ID() << "\", "
				<< "\"feature\": \"" << gene.feature() << "\", "
				<< "\"parent\": \"" << gene.parent() << "\", "
				<< "\"chromosome\": \"" << gene.sequence() << "\", "
				<< "\"start\": " << gene.start() << ", "
				<< "\"end\": " << gene.end() << ", "
				<< "\"strand\": \"" << gene.strand() << "\", "
				<< "\"display\": \"" << display << "\" }" ;
		}
		s << "\n]" ;
		return s.str() ;
	}

	std::string rangesToJSON( std::vector< ContigSubsequenceSpec > const& sequence_ids ) const {
		std::ostringstream s ;
		s << "{\n" ;
		for( std::size_t i = 0; i < sequence_ids.size(); ++i ) {
			auto& sequence_id = sequence_ids[i] ;
			s
				<< ((i>0) ? ",\n" : "" )
				<< "\""
				<< sequence_id.id()
				<< "\": { "
				<< "\"chromosome\": \""
				<< sequence_id.range().chromosome()
				<< "\", \"start\": "
				<< sequence_id.range().start().position()
				<< ", \"end\": "
				<< sequence_id.range().end().position()
				<< " }" ;
		}
		s << "\n}" ;
		return s.str() ;
	}

	std::string annotationsToJSON(
		Annotations const& annotations
	) const {
		std::ostringstream s ;
		s << "{\n" ;

		std::vector< std::string > const sequence_ids = annotations.sequence_ids() ;
		for( std::size_t i = 0; i < sequence_ids.size(); ++i ) {
			std::string const& sequence_name = sequence_ids[i] ;
			s	<< ((i>0) ? ",\n" : "")
				<< "  \"" << sequence_name << "\": {\n" ;
			for( std::size_t j = 0; j < annotations.names().size(); ++j ) {
				std::string const& annotation_name = annotations.names()[j] ;
				s	<< ((j>0) ? ",\n" : "")
					<< "    \"" << annotation_name << "\": [\n" ;
				if( annotations.has( sequence_name, annotation_name )) {
					std::vector< RegionValue > const& values = annotations.find( sequence_name, annotation_name ) ;
					for( std::size_t ri = 0; ri < values.size(); ++ri ) {
						RegionValue const& v = values[ri] ;
						s << ((ri>0) ? ",\n" : "" )
							<< "      { \"chromosome\": \"" << v.range().chromosome() << "\", "
							<< "\"start\": " << v.range().start().position() + 1 << ", "
							<< "\"end\": " << v.range().end().position() << ", "
							<< "\"value\": " << v.value()
							<< "}" ;
					}
				}
				s << "\n    ]" ;
			}
			s << "\n  }" ;
		}
		s << "\n}" ;
		return s.str() ;
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		PlotMSAApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}

