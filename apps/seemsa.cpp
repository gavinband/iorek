
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include "boost/regex.hpp"
#include <boost/algorithm/string/replace.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"
#include "statfile/BuiltInTypeStatSource.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "seemsa" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct PlotMSAOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-msa" ]
			.set_description( "Path of FASTA file(s) (or gzipped FASTA file(s)) containing the multiple sequence alignment." )
			.set_is_required()
			.set_takes_values_until_next_option()
		;
		
		options[ "-o" ]
			.set_description( "Path of output HTML file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
		
		options[ "-highlight" ]
			.set_description( "Specify sequences to highlight in the resulting visualisation" )
			.set_takes_values_until_next_option() ;
		
		options[ "-distinguish" ]
			.set_description( "Specify the names sequences to distinguish. "
				" These will be displayed prominently in the output (e.g. by placing them at the bottom). "
				"The *last value* specified here represents a 'reference' sequence against which genes will be plotted." )
			.set_takes_values_until_next_option() ;

		options[ "-genes" ]
			.set_description( "Specific a gff file of genes to load" )
			.set_takes_single_value() ;
		
		options.option_implies_option( "-genes", "-distinguish" ) ;
		
		options[ "-annotate-bed4" ]
			.set_description( "Specify one or more bed4 files to annotate with."
				" Value must be one or more key=filename pair(s)." )
			.set_takes_values_until_next_option() ;

		options.declare_group( "URL options" ) ;
		options[ "-url-base" ]
			.set_description(
				"Specify the base used to construct the urls containing the viewer implementation. "
				"By default this points to my server, but you can point to a local copy of the javascript and css code, "
				" or place a copy elsewhere on the web, if desired." )
			.set_takes_single_value()
			.set_default_value( "https://www.well.ox.ac.uk/~gav/projects/msa_viewer" ) ;
	}
} ;

namespace {
}

struct GFFRecord: public boost::noncopyable {
public:
	typedef genfile::string_utils::slice slice ;
private:
	static genfile::VariantEntry parse_attributes( std::string const& attributes, std::string const& attribute ) {
		// inefficient to compile re each time - improve this.
		const boost::regex re( attribute + "=([^;]+)" ) ;
		boost::match_results<std::string::const_iterator> match ;
		bool success = boost::regex_search( attributes, match, re ) ;
		if( !success || !match[1].matched) {
			return genfile::MissingValue() ;
		} else {
			return std::string( match[1].first, match[1].second ) ;
		}
	}

public:
	static GFFRecord parse( std::string const& line ) {
		using genfile::string_utils::split ;
		GFFRecord result ;
		result.m_data = line ;
		result.m_elts = slice(result.m_data).split( "\t" ) ;
		assert( result.m_elts.size() == 9 ) ;
		result.m_start = genfile::string_utils::to_repr< genfile::Position >( result.m_elts[3] ) ;
		result.m_end = genfile::string_utils::to_repr< genfile::Position >( result.m_elts[4] ) ;
		result.m_ID = GFFRecord::parse_attributes( result.m_elts[8], "ID" ) ;
		result.m_parent = GFFRecord::parse_attributes( result.m_elts[8], "Parent" ) ;
		result.m_description = GFFRecord::parse_attributes( result.m_elts[8], "description" ) ;
		result.m_gene_name = GFFRecord::parse_attributes( result.m_elts[8], "gene_name" ) ;
		return result ;
	}

	GFFRecord( GFFRecord const& other ):
		m_data( other.m_data ),
		m_elts( other.m_elts ),
		m_start( other.m_start ),
		m_end( other.m_end ),
		m_ID( other.m_ID ),
		m_parent( other.m_parent ),
		m_description( other.m_description ),
		m_gene_name( other.m_gene_name )
	{
		// fix elts to refer to our own data
		for( std::size_t i = 0; i < m_elts.size(); ++i ) {
			m_elts[i] = slice( m_data, m_elts[i].get_start(), m_elts[i].get_end() ) ;
		}
	}
	
private:
	GFFRecord() {}
		
public:
	
	slice const& sequence() const { return m_elts[0] ; }
	slice const& source() const { return m_elts[1] ; }
	slice const& feature() const { return m_elts[2] ; }
	genfile::Position start() const { return m_start ; }
	genfile::Position end() const { return m_end ; }
	slice const& score() const { return m_elts[5] ; }
	slice const& strand() const { return m_elts[6] ; }
	slice const& phase() const { return m_elts[7] ; }
	slice const& attributes() const { return m_elts[8] ; }
	genfile::VariantEntry const& ID() const { return m_ID ; }
	genfile::VariantEntry const& parent() const { return m_parent ; }
	genfile::VariantEntry const& gene_name() const { return m_gene_name ; }
private:
	std::string m_data ;
	std::vector< slice > m_elts ;
	genfile::Position m_start ;
	genfile::Position m_end ;
	genfile::VariantEntry m_ID ;
	genfile::VariantEntry m_parent ;
	genfile::VariantEntry m_description ;
	genfile::VariantEntry m_gene_name ;
} ;

void parse_gff( std::istream& input, std::function< void( GFFRecord const& record ) > callback ) {
	std::string line ;
	while( std::getline( input, line )) {
		if( line.size() > 0 && line[0] != '#' ) {
			callback( GFFRecord::parse( line ) ) ;
		}
	}
}

struct PlotMSAApplication: public appcontext::ApplicationContext
{
public:
	PlotMSAApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new PlotMSAOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( appcontext::OptionProcessingException const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		} catch( genfile::DuplicateKeyError const& e ) {
			// this 
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:

	// This class handles a specification of a subsequence of a larger contig.
	// The subsequence exists at a given (1-based) coordinate range on the larger contig
	// Additionally, it can represent a forward or a reverse-complement portion.
	struct ContigSubsequenceSpec {
		typedef enum { eForward = 0, eReverse = 1 } Orientation ;
		
		// Spec should be of the form:
		// contig:start-end
		// and we expect one-based, closed coordinates.
		ContigSubsequenceSpec( std::string spec ):
			m_spec( spec ),
			m_range( genfile::GenomePositionRange::parse( spec )),
			m_id( m_range.chromosome() )
		{}

		ContigSubsequenceSpec( std::string spec, genfile::GenomePositionRange const& range ):
			m_spec(spec),
			m_range( range ),
			m_id( spec )
		{}	

		ContigSubsequenceSpec( ContigSubsequenceSpec const& other ):
			m_spec( other.m_spec ),
			m_range( other.m_range ),
			m_id( other.m_id )
		{}

		ContigSubsequenceSpec& operator=( ContigSubsequenceSpec const& other ) {
			m_id = other.m_id ;
			m_spec = other.m_spec ;
			m_range = other.m_range ;
			return *this ;
		}
		
		std::string const& spec() const { return m_spec ; }
		std::string const& id() const { return m_id ; }
		genfile::GenomePositionRange const& range() const { return m_range ; }
		Orientation const orientation() {
			return (m_range.start().position() >= m_range.end().position()) ? eForward : eReverse ;
		}

	private:
		ContigSubsequenceSpec() ;
		
	private:
		std::string m_spec ;
		genfile::GenomePositionRange m_range ;
		std::string m_id ;
	} ;

	struct RegionValue {
		//RegionValue() {} ;
		RegionValue( genfile::GenomePositionRange const& range, double value ):
			m_range( range ),
			m_value( value )
		{}
		RegionValue( RegionValue const& other ):
			m_range( other.m_range ),
			m_value( other.m_value )
		{}
		RegionValue& operator=( RegionValue const& other ) {
			m_range = other.m_range ;
			m_value = other.m_value ;
			return *this ;
		}

		genfile::GenomePositionRange const range() const { return m_range ; }
		double value() const { return m_value ; }

	private:
		genfile::GenomePositionRange m_range ;
		double m_value ;
	} ;

	typedef std::map< std::string, std::vector< RegionValue > > Annotation ;
	typedef std::map< std::string, Annotation > Annotations ;
	
private:
	
	void unsafe_process() {
		genfile::Fasta::UniquePtr fasta = load_fasta(
			options().get_values< std::string >( "-msa" )
		) ;
		check_sequence_lengths( *fasta ) ;

		auto sequence_ids = parse_sequence_ids( *fasta ) ;

		if( options().check( "-distinguish" )) {
			std::vector< std::string > const& distinguished = options().get_values< std::string >( "-distinguish" ) ;
			for( auto& id: distinguished ) {
				std::size_t i = 0 ;
				for( ; i < sequence_ids.size(); ++i ) {
					if( sequence_ids[i].id() == id ) {
						break ;
					}
				}
				if( i == sequence_ids.size() ) {
					throw genfile::BadArgumentError(
						"PlotMSAApplication::unsafe_process()",
						"-distinguish",
						"ID \"" + id + "\" is not among the sequence IDs in the alignment."
					) ;
				}
				ContigSubsequenceSpec tmp = sequence_ids[i] ;
				sequence_ids.erase( sequence_ids.begin() + i ) ;
				sequence_ids.insert( sequence_ids.begin(), tmp ) ;
			}
		}

		ui().logger() << "Loaded MSA with " << fasta->number_of_sequences() << " sequences.\n" ;

		genfile::Fasta::UniquePtr highlights ;
		if( options().check( "-highlight" )) {
			highlights = load_highlights( options().get< std::string >( "-highlight" )) ;
		}
		
		Annotations annotations ;
		if( options().check( "-annotate-bed4" )) {
			annotations = load_annotations( options().get_values< std::string >( "-annotate-bed4" ), sequence_ids ) ;
		}

		std::vector< GFFRecord > genes ;
		if( options().check( "-genes" )) {
			genes = load_genes(
				options().get_value< std::string >( "-genes" ),
				sequence_ids[0].range()
			) ;
		}
		

		std::string const& output = options().get< std::string >( "-o" ) ;
		ui().logger() << "Writing output to \"" << output << "\"....\n" ;
		std::auto_ptr< std::ostream > ostr = genfile::open_text_file_for_output( output ) ;
		write_html( *ostr, *fasta, sequence_ids, genes, highlights, annotations ) ;
	}
	
	genfile::Fasta::UniquePtr load_fasta( std::vector< std::string > const& filenames ) const {
		genfile::Fasta::UniquePtr result = genfile::Fasta::create() ;
		for( auto& filename: filenames ) {
			auto progress_context = ui().get_progress_context( "Loading \"" + filename + "\"" ) ;
			result->add_sequences_from_file( filename, progress_context ) ;
		}
		return result ;
	}
	
	void check_sequence_lengths( genfile::Fasta const& fasta ) const {
		using genfile::string_utils::to_string ;
		std::size_t sequence_length = 0 ;
		std::vector< std::string > const& sequence_ids = fasta.sequence_ids() ;
		for( std::size_t i = 0; i < sequence_ids.size(); ++i ) {
			genfile::Fasta::PositionedSequenceRange p = fasta.get_sequence( sequence_ids[i] ) ;
			std::string sequence( p.second.first, p.second.second ) ; 
			if( i == 0 ) {
				sequence_length = sequence.size() ;
			} else {
				if( sequence_length != sequence.size() ) {
					throw genfile::BadArgumentError(
						"PlotMSAApplication::unsafe_process()",
						"-msa",
						"Sequences \"" + sequence_ids[0] + "\" and \"" + sequence_ids[i] + "\" have different lengths "
						"(" + to_string(sequence_length) + " vs. " + to_string(sequence.size()) + ")"
					) ;
				}
			}
		}
	}
	
	std::vector< ContigSubsequenceSpec > parse_sequence_ids( genfile::Fasta const& fasta ) const {
		std::vector< ContigSubsequenceSpec > result ;
		fasta.sequence_ids( [&result,&fasta]( std::string const& id ) {
			try {
				result.push_back( ContigSubsequenceSpec( id )) ;
			}
			catch( genfile::string_utils::StringConversionError const& e ) {
				result.push_back( 
					ContigSubsequenceSpec(
						id,
						fasta.get_sequence( id ).first
					)
				) ;
			}
		}) ;

		return result ;
	}
	
	std::vector< GFFRecord > load_genes(
		std::string const& filename,
		genfile::GenomePositionRange const& range
	) const {
		std::vector< GFFRecord > result ;
		auto input = genfile::open_text_file_for_input( filename ) ;
		genfile::Position const a = std::min(
			range.start().position(),
			range.end().position()
		),
		b = std::max(
			range.start().position(),
			range.end().position()
		) ;
		
		{
			auto progress_context = ui().get_progress_context( "Loading genes" ) ;
			parse_gff( *input, [&]( GFFRecord const& record ) {
				progress_context.notify_progress() ;
				if(
					(record.sequence() == range.chromosome())
					&& (record.end() >= a)
					&& (record.start() <= b)
				) {
					result.push_back( record ) ;
				}
			}) ;
		}
		ui().logger() << "++ Loaded "
			<< result.size()
			<< " records in range "
			<< range << ".\n" ;
		return result ;
	}
	
	genfile::Fasta::UniquePtr load_highlights( std::string const& filename ) {
		auto result = genfile::Fasta::create() ;

		auto source = statfile::BuiltInTypeStatSource::open( filename ) ;
		{
			auto progress_context = ui().get_progress_context( "Loading highlights" ) ;
			std::size_t const nameIndex = source->index_of_column( "primer_name" ) ;
			std::size_t const sequenceIndex = source->index_of_column( "sequence" ) ;
			std::cerr << "COLUMN INDEX: " << nameIndex << ", " << sequenceIndex << ".\n" ;
			assert( nameIndex < sequenceIndex ) ; // TODO: allow this either way.
			std::string name, sequence ;
			while(
				(*source)
					>> statfile::ignore( nameIndex )
					>> name
					>> statfile::ignore( sequenceIndex - nameIndex - 1 )
					>> sequence
			) {
				result->add_sequence( name, sequence ) ;
				progress_context.notify_progress() ;
				(*source) >> statfile::ignore_all() ;
			}
		}
		ui().logger() << "++ Loaded "
			<< result->number_of_sequences()
			<< " from \"" << filename << "\".\n" ;
		return result ;
	}
	
	Annotations load_annotations(
		std::vector< std::string > const& specs,
		std::vector< ContigSubsequenceSpec > const& sequence_ids
	) {
		using genfile::string_utils::slice ;
		Annotations result ;
		for( std::string const& spec: specs ) {
			std::vector< slice > elts = slice( spec ).split( "=" );
			if( elts.size() != 2 ) {
				throw genfile::BadArgumentError(
					"load_annotations()",
					"spec=\"" + spec + "\"",
					"Expected name=value pair."
				) ;
			}
			load_bed4_annotation(
				elts[1],
				[&] ( RegionValue const& value ) {
					for( ContigSubsequenceSpec const& sequence_id: sequence_ids ) {
						genfile::Position const a = std::min(
							sequence_id.range().start().position(),
							sequence_id.range().end().position()
						),
						b = std::max(
							sequence_id.range().start().position(),
							sequence_id.range().end().position()
						) ;
						if(
							(value.range().chromosome() == sequence_id.id())
							&& (value.range().end().position() >= a )
							&& (value.range().start().position() <= b )
						) {
							result[value.range().chromosome()][elts[0]].push_back( value ) ;
						}
					}
				}
			) ;
		}
		return result ;
	}

	void load_bed4_annotation(
		std::string const& filename,
		boost::function< void( RegionValue const& ) > callback
	) {
		using genfile::string_utils::slice ;
		using genfile::string_utils::to_string ;
		using genfile::string_utils::to_repr ;
		auto input = genfile::open_text_file_for_input( filename ) ;
		{
			auto progress_context = ui().get_progress_context( "Loading annotations from \"" + filename + "\"" ) ;
			std::string line ;
			std::vector< slice > elts ;
			std::size_t count = 0 ;
			while( std::getline( *input, line )) {
				elts = slice( line ).split( "\t" ) ;
				if( elts.size() != 4 ) {
					throw genfile::MalformedInputError(
						filename,
						"Line " + to_string( count+1 ) + " contains wrong number of values (" + to_string( elts.size()) + ", should be 4).",
						count + 1
					) ;
				}
				
				callback(
					RegionValue(
						genfile::GenomePositionRange(
							genfile::Chromosome( elts[0] ),
							to_repr< genfile::Position >( elts[1] ),
							to_repr< genfile::Position >( elts[2] )
						),
						to_repr< double >( elts[3] )
					)
				) ;
				progress_context.notify_progress() ;
				++count ;
			}
		}
	}
	
	
	void write_html(
		std::ostream& out,
		genfile::Fasta const& fasta,
		std::vector< ContigSubsequenceSpec > const& sequence_ids,
		std::vector< GFFRecord > const& genes,
		genfile::Fasta::UniquePtr const& highlights,
		Annotations const& annotations
	) const {
		// This is a C++11 raw string literal
		std::string preamble = R""""(<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Multiple sequence alignment viewer</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.3.0/d3.min.js"></script>
	<script src="[URLBASE]/js/assert.js"></script>
	<script src="[URLBASE]/js/GeneView.js"></script>
	<script src="[URLBASE]/js/MSA.js"></script>
	<script src="[URLBASE]/js/AlignmentTrackScale.js"></script>
	<script src="[URLBASE]/js/MSAView.js"></script>
	<script src="[URLBASE]/js/MSAController.js"></script>
	<script src="[URLBASE]/js/run_msa_viewer.js"></script>
	<link href="[URLBASE]/css/msa_viewer.css" rel="stylesheet" >
</head>
<body>
	<section class="figure">
		<svg class = "names" width=900 height=600></svg>
		<svg class = "controls" width=900 height=200></svg>
		<canvas class = "sequences" width=900 height=600></canvas>
		<svg class = "genes" width=900 height=200></svg>
	</section>
</body>
<script>
	data = )"""" ;
		boost::algorithm::replace_all( preamble, "[URLBASE]", options().get< std::string >( "-url-base" )) ;
		out
			<< preamble
			<< "{\n"
			<< "  \"alignment\": "
			<< sequencesToJSON( fasta, sequence_ids )
			<< ",\n"
			<< "  \"ranges\": "
			<< rangesToJSON( sequence_ids )
			<< ",\n  \"genes\": "
			<< genesToJSON( genes )
			<< ",\n" ;
		if( highlights.get() ) { 
			out
				<< "  \"highlights\": "
				<< sequencesToJSON( *highlights )
				<< ",\n" ;
		} else {
			out
				<< "  \"highlights\": {}"
				<< ",\n" ;
		}
		if( annotations.size() > 0 ) {
			out
 				<< "  \"annotations\": "
				<< annotationsToJSON( annotations )
				<< "\n" ;
		} else {
			out
				<< "  \"annotations\": {}\n" ;
		}
		out
			<< "};\n"
			<< "run_msa_viewer( data ) ;\n"
			<< "</script>\n"
			<< "</html>\n" ;
	}

	std::string sequencesToJSON(
		genfile::Fasta const& fasta,
		std::vector< ContigSubsequenceSpec > const& sequence_ids
	) const {
		std::ostringstream s ;
		s << "[\n" ;
		std::size_t count = 0 ;
		std::deque< char > sequence ;
		for( auto& sequence_id: sequence_ids ) {
			genfile::Fasta::PositionedSequenceRange p = fasta.get_sequence( sequence_id.spec() ) ;
			s << (count>0 ? ",\n" : "" )
				<< "{ \"name\": \""
				<< sequence_id.id()
				<< "\", \"sequence\": \""
				<< std::string( p.second.first, p.second.second )
				<< "\" }" ;
			++count ;
		}
		s << "\n]" ;
		return s.str() ;
	}
	
	std::string sequencesToJSON(
		genfile::Fasta const& fasta
	) const {
		return sequencesToJSON( fasta, parse_sequence_ids( fasta )) ;
	}
	

	std::string genesToJSON( std::vector< GFFRecord > const& genes ) const {
		std::ostringstream s ;
		s << "[\n" ;
		for( std::size_t i = 0; i < genes.size(); ++i ) {
			GFFRecord const& gene = genes[i] ;
			genfile::VariantEntry const display = (gene.gene_name().is_missing() ? gene.ID() : gene.gene_name() ) ;
			s << ((i>0) ? ",\n" : "") ;
			s << "{ "
				<< "\"ID\": \"" << gene.ID() << "\", "
				<< "\"feature\": \"" << gene.feature() << "\", "
				<< "\"parent\": \"" << gene.parent() << "\", "
				<< "\"chromosome\": \"" << gene.sequence() << "\", "
				<< "\"start\": " << gene.start() << ", "
				<< "\"end\": " << gene.end() << ", "
				<< "\"strand\": \"" << gene.strand() << "\", "
				<< "\"display\": \"" << display << "\" }" ;
		}
		s << "\n]" ;
		return s.str() ;
	}

	std::string rangesToJSON( std::vector< ContigSubsequenceSpec > const& sequence_ids ) const {
		std::ostringstream s ;
		s << "{\n" ;
		for( std::size_t i = 0; i < sequence_ids.size(); ++i ) {
			auto& sequence_id = sequence_ids[i] ;
			s
				<< ((i>0) ? ",\n" : "" )
				<< "\""
				<< sequence_id.id()
				<< "\": { "
				<< "\"chromosome\": \""
				<< sequence_id.range().chromosome()
				<< "\", \"start\": "
				<< sequence_id.range().start().position()
				<< ", \"end\": "
				<< sequence_id.range().end().position()
				<< " }" ;
		}
		s << "\n}" ;
		return s.str() ;
	}

	std::string annotationsToJSON( Annotations const& annotations ) const {
		std::ostringstream s ;
		s << "{\n" ;
		Annotations::const_iterator i = annotations.begin(), end_i = annotations.end() ;
		for( std::size_t icount = 0; i != end_i; ++i, ++icount ) {
			std::string const& sequence_name = i->first ;
			Annotation::const_iterator j = i->second.begin(), end_j = i->second.end() ;
			s	<< ((icount>0) ? ",\n" : "")
				<< "  \"" << sequence_name << "\": {\n" ;
			for( std::size_t jcount = 0; j != end_j; ++j, ++jcount ) {
				std::string const& annotation_name = j->first ;
				s	<< ((jcount>0) ? ",\n" : "")
					<< "    \"" << annotation_name << "\": [\n" ;
				std::vector< RegionValue > const& values = j->second ;
				for( std::size_t i = 0; i < values.size(); ++i ) {
					RegionValue const& v = values[i] ;
					s << ((i>0) ? ",\n" : "" )
						<< "      { \"chromosome\": \"" << v.range().chromosome() << "\", "
						<< "\"start\": " << v.range().start().position() + 1 << ", "
						<< "\"end\": " << v.range().end().position() << ", "
						<< "\"value\": " << v.value()
						<< "}" ;
				}
				s << "\n    ]" ;
			}
			s << "\n  }" ;
		}
		s << "\n}" ;
		return s.str() ;
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		PlotMSAApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
