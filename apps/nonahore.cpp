
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <vector>
#include <string>
#include <numeric>
#include <Eigen/Core>

#include <boost/random/mersenne_twister.hpp>
#include <boost/random/uniform_int_distribution.hpp>
#include <boost/random/uniform_01.hpp>
#include <boost/random/beta_distribution.hpp>
#include <boost/math/distributions/geometric.hpp>

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "statfile/BuiltInTypeStatSource.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#include "svelte/GaussianCoverageLoglikelihood.hpp"
#include "svelte/MixtureCoverageLoglikelihood.hpp"
#include "svelte/CoverageProfile.hpp"
#include "svelte/SVHaplotype.hpp"
#include "svelte/SVPopulationModel.hpp"

#define DEBUG 0

namespace globals {
	std::string const program_name = "nonahore" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct NonahoreOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-c" ]
			.set_description( "Path to file containing coverage data." )
			.set_takes_single_value()
			.set_is_required()
		;

		options[ "-t" ]
			.set_description( "Path to file containing coverage data for training." )
			.set_takes_single_value()
			.set_is_required()
		;

		options[ "-og" ]
			.set_description( "Path of output genotypes file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options.declare_group( "Model options" ) ;
		options[ "-penalty" ]
			.set_description( "Parameter of geometric distribution penalty on number of SVs" )
			.set_takes_single_value()
			.set_default_value( 0.5 ) ;

		options[ "-iterations" ]
			.set_description( "Number of iterations to run" )
			.set_takes_single_value()
			.set_default_value( 1 ) ;

		options[ "-ploidy" ]
			.set_description( "Ploidy of samples" )
			.set_takes_single_value()
			.set_default_value( 2 ) ;

	}
} ;

struct NonahoreApplication: public appcontext::ApplicationContext
{
public:
	NonahoreApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new NonahoreOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:

	typedef svelte::CoverageProfile CoverageProfile ;
	typedef svelte::SVHaplotype SVHaplotype ;
	typedef std::map< CoverageProfile, std::vector< SVHaplotype > > ProfileSVMap ;
	ProfileSVMap m_profileHaplotypeMap ;
	
	boost::random::mt19937 m_rng ;
	
	void unsafe_process() {
		unsafe_process(
			options().get< std::string >( "-t" ),
			options().get< std::string >( "-c" )
		) ;
	}
	
	void unsafe_process(
		std::string const& training_filename,
		std::string const& data_filename
	) {
		std::vector< std::string > samples ;
		std::vector< std::pair< genfile::GenomePositionRange, std::size_t > > bins ;
		Eigen::MatrixXd coverage ;
		
		// Learn means and variances from the training data
		{
			auto source = statfile::BuiltInTypeStatSource::open( training_filename ) ;
			read_svelte_output( *source, &samples, &bins, &coverage ) ;
		}
		Eigen::RowVectorXd means = coverage.colwise().sum() / coverage.rows() ;
		Eigen::RowVectorXd variances = (coverage - means.replicate( coverage.rows(), 1 )).array().square().colwise().sum() / (coverage.rows() - 1) ;

		// Load actual coverage data
		{
			auto source = statfile::BuiltInTypeStatSource::open( data_filename ) ;
			read_svelte_output( *source, &samples, &bins, &coverage ) ;
		}

		int const ploidy = options().get< int >( "-ploidy" ) ;

		std::cerr << "LOADED COVERAGE:\n" ;
		std::cerr << coverage.block( 0, 0, std::min( coverage.rows(), 10l ), std::min( coverage.cols(), 10l )) << ".\n" ;
		std::cerr << "    PREDICTED " << ploidy << "-ploid MEANS: " << ( means / ploidy ) << ".\n" ;
		std::cerr << "PREDICTED " << ploidy << "-ploid VARIANCES: " << ( variances / ploidy ) << ".\n" ;
		std::cerr << "\n...processing...\n\n" ;

		SVHaplotype haplotype( 0, bins.size() ) ;
		svelte::SVPopulationModel referenceModel( haplotype.toProfile() ) ;
		m_profileHaplotypeMap[ haplotype.toProfile() ].push_back( haplotype ) ;

		svelte::MixtureCoverageLoglikelihood ll(
			means / ploidy,
			variances / ploidy,
			coverage
		) ;

		Eigen::MatrixXd theLLs ;
		Eigen::VectorXd totalLLs( means.size() ) ;
		svelte::SVPopulationModel bestPopulationModel = referenceModel ;

		boost::math::geometric geometric( options().get< double >( "-penalty" )) ;
		using boost::math::pdf ;
		std::size_t const max_iterations = options().get< std::size_t >( "-iterations" ) ;
		for( std::size_t iteration = 0; iteration < max_iterations; ++iteration, referenceModel = bestPopulationModel ) {
			{
				ProfileSVMap new_profileHaplotypeMap( m_profileHaplotypeMap ) ;
				std::set< SVHaplotype > visited_haplotypes ;
				std::set< CoverageProfile > visited_profiles ;
				
				std::vector< svelte::SVPopulationModel > new_models ;
				new_models.reserve( 1000000 ) ;

				// Always include this one
				new_models.push_back( referenceModel ) ;

				// Try removing one
				for( std::size_t i = 1; i < referenceModel.profiles().size(); ++i ) {
					svelte::SVPopulationModel model = referenceModel ;
					model.remove( referenceModel.profiles()[i] ) ;
					new_models.push_back( model ) ;
				}
				
				std::cerr << "\n"
					<< "ITERATION " << iteration << ": Adjusting frequencies...\n" ;
				if( referenceModel.size() > 1 ) {
					sample_frequencies(
						referenceModel,
						200,
						[&]( svelte::SVPopulationModel const& model ) {
							new_models.push_back( model ) ;
						}
					) ;
				}
				
				std::cerr << "ITERATION " << iteration << ": Generating recombinants...\n" ;
				sample_recombinant_haplotypes_from_profiles(
					referenceModel,
					m_profileHaplotypeMap,
					1000,
					[&]( SVHaplotype const& haplotype ) {
						CoverageProfile const profile = haplotype.toProfile() ;
						bool haplotypeIsNovel = visited_haplotypes.insert( haplotype ).second ;
						bool profileIsNovel = visited_profiles.insert( profile ).second ;
						if( haplotypeIsNovel ) {
							new_profileHaplotypeMap[ profile ].push_back( haplotype ) ;
						}
#if 0
						std::cerr << profile.toString() << "\n" ;
#endif
						if( !profileIsNovel || referenceModel.contains( profile )) {
							//std::cerr << "  Skipped: " << profile.toString() << ".\n" ;
						} else {
							
							// add
							for( std::size_t f = 5; f <= 95; f += 10 ) {
								svelte::SVPopulationModel model = referenceModel ;
								model.add( profile, double(f)/100 ) ;
								new_models.push_back( model ) ;
							}

							// replace
							for( std::size_t i = 1 ; i < referenceModel.profiles().size(); ++i ) {
								svelte::SVPopulationModel model = referenceModel ;
								model.replace( i, profile ) ;
								new_models.push_back( model ) ;
							}
						}
					}
				) ;

				std::cerr << "ITERATION " << iteration << ": Evaluating lls...\n" ;
				// Now evaluate LLs...
				ll.evaluate( referenceModel, &theLLs ) ;
				rowwise_log_sum_exp( theLLs, &totalLLs ) ;
				bestPopulationModel = referenceModel ;
				double const referenceLL = totalLLs.sum() ;
				double const referencePenalty = std::log( pdf( geometric, referenceModel.size() )) ;
				double bestModelLL = referenceLL ;
				double bestModelPenalty = referencePenalty ;
				
				for( auto new_model: new_models ) {
					ll.evaluate( new_model, &theLLs ) ;
					rowwise_log_sum_exp( theLLs, &totalLLs ) ;
					double const LL = totalLLs.sum() ;
					double const penalty = std::log( pdf( geometric, new_model.size() )) ;
#if 0
					std::cerr
						<< "  ITERATION: " << iteration
						<< ": MODEL: " << new_model.toString()
						<< ": LL = " << LL
						<< "\n" ;
#endif
					if( (LL + penalty) > (bestModelLL + bestModelPenalty) ) {
						bestPopulationModel = new_model ;
						bestModelLL = LL ;
						bestModelPenalty = penalty ;
					}
				}
		
				m_profileHaplotypeMap.swap( new_profileHaplotypeMap ) ;
				std::cerr << "\n" ;
				std::cerr
					<< "++ AFTER ITERATION " << iteration << ":\n"
					<< "++ BEST MODEL:\n" << bestPopulationModel.prettyPrint()
					<< "++ LL = " << bestModelLL << " with penalty: " << bestModelPenalty
					<< ".\n" ;
			}
			
			referenceModel = bestPopulationModel ;
		}

#if 0
		std::cerr << "ALLELES:\n" ;
		{
			auto profiles = bestPopulationModel.profiles() ;
			for( std::size_t i = 0; i < profiles.size(); ++i ) {
				auto profile = profiles[i] ;
				auto where = m_profileHaplotypeMap.find( profile ) ;
				assert( where != m_profileHaplotypeMap.end() ) ;
				std::cerr << profile.toString() << ":\n" ;
				for( auto hap: where->second ) {
					std::cerr << " -> " << hap.toString() << "\n" ;
				}
			}
		}
#endif
		std::cerr << "Writing genotypes.\n" ;
		{
			ll.evaluate( bestPopulationModel, &theLLs ) ;
			// divide by totals to get probabilities
			rowwise_log_sum_exp( theLLs, &totalLLs ) ;
			theLLs -= totalLLs.replicate( 1, theLLs.cols() ) ;
			// find maxima carrying non-ref haplotypes
			auto profiles = bestPopulationModel.profiles() ;
			std::vector< std::string > genotypes ;
			for( std::size_t i = 0 ; i < profiles.size(); ++i ) {
				for( std::size_t j = i; j < profiles.size(); ++j ) {
					genotypes.push_back( genfile::string_utils::to_string( i ) + "/" + genfile::string_utils::to_string( j ) ) ;
				}
			}
			statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open( options().get< std::string >( "-og" )) ;
			(*sink) | "sample" | "genotype" ;
			for( int i = 0; i < theLLs.rows(); ++i ) {
				int j ;
				theLLs.row(i).maxCoeff( &j ) ;
				(*sink) << samples[i] << genotypes[j] << statfile::end_row() ;
				//std::cerr << genotypes[j]<< ": " << samples[i] << "\n" ;
			}
		}
	}
	
	// Read an output file from svelte.
	void read_svelte_output(
		statfile::BuiltInTypeStatSource& source,
		std::vector< std::string >* samples,
		std::vector< std::pair< genfile::GenomePositionRange, std::size_t > >* bins,
		Eigen::MatrixXd* coverage
	) {
		std::vector< std::string > column_names = source.column_names() ;
		std::vector< std::pair< std::string, std::size_t > > sampleColumns ;
		sampleColumns.reserve( column_names.size() / 2 ) ;
		for( std::size_t i = 0; i < column_names.size(); ++i ) {
			auto name = column_names[i] ;
			if( name.size() > 9 && name.substr( name.size() - 9, name.size() ) == ":coverage" && name != "total:coverage" ) {
				sampleColumns.push_back( std::make_pair( name.substr( 0, name.size() - 9 ), i )) ;
			}
		}
		std::vector< std::pair< genfile::GenomePositionRange, std::size_t > > loadedBins ;
		std::vector< double > coverage_data ;
		coverage_data.reserve( 1000 * sampleColumns.size() ) ;

		using genfile::string_utils::to_repr ;
		std::string chromosome ;
		uint32_t position, size, N ;
		while( source >> chromosome >> position >> size >> N ) {
			loadedBins.push_back(
				std::make_pair( genfile::GenomePositionRange( chromosome, position, position + size ), N )
			) ;
			std::size_t sample_i = 0 ;
			std::string stringValue ;
			bool ignoreThisBin = false ;
			for( ; sample_i < sampleColumns.size(); ++sample_i ) {
				while( source.current_column() < sampleColumns[sample_i].second ) {
					source >> statfile::ignore() ;
				}
				source >> stringValue ;
				if( stringValue == "NA" ) {
					ignoreThisBin = true ;
				} else {
					coverage_data.push_back( to_repr< double >( stringValue ) ) ;
				}
			}
			source >> statfile::ignore_all() ;
			if( ignoreThisBin ) {
				loadedBins.pop_back() ;
			}
		}

		assert( coverage_data.size() == loadedBins.size() * sampleColumns.size() ) ;
		
		// copy data to output
		bins->swap( loadedBins ) ;

		samples->resize( sampleColumns.size() ) ;
		for( std::size_t i = 0; i < sampleColumns.size(); ++i ) {
			(*samples)[i] = sampleColumns[i].first ;
		}

		coverage->setZero( bins->size(), samples->size() ) ;
		for( std::size_t i = 0; i < coverage_data.size(); ++i ) {
			(*coverage)( i / sampleColumns.size(), i % sampleColumns.size() ) = coverage_data[i] ;
		}
		// form coverage averages, not totals.
		for( int row = 0; row < coverage->rows(); ++row ) {
			(*coverage).row(row) = (*coverage).row(row) / (*bins)[std::size_t(row)].second ;
		}
	}
	
	void generate_recombinant_haplotypes_from_profiles(
		std::vector< svelte::CoverageProfile > const& profiles,
		ProfileSVMap const& profileHaplotypeMap,
		std::function< void( SVHaplotype const& ) > callback
	) {
		// generate all recombinant haplotypes
		for( std::size_t pi = 0; pi < profiles.size(); ++pi ) {
			ProfileSVMap::const_iterator where_i = profileHaplotypeMap.find( profiles[pi] ) ;
			assert( where_i != profileHaplotypeMap.end() ) ;
			for( std::size_t pj = pi; pj < profiles.size() ; ++pj ) {
				ProfileSVMap::const_iterator where_j = profileHaplotypeMap.find( profiles[pj] ) ;
				assert( where_j != profileHaplotypeMap.end() ) ;
				for( std::size_t hapi = 0; hapi < where_i->second.size(); ++hapi ) {
					for( std::size_t hapj = (pi==pj) ? hapi : 0; hapj < where_j->second.size(); ++hapj ) {
						SVHaplotype const& hap1 = where_i->second[hapi] ;
						SVHaplotype const& hap2 = where_j->second[hapj] ;
						generate_recombinant_haplotypes( hap1, hap2, callback ) ;
					}
				}
			}
		}
	}

	void sample_frequencies(
		svelte::SVPopulationModel const& model,
		std::size_t N,
		std::function< void( svelte::SVPopulationModel const& ) > callback
	) {
		typedef boost::random::uniform_int_distribution< std::size_t > Uniform ;
		typedef boost::random::beta_distribution< double > Beta ;
		std::vector< double > const frequencies = model.frequencies() ;
		std::vector< double > new_frequencies( frequencies ) ;
		double sum = std::accumulate( frequencies.begin(), frequencies.end(), 0.0 ) ;
		Uniform selector( 0, frequencies.size() - 1 ) ;
		Beta frequencyGenerator( 1.02, 1.02 ) ; // use beta distribution to avoid zero.
		for( std::size_t i = 0; i < N; ++i ) {
			// pick a random frequency to change
			std::size_t w = selector( m_rng ) ;
			// pick a random value to change by
			new_frequencies = frequencies ;
			new_frequencies[w] = frequencyGenerator( m_rng ) ;
			double sumOfOthers = sum - frequencies[w] ;
			for( std::size_t k = 0; k < new_frequencies.size(); ++k ) {
				if( k != w ) {
					new_frequencies[k] /= sumOfOthers ;
				}
			}
			svelte::SVPopulationModel newModel = model ;
			newModel.set_frequencies( new_frequencies ) ;
			callback( newModel ) ;
		}
	}

	std::size_t select_by_frequency( std::vector< double > const& frequencies ) {
		typedef boost::random::uniform_01< std::size_t > Uniform ;
		Uniform selector ;
		double value = selector( m_rng ) ;
		std::size_t result = 0 ;
		for(
			value -= frequencies[0];
			(result < frequencies.size()) && (value > 0) ;
			value -= frequencies[++result]
		) {
			// nothing to do
		}
		return result ;
	}

	void sample_recombinant_haplotypes_from_profiles(
		svelte::SVPopulationModel const& model,
		ProfileSVMap const& profileHaplotypeMap,
		std::size_t const N,
		std::function< void( SVHaplotype const& ) > callback
	) {
		std::vector< svelte::CoverageProfile > const& profiles = model.profiles() ;
		std::vector< double > const frequencies = model.frequencies() ;
		typedef boost::random::uniform_int_distribution< std::size_t > UniformInt ;
		for( std::size_t i = 0; i < N; ++i ) {
			std::size_t const pi = select_by_frequency( frequencies ) ;
			std::size_t const pj = select_by_frequency( frequencies ) ;
			auto where_i = profileHaplotypeMap.find( profiles[pi] ) ;
			auto where_j = profileHaplotypeMap.find( profiles[pj] ) ;
			assert( where_i != profileHaplotypeMap.end() ) ;
			assert( where_j != profileHaplotypeMap.end() ) ;

			UniformInt leftHapSelector( 0, where_i->second.size() - 1 ) ;
			UniformInt rightHapSelector( 0, where_j->second.size() - 1 ) ;

			SVHaplotype const& leftHap = where_i->second[ leftHapSelector( m_rng ) ] ;
			SVHaplotype const& rightHap = where_j->second[ rightHapSelector( m_rng ) ] ;

			UniformInt leftBreakpointSelector( 1, leftHap.size() - 1 ) ;
			UniformInt rightBreakpointSelector( 1, rightHap.size() - 1 ) ;

			callback(
				splice(
					leftHap, leftBreakpointSelector( m_rng ),
					rightHap, rightBreakpointSelector( m_rng )
				)
			) ;
		}
	}
	
	void generate_recombinant_haplotypes(
		SVHaplotype const& haplotype1,
		SVHaplotype const& haplotype2,
		std::function< void( SVHaplotype const& ) > callback
	) {
		std::size_t const leftSize = haplotype1.size() ;
		std::size_t const rightSize = haplotype2.size() ;
		for( std::size_t leftBreakpoint = 1; leftBreakpoint < leftSize - 1; ++leftBreakpoint ) {
			for( std::size_t rightBreakpoint = 1; rightBreakpoint < rightSize - 1; ++rightBreakpoint ) {
				callback(
					splice(
						haplotype1, leftBreakpoint,
						haplotype2, rightBreakpoint
					)
				) ;
			}
		}
	}

	template< typename Matrix >
	double log_sum_exp( Matrix const& data ) {
		if( data.size() == 0 ) {
			return 0.0 ;
		}
		double max_value = data.array().maxCoeff() ;
		if( max_value == -std::numeric_limits< double >::infinity() ) {
			return max_value ;
		}
		Eigen::MatrixXd const exponential = ( data - Eigen::MatrixXd::Constant( data.rows(), data.cols(), max_value ) ).array().exp() ;
		return max_value + std::log( exponential.array().sum() ) ;
	}
	
	void rowwise_log_sum_exp( Eigen::MatrixXd const& data, Eigen::VectorXd* result ) {
		assert( result ) ;
		assert( result->size() == data.rows() ) ;
		for( int i = 0; i < result->size(); ++i ) {
			(*result)(i) = log_sum_exp( data.row(i) ) ;
		}
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		NonahoreApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
