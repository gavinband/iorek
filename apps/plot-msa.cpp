
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include "boost/regex.hpp"

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "plot-msa" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct PlotMSAOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-msa" ]
			.set_description( "Path of FASTA file(s) (or gzipped FASTA file(s)) containing the multiple sequence alignment." )
			.set_is_required()
			.set_takes_values_until_next_option()
		;
		
		options[ "-o" ]
			.set_description( "Path of output HTML file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
		
		options[ "-highlight" ]
			.set_description( "Specify sequences to highlight in the resulting visualisation" )
			.set_takes_values_until_next_option() ;
		
		options[ "-distinguish" ]
			.set_description( "Specify the name of a single sequence to distinguish" )
			.set_takes_single_value() ;
		
		options[ "-genes" ]
			.set_description( "Specific a sqlite file of genes to load" )
			.set_takes_single_value() ;
		
		options.option_implies_option( "-genes", "-distinguish" ) ;
	}
} ;

namespace {
}

struct GFFRecord: public boost::noncopyable {
public:
	typedef genfile::string_utils::slice slice ;
private:
	static genfile::VariantEntry parse_attributes( std::string const& attributes, std::string const& attribute ) {
		// inefficient to compile re each time - improve this.
		const boost::regex re( attribute + "=([^;]+)" ) ;
		boost::match_results<std::string::const_iterator> match ;
		bool success = boost::regex_search( attributes, match, re ) ;
		if( !success || !match[1].matched) {
			return genfile::MissingValue() ;
		} else {
			return std::string( match[1].first, match[1].second ) ;
		}
	}

public:
	static GFFRecord parse( std::string const& line ) {
		using genfile::string_utils::split ;
		GFFRecord result ;
		result.m_data = line ;
		result.m_elts = slice(result.m_data).split( "\t" ) ;
		assert( result.m_elts.size() == 9 ) ;
		result.m_start = genfile::string_utils::to_repr< genfile::Position >( result.m_elts[3] ) ;
		result.m_end = genfile::string_utils::to_repr< genfile::Position >( result.m_elts[4] ) ;
		result.m_ID = GFFRecord::parse_attributes( result.m_elts[8], "ID" ) ;
		result.m_parent = GFFRecord::parse_attributes( result.m_elts[8], "Parent" ) ;
		result.m_description = GFFRecord::parse_attributes( result.m_elts[8], "description" ) ;
		return result ;
	}

	GFFRecord( GFFRecord const& other ):
		m_data( other.m_data ),
		m_elts( other.m_elts ),
		m_start( other.m_start ),
		m_end( other.m_end ),
		m_ID( other.m_ID ),
		m_parent( other.m_parent ),
		m_description( other.m_description )
	{
		// fix elts to refer to our own data
		for( std::size_t i = 0; i < m_elts.size(); ++i ) {
			m_elts[i] = slice( m_data, m_elts[i].get_start(), m_elts[i].get_end() ) ;
		}
	}
		
private:
	GFFRecord() {}
		
public:
	
	slice const& sequence() const { return m_elts[0] ; }
	slice const& source() const { return m_elts[1] ; }
	slice const& feature() const { return m_elts[2] ; }
	genfile::Position start() const { return m_start ; }
	genfile::Position end() const { return m_end ; }
	slice const& score() const { return m_elts[5] ; }
	slice const& strand() const { return m_elts[6] ; }
	slice const& phase() const { return m_elts[7] ; }
	slice const& attributes() const { return m_elts[8] ; }
	genfile::VariantEntry const& ID() const { return m_ID ; }
	genfile::VariantEntry const& parent() const { return m_parent ; }
private:
	std::string m_data ;
	std::vector< slice > m_elts ;
	genfile::Position m_start ;
	genfile::Position m_end ;
	genfile::VariantEntry m_ID ;
	genfile::VariantEntry m_parent ;
	genfile::VariantEntry m_description ;
} ;

void parse_gff( std::istream& input, std::function< void( GFFRecord const& record ) > callback ) {
	std::string line ;
	while( std::getline( input, line )) {
		if( line.size() > 0 && line[0] != '#' ) {
			callback( GFFRecord::parse( line ) ) ;
		}
	}
}

struct PlotMSAApplication: public appcontext::ApplicationContext
{
public:
	PlotMSAApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new PlotMSAOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( appcontext::OptionProcessingException const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		} catch( genfile::DuplicateKeyError const& e ) {
			// this 
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:

	void unsafe_process() {
		using genfile::string_utils::to_string ;

		genfile::Fasta fasta ;
		auto filenames = options().get_values< std::string >( "-msa" ) ;
		for( auto& filename: filenames ) {
			auto progress_context = ui().get_progress_context( "Loading \"" + filename + "\"" ) ;
			fasta.add_sequences_from_file( filename, progress_context ) ;
		}
		ui().logger() << "Loaded MSA with " << fasta.number_of_sequences() << " sequences.\n" ;

		ui().logger() << "Checking sequences...\n" ;
		{
			std::size_t sequence_length = 0 ;
			std::vector< std::string > const& sequence_ids = fasta.sequence_ids() ;
			for( std::size_t i = 0; i < sequence_ids.size(); ++i ) {
				genfile::Fasta::PositionedSequenceRange p = fasta.get_sequence( sequence_ids[i] ) ;
				std::string sequence( p.second.first, p.second.second ) ; 
				if( i == 0 ) {
					sequence_length = sequence.size() ;
				} else {
					if( sequence_length != sequence.size() ) {
						throw genfile::BadArgumentError(
							"PlotMSAApplication::unsafe_process()",
							"-msa",
							"Sequences \"" + sequence_ids[0] + "\" and \"" + sequence_ids[i] + "\" have different lengths "
							"(" + to_string(sequence_length) + " vs. " + to_string(sequence.size()) + ")"
						) ;
					}
				}
			}
		}

		std::string const& output = options().get< std::string >( "-o" ) ;
		ui().logger() << "Writing output to \"" << output << "\"....\n" ;
		std::auto_ptr< std::ostream > ostr = genfile::open_text_file_for_output( output ) ;
		write_html( *ostr, fasta ) ;
	}
	
	void write_html( std::ostream& out, genfile::Fasta const& fasta ) const {
		// This is a C++11 raw string literal
		out << R""""(<!DOCTYPE html>
<html>
<head>
</head>
<body>
	<svg width=900 height=800 style="border: 1px solid black;">
				<rect x=10 y=10 width=2 height = 2></rect></svg>
</body>
<script>
	data = )"""" ;
		out << toJSON( fasta ) ;
		out
			<< ";\n</script>\n"
			<< "</html>\n" ;
	}

	std::string toJSON( genfile::Fasta const& fasta ) const {
		std::ostringstream s ;
		s << "[\n" ;
		std::size_t count = 0 ;
		std::deque< char > sequence ;
		for( auto& name: fasta.sequence_ids() ) {
			genfile::Fasta::PositionedSequenceRange p = fasta.get_sequence( name ) ;
			s << (count>0 ? ",\n" : "" )
				<< "{ \"name\": \""
				<< name
				<< "\", \"sequence\": \""
				<< std::string( p.second.first, p.second.second )
				<< "\" }" ;
			++count ;
		}
		s << "\n]" ;
		return s.str() ;
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		PlotMSAApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
