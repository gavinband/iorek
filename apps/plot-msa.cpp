
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include "boost/regex.hpp"
#include <boost/algorithm/string/replace.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "plot-msa" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct PlotMSAOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-msa" ]
			.set_description( "Path of FASTA file(s) (or gzipped FASTA file(s)) containing the multiple sequence alignment." )
			.set_is_required()
			.set_takes_values_until_next_option()
		;
		
		options[ "-o" ]
			.set_description( "Path of output HTML file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
		
		options[ "-highlight" ]
			.set_description( "Specify sequences to highlight in the resulting visualisation" )
			.set_takes_values_until_next_option() ;
		
		options[ "-distinguish" ]
			.set_description( "Specify the names sequences to distinguish. "
				" These will be displayed prominently in the output (e.g. by placing them at the bottom). "
				"The *last value* specified here represents a 'reference' sequence against which genes will be plotted." )
			.set_takes_values_until_next_option() ;

		options[ "-genes" ]
			.set_description( "Specific a gff file of genes to load" )
			.set_takes_single_value() ;
		
		options.option_implies_option( "-genes", "-distinguish" ) ;
		
		options.declare_group( "URL options" ) ;
		options[ "-url-base" ]
			.set_description(
				"Specify the base used to construct the urls containing the viewer implementation. "
				"By default this points to my server, but you can point to a local copy of the javascript and css code, "
				" or place a copy elsewhere on the web, if desired." )
			.set_takes_single_value()
			.set_default_value( "https://www.well.ox.ac.uk/~gav/projects/msa_viewer" ) ;
	}
} ;

namespace {
}

struct GFFRecord: public boost::noncopyable {
public:
	typedef genfile::string_utils::slice slice ;
private:
	static genfile::VariantEntry parse_attributes( std::string const& attributes, std::string const& attribute ) {
		// inefficient to compile re each time - improve this.
		const boost::regex re( attribute + "=([^;]+)" ) ;
		boost::match_results<std::string::const_iterator> match ;
		bool success = boost::regex_search( attributes, match, re ) ;
		if( !success || !match[1].matched) {
			return genfile::MissingValue() ;
		} else {
			return std::string( match[1].first, match[1].second ) ;
		}
	}

public:
	static GFFRecord parse( std::string const& line ) {
		using genfile::string_utils::split ;
		GFFRecord result ;
		result.m_data = line ;
		result.m_elts = slice(result.m_data).split( "\t" ) ;
		assert( result.m_elts.size() == 9 ) ;
		result.m_start = genfile::string_utils::to_repr< genfile::Position >( result.m_elts[3] ) ;
		result.m_end = genfile::string_utils::to_repr< genfile::Position >( result.m_elts[4] ) ;
		result.m_ID = GFFRecord::parse_attributes( result.m_elts[8], "ID" ) ;
		result.m_parent = GFFRecord::parse_attributes( result.m_elts[8], "Parent" ) ;
		result.m_description = GFFRecord::parse_attributes( result.m_elts[8], "description" ) ;
		return result ;
	}

	GFFRecord( GFFRecord const& other ):
		m_data( other.m_data ),
		m_elts( other.m_elts ),
		m_start( other.m_start ),
		m_end( other.m_end ),
		m_ID( other.m_ID ),
		m_parent( other.m_parent ),
		m_description( other.m_description )
	{
		// fix elts to refer to our own data
		for( std::size_t i = 0; i < m_elts.size(); ++i ) {
			m_elts[i] = slice( m_data, m_elts[i].get_start(), m_elts[i].get_end() ) ;
		}
	}
	
private:
	GFFRecord() {}
		
public:
	
	slice const& sequence() const { return m_elts[0] ; }
	slice const& source() const { return m_elts[1] ; }
	slice const& feature() const { return m_elts[2] ; }
	genfile::Position start() const { return m_start ; }
	genfile::Position end() const { return m_end ; }
	slice const& score() const { return m_elts[5] ; }
	slice const& strand() const { return m_elts[6] ; }
	slice const& phase() const { return m_elts[7] ; }
	slice const& attributes() const { return m_elts[8] ; }
	genfile::VariantEntry const& ID() const { return m_ID ; }
	genfile::VariantEntry const& parent() const { return m_parent ; }
private:
	std::string m_data ;
	std::vector< slice > m_elts ;
	genfile::Position m_start ;
	genfile::Position m_end ;
	genfile::VariantEntry m_ID ;
	genfile::VariantEntry m_parent ;
	genfile::VariantEntry m_description ;
} ;

void parse_gff( std::istream& input, std::function< void( GFFRecord const& record ) > callback ) {
	std::string line ;
	while( std::getline( input, line )) {
		if( line.size() > 0 && line[0] != '#' ) {
			callback( GFFRecord::parse( line ) ) ;
		}
	}
}

struct PlotMSAApplication: public appcontext::ApplicationContext
{
public:
	PlotMSAApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new PlotMSAOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( appcontext::OptionProcessingException const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		} catch( genfile::DuplicateKeyError const& e ) {
			// this 
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:

	struct SequenceIdentifier {
		SequenceIdentifier( std::string spec ):
			m_spec( spec ),
			m_range( genfile::GenomePositionRange::parse( spec )),
			m_id( m_range.chromosome() )
		{}

		SequenceIdentifier( SequenceIdentifier const& other ):
			m_spec( other.m_spec ),
			m_id( other.m_id ),
			m_range( other.m_range )
		{}

		SequenceIdentifier& operator=( SequenceIdentifier const& other ) {
			m_id = other.m_id ;
			m_spec = other.m_spec ;
			m_range = other.m_range ;
			return *this ;
		}
		
		std::string const& spec() const { return m_spec ; }
		std::string const& id() const { return m_id ; }
		genfile::GenomePositionRange const& range() const { return m_range ; }
		
	private:
		SequenceIdentifier() ;
		
	private:
		std::string m_spec ;
		genfile::GenomePositionRange m_range ;
		std::string m_id ;
	} ;

	void unsafe_process() {
		genfile::Fasta::UniquePtr fasta = load_fasta(
			options().get_values< std::string >( "-msa" )
		) ;
		check_sequence_lengths( *fasta ) ;

		auto sequence_ids = parse_sequence_ids( *fasta ) ;

		if( options().check( "-distinguish" )) {
			std::vector< std::string > const& distinguished = options().get_values< std::string >( "-distinguish" ) ;
			for( auto& id: distinguished ) {
				std::size_t i = 0 ;
				for( ; i < sequence_ids.size(); ++i ) {
					if( sequence_ids[i].id() == id ) {
						break ;
					}
				}
				if( i == sequence_ids.size() ) {
					throw genfile::BadArgumentError(
						"PlotMSAApplication::unsafe_process()",
						"-distinguish",
						"ID \"" + id + "\" is not among the sequence IDs in the alignment."
					) ;
				}
				SequenceIdentifier tmp = sequence_ids[i] ;
				sequence_ids.erase( sequence_ids.begin() + i ) ;
				sequence_ids.insert( sequence_ids.begin(), tmp ) ;
			}
		}

		ui().logger() << "Loaded MSA with " << fasta->number_of_sequences() << " sequences.\n" ;
		std::vector< GFFRecord > genes ;
		if( options().check( "-genes" )) {
			genes = load_genes(
				options().get_value< std::string >( "-genes" ),
				sequence_ids[0].range()
			) ;
		}
		
		std::string const& output = options().get< std::string >( "-o" ) ;
		ui().logger() << "Writing output to \"" << output << "\"....\n" ;
		std::auto_ptr< std::ostream > ostr = genfile::open_text_file_for_output( output ) ;
		write_html( *ostr, *fasta, sequence_ids, genes ) ;
	}
	
	genfile::Fasta::UniquePtr load_fasta( std::vector< std::string > const& filenames ) const {
		genfile::Fasta::UniquePtr result = genfile::Fasta::create() ;
		for( auto& filename: filenames ) {
			auto progress_context = ui().get_progress_context( "Loading \"" + filename + "\"" ) ;
			result->add_sequences_from_file( filename, progress_context ) ;
		}
		return result ;
	}
	
	void check_sequence_lengths( genfile::Fasta const& fasta ) const {
		using genfile::string_utils::to_string ;
		std::size_t sequence_length = 0 ;
		std::vector< std::string > const& sequence_ids = fasta.sequence_ids() ;
		for( std::size_t i = 0; i < sequence_ids.size(); ++i ) {
			genfile::Fasta::PositionedSequenceRange p = fasta.get_sequence( sequence_ids[i] ) ;
			std::string sequence( p.second.first, p.second.second ) ; 
			if( i == 0 ) {
				sequence_length = sequence.size() ;
			} else {
				if( sequence_length != sequence.size() ) {
					throw genfile::BadArgumentError(
						"PlotMSAApplication::unsafe_process()",
						"-msa",
						"Sequences \"" + sequence_ids[0] + "\" and \"" + sequence_ids[i] + "\" have different lengths "
						"(" + to_string(sequence_length) + " vs. " + to_string(sequence.size()) + ")"
					) ;
				}
			}
		}
	}
	
	std::vector< SequenceIdentifier > parse_sequence_ids( genfile::Fasta const& fasta ) const {
		std::vector< SequenceIdentifier > result ;
		fasta.sequence_ids( [&result]( std::string const& id ) { result.push_back( SequenceIdentifier( id )) ; }) ;
		return result ;
	}
	
	std::vector< GFFRecord > load_genes(
		std::string const& filename,
		genfile::GenomePositionRange const& range
	) const {
		std::vector< GFFRecord > result ;
		auto input = genfile::open_text_file_for_input( filename ) ;
		parse_gff( *input, [&]( GFFRecord const& record ) {
			if(
				(record.sequence() == range.chromosome())
				&& (record.end() >= range.start().position())
				&& (record.start() <= range.end().position())
			) {
				result.push_back( record ) ;
			}
		}) ;
		return result ;
	}
	
	void write_html(
		std::ostream& out,
		genfile::Fasta const& fasta,
		std::vector< SequenceIdentifier > const& sequence_ids,
		std::vector< GFFRecord > const& genes
	) const {
		// This is a C++11 raw string literal
		std::string preamble = R""""(<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Multiple sequence aligmnet viewer</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.3.0/d3.min.js"></script>
	<script src="[URLBASE]/js/assert.js"></script>
	<script src="[URLBASE]/js/GeneView.js"></script>
	<script src="[URLBASE]/js/MSA.js"></script>
	<script src="[URLBASE]/js/MSAView.js"></script>
	<script src="[URLBASE]/js/MSAController.js"></script>
	<script src="[URLBASE]/js/run_msa_viewer.js"></script>
	<link href="[URLBASE]/css/msa_viewer.css" rel="stylesheet" >
</head>
<body>
	<section class="figure">
		<svg class = "names" width=900 height=600></svg>
		<svg class = "controls" width=900 height=200></svg>
		<canvas class = "sequences" width=900 height=600></canvas>
		<svg class = "genes" width=900 height=200></svg>
	</section>
</body>
<script>
	data = )"""" ;
		boost::algorithm::replace_all( preamble, "[URLBASE]", options().get< std::string >( "-url-base" )) ;
		out
			<< preamble
			<< "{\n"
			<< "  \"alignment\": "
			<< sequencesToJSON( fasta, sequence_ids )
			<< ",\n"
			<< "  \"ranges\": "
			<< rangesToJSON( sequence_ids )
			<< ",\n  \"genes\": "
			<< genesToJSON( genes )
			<< "\n"
			<< "};\n"
			<< "run_msa_viewer( data ) ;\n"
			<< "</script>\n"
			<< "</html>\n" ;
	}

	std::string sequencesToJSON(
		genfile::Fasta const& fasta,
		std::vector< SequenceIdentifier > const& sequence_ids
	) const {
		std::ostringstream s ;
		s << "[\n" ;
		std::size_t count = 0 ;
		std::deque< char > sequence ;
		for( auto& sequence_id: sequence_ids ) {
			genfile::Fasta::PositionedSequenceRange p = fasta.get_sequence( sequence_id.spec() ) ;
			s << (count>0 ? ",\n" : "" )
				<< "{ \"name\": \""
				<< sequence_id.id()
				<< "\", \"sequence\": \""
				<< std::string( p.second.first, p.second.second )
				<< "\" }" ;
			++count ;
		}
		s << "\n]" ;
		return s.str() ;
	}

	std::string genesToJSON( std::vector< GFFRecord > const& genes ) const {
		std::ostringstream s ;
		s << "[\n" ;
		for( std::size_t i = 0; i < genes.size(); ++i ) {
			GFFRecord const& gene = genes[i] ;
			s << ((i>0) ? ",\n" : "") ;
			s << "{ "
				<< "\"ID\": \"" << gene.ID() << "\", "
				<< "\"feature\": \"" << gene.feature() << "\", "
				<< "\"parent\": \"" << gene.parent() << "\", "
				<< "\"chromosome\": \"" << gene.sequence() << "\", "
				<< "\"start\": " << gene.start() << ", "
				<< "\"end\": " << gene.end() << ", "
				<< "\"strand\": \"" << gene.strand() << "\" }" ;
		}
		s << "\n]" ;
		return s.str() ;
	}

	std::string rangesToJSON( std::vector< SequenceIdentifier > const& sequence_ids ) const {
		std::ostringstream s ;
		s << "{\n" ;
		for( std::size_t i = 0; i < sequence_ids.size(); ++i ) {
			auto& sequence_id = sequence_ids[i] ;
			s
				<< ((i>0) ? ",\n" : "" )
				<< "\""
				<< sequence_id.id()
				<< "\": { "
				<< "\"chromosome\": \""
				<< sequence_id.range().chromosome()
				<< "\", \"start\": "
				<< sequence_id.range().start().position()
				<< ", \"end\": "
				<< sequence_id.range().end().position() + 1 // adjust to open-ended ranges.
				<< " }" ;
		}
		s << "\n}" ;
		return s.str() ;
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		PlotMSAApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
