
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/annotation/GFFRecord.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "find-vj-reads" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct FindVJReadsOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_values_until_next_option()
		;
		options[ "-V-genes" ]
			.set_description( "TSV file containing chromosome, start, end, and name of V gene segments."
			" Coordinate ranges should be 1-based, closed." )
			.set_takes_single_value()
		;
		options[ "-J-genes" ]
			.set_description( "TSV file containing chromosome, start, end, and name of J gene segments."
			" Coordinate ranges should be 1-based, closed." )
			.set_takes_single_value()
		;
		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description(
				"Range of positions to focus analysis on (in the form <chromosome>:<position>, or <chromosome>:<start>-<end>). "
				"Note " + globals::program_name + " uses 1-based coordinates with closed intervals." )
			.set_takes_values_until_next_option()
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 1000 )
		;

		options[ "-fasta" ]
			.set_description( "Specify reference sequence (mandatory when using CRAM files)" )
			.set_takes_single_value()
			.set_is_required() ;
	}
} ;

namespace impl {
	struct ReadReferenceAlignment {
		enum Orientation { eForward = 1, eReverse = -1 } ;
		ReadReferenceAlignment():
			start(0),
			end(0),
			orientation(eForward)
		{}

		ReadReferenceAlignment( seqlib::BamRecord const& alignment ):
			start( alignment.Position() ),
			end( alignment.PositionEnd() ),
			orientation( alignment.ReverseFlag() ? eReverse : eForward ),
			cigar( alignment.GetCigar() )
		{}

		uint32_t start ;
		uint32_t end ;
		Orientation orientation ;
		seqlib::Cigar cigar ;
	} ;

	struct SingleReadAlignments {
		std::string id ;
		std::string sequence ;
		std::vector< ReadReferenceAlignment > alignments ;
	} ;

}

struct FindVJReadsApplication: public appcontext::ApplicationContext
{
public:
	FindVJReadsApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new FindVJReadsOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	typedef genfile::annotation::GFFRecord GFFRecord ;
	genfile::Fasta m_fasta ;
	std::vector< GFFRecord > m_v_genes ;
	std::vector< GFFRecord > m_j_genes ;
	typedef std::map< std::string, impl::SingleReadAlignments > AlignmentsByReadId ;
	AlignmentsByReadId m_alignments ;

private:
	void unsafe_process() {

		//m_v_genes = load_genes( options().get< std::string >( "-V-genes" )) ;
		//m_j_genes = load_genes( options().get< std::string >( "-J-genes" )) ;
		auto analysis_range = genfile::GenomePositionRange::parse( options().get< std::string >( "-range" ) );
		load_alignments(
			options().get< std::string >( "-reads" ),
			options().get< std::string >( "-fasta" ),
			analysis_range,
			&m_alignments
		) ;

		{
			std::string const& fasta_filename = options().get< std::string >( "-fasta" ) ;
			auto progress_context = ui().get_progress_context( "Loading sequences from \"" + fasta_filename + "\"" ) ;
			m_fasta.add_sequences_from_file( fasta_filename, progress_context ) ;
		}
	}


private:
	std::vector< GFFRecord > load_genes( std::string const& filename ) const {
		auto progress = ui().get_progress_context( "Loading genes from \"" + filename + "\"" ) ;
		std::vector< GFFRecord > result ;
		auto input = genfile::open_text_file_for_input( filename ) ;
		genfile::annotation::parse_gff(
			*input,
			[&]( GFFRecord const& r ) {
				result.push_back(r) ;
				progress( result.size() ) ;
			}
		) ;
		return result ;
	}

	void load_alignments(
		std::string const read_filename,
		std::string const& fasta_filename,
		genfile::GenomePositionRange const& range,
		AlignmentsByReadId* result
	) const {
		assert( result != 0 ) ;


		seqlib::BamReader reader;
		reader.SetCramReference( fasta_filename ) ;
		if( !reader.Open( read_filename )) {
			throw genfile::BadArgumentError(
				"FindVJReadsApplication::load_alignments()",
				"read_filename=\"" + read_filename + "\"",
				"Unable to open file."
			) ;
		}
		seqlib::BamHeader const& header = reader.Header() ;
		{
			try {
				// note:  SeqLib is a bit weird on positions.
				// htslib uses 0-based, half-open positions throughout.  See e.g. the hts_parse_reg function which SeqLib uses here under the hood.
				// However, SeqLib changes this back into a 1-based, closed position internally.
				// The upshot is we pass in 1-based coords and that's how SeqLib treats them.
				// (But when we use this region below, the alignments come back 0-based).
				reader.SetRegion( seqlib::GenomicRegion( range.toString(), header )) ;
			} catch( std::invalid_argument const& e ) {
				throw genfile::BadArgumentError(
					"FindVJReadsApplication::load_alignments()",
					"region=\"" + range.toString() + "\"",
					"Failed for file \"" + read_filename + "\""
				) ;
			}
		}

		{
			auto progress = ui().get_progress_context( "Loading read alignments from \"" + read_filename + "\"" ) ;
			seqlib::BamRecord alignment ;
			std::size_t count = 0 ;
			while( reader.GetNextRecord( alignment ) ) {
				if(
					!alignment.SecondaryFlag()
					&& !alignment.DuplicateFlag()
					&& !alignment.QCFailFlag()
					&& alignment.MappedFlag()
				) {
					load_alignment( alignment, result ) ;
					progress( ++count ) ;
				}
			}
		}
	}

	void load_alignment(
		seqlib::BamRecord const& alignment,
		AlignmentsByReadId* alignments
	) const {
		std::string const id = alignment.Qname() ;
		AlignmentsByReadId::iterator where = alignments->find( id ) ;
		impl::SingleReadAlignments result ;
		if( where != alignments->end() ) {
			result = where->second ;
			assert( result.id == id ) ;
		} else {
			result.id = id ;
		}
		bool const primary = !alignment.SupplementaryFlag() ;
		if( primary ) {
			if( result.sequence.size() > 0 ) {
				throw genfile::BadArgumentError(
					"FindVJReadsApplication::load_alignment()",
					"read \"" + id + "\"",
					"Sequence already set, this read has more than one primary alignments!"
				) ;
			}
			result.sequence = alignment.Sequence() ;
		}
		result.alignments.insert(
			// put primary alignment first
			primary ? result.alignments.begin() : result.alignments.end(),
			impl::ReadReferenceAlignment( alignment )
		) ;
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		FindVJReadsApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
