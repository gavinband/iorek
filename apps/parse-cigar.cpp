//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include <boost/function.hpp>

#include "../package_revision_autogenerated.hpp"

#include "qcdb/Storage.hpp"

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"

namespace globals {
	std::string const program_name = "svelte" ;
	std::string const program_version = svelte_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct SvelteOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options.declare_group( "Model options" ) ;
		/*
		options[ "-train-regions" ]
			.set_description( "A regions (expressed in the form <chromosome>:<start>-<end>)"
				" to learn distributions from.  Regions are expressed in 1-based, right-closed coordinates."
				" (These regions should have few copy number variants)" 
				" Alternatively this can be the name of a file containing a list of regions."
			)
			.set_takes_single_value()
			.set_is_required()
		;
		options[ "-inference-regions" ]
			.set_description( "Set of regions (expressed in the form <chromosome>:<start>-<end>)"
				" to infer copy number variants in."
				"Regions are expressed in 1-based, right-closed coordinates."
				" Alternatively this can be the name of a file containing a list of regions."
			)
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		*/

		options[ "-reference" ]
			.set_description( "Specify reference sequence" )
			.set_takes_single_value() ;

		options[ "-mq" ]
			.set_description( "Mapping quality threshold" )
			.set_takes_single_value()
			.set_default_value( 0 ) ;
		
	}
} ;

struct SvelteApplication: public appcontext::ApplicationContext
{
public:
	SvelteApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new SvelteOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		unsafe_process() ;
	}

private:
	
	void unsafe_process() {
		std::vector< std::string > filenames = options().get_values< std::string >( "-reads" ) ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			process( filenames[i] ) ;
		}
	}
	
	void process( std::string const& filename ) {
		seqlib::BamReader reader;
		if( options().check( "-reference" )) {
			reader.SetCramReference( options().get< std::string >( "-reference" )) ;
		}
		if( !reader.Open( filename )) {
			assert( "Failed to open file" ) ;
		}
		seqlib::BamRecord alignment ;
		int const MQ = options().get< int >( "-mq" ) ;
		std::deque< seqlib::BamRecord > alignments ;
		AlignmentStats total ;

		qcdb::Storage::UniquePtr storage = qcdb::Storage::create(
			"-",
			globals::program_name,
			"",
			qcdb::Storage::Metadata()
		) ;
		storage->add_variable( "end_position" ) ;
		storage->add_variable( "query_length" ) ;
		storage->add_variable( "mapping_quality" ) ;
		storage->add_variable( "aligned_count" ) ;
		storage->add_variable( "aligned_bases" ) ;
		storage->add_variable( "matched_count" ) ;
		storage->add_variable( "matched_bases" ) ;
		storage->add_variable( "mismatched_count" ) ;
		storage->add_variable( "mismatched_bases" ) ;
		storage->add_variable( "mismatched_count" ) ;
		storage->add_variable( "mismatched_bases" ) ;
			
		while( reader.GetNextRecord( alignment ) ) {
			if( alignment.MapQuality() >= MQ ) {
				genfile::VariantIdentifyingData variant(
					alignment.Qname(),
					genfile::GenomePosition( alignment.ChrName(), alignment.Position() ),
					".", "."
				) ;
				storage->create_new_variant( variant ) ;

				storage->store_per_variant_data(
					variant,
					"end_position",
					alignment.PositionEnd()
				) ;
				storage->store_per_variant_data(
					variant,
					"query_length",
					alignment.Length()
				) ;
				storage->store_per_variant_data(
					variant,
					"mapping_quality",
					alignment.MapQuality()
				) ;
				AlignmentStats stats( alignment ) ;
				stats.output_results(
					[&storage,&variant]( std::string const& name, uint32_t const value ) {
						storage->store_per_variant_data(
							variant,
							name,
							genfile::VariantEntry::Integer( value )
						) ;
					}
				) ;
				total.add( alignment ) ;
			}
		}		
		std::cout << "TOTAL" << ": " << total.toJSON() << "\n" ;
	}


	struct AlignmentStats {
	public:

		/*
		* from htslib sam.h:
		*
		* BAM_CIGAR_TYPE  QUERY  REFERENCE
		* --------------------------------
		* BAM_CMATCH      1      1
		* BAM_CINS        1      0
		* BAM_CDEL        0      1
		* BAM_CREF_SKIP   0      1
		* BAM_CSOFT_CLIP  1      0
		* BAM_CHARD_CLIP  0      0
		* BAM_CPAD        0      0
		* BAM_CEQUAL      1      1
		* BAM_CDIFF       1      1
		* BAM_CBACK       0      0
		* --------------------------------
		*/
		enum Types {
			eAligned = 0,
			eInsertion = 1,
			eDeletion = 2,
			eRefSkip = 3,
			eSoftClip = 4,
			eHardClip = 5,
			ePad = 6,
			eMatch = 7,
			eMismatch = 8,
			// back is ignored, and we additionally report edit distance
			eEditDistance = 9
		} ;
		
	public:
		AlignmentStats():
			m_opCounts( 10, 0u ),
			m_opBaseTotals( 10, 0u )
		{}

		AlignmentStats( seqlib::BamRecord const& alignment ):
			m_opCounts( 10, 0u ),
			m_opBaseTotals( 10, 0u )
		{
			this->add( alignment ) ;
		}

		AlignmentStats( AlignmentStats const& other ):
			m_opCounts( other.m_opCounts ),
			m_opBaseTotals( other.m_opBaseTotals )
		{}

		AlignmentStats& operator=( AlignmentStats const& other ) {
			m_opCounts = other.m_opCounts ;
			m_opBaseTotals = other.m_opBaseTotals ;
			return *this ;
		}

		void add( seqlib::BamRecord const& alignment ) {
			typedef seqlib::Cigar Cigar ;
			typedef seqlib::CigarField CigarField ;
			Cigar cigar = alignment.GetCigar() ;
			Cigar::const_iterator i = cigar.begin() ;
			Cigar::const_iterator const end_i = cigar.end() ;
			for( ; i != end_i; ++i ) {
				m_opCounts[ i->RawType() ] += 1 ;
				m_opBaseTotals[ i->RawType() ] += i->Length() ;
			}
			std::string MD_string ;
			if( alignment.GetTag( "MD", MD_string ) ) {
				std::vector< MDElt > const MD = parse_MD( MD_string ) ;
				uint32_t matches = 0 ;
				uint32_t mismatches = 0 ;
				uint32_t deletions = 0 ;
				for( std::size_t i = 0; i < MD.size(); ++i ) {
					if( MD[i].type() == MDElt::eMatch ) {
						matches += MD[i].size() ;
						m_opCounts[ eMatch ] += 1 ;
						m_opBaseTotals[ eMatch ] += MD[i].size() ;
					} else if( MD[i].type() == MDElt::eMismatch ) {
						mismatches += MD[i].size() ;
						m_opCounts[ eMismatch ] += 1 ;
						m_opBaseTotals[ eMismatch ] += MD[i].size() ;
					} else if( MD[i].type() == MDElt::eDeletion ) {
						deletions += MD[i].size() ;
					}
				}
				uint32_t edit_distance = m_opBaseTotals[ eMismatch ] + m_opBaseTotals[ eInsertion ] + m_opBaseTotals[ eDeletion ] ;
				m_opCounts[ eEditDistance ] = edit_distance ;
			}
		}
		
		typedef boost::function< void ( std::string const& value_name, uint32_t const value ) > ResultCallback ;

		void output_results( ResultCallback callback ) const {
			std::vector< std::string > opNames{
				"aligned", "inserted", "deleted",
				"skipped",
				"soft_clipped", "hard_clipped",
				"padded",
				"matched",
				"mismatched",
				"edit_distance"
			} ;
			for( std::size_t type = 0; type < 9; ++type ) {
				callback( opNames[type] + "_count", m_opCounts[type] ) ;
				callback( opNames[type] + "_bases", m_opBaseTotals[type] ) ;
			}
			callback( "edit_distance", m_opCounts[ eEditDistance ] ) ;
		}
		
		std::string toJSON() const {
			std::ostringstream ostr ;
			ostr << "{ " ;
			int count = 0 ;
			output_results(
				[&ostr,&count]( std::string const& name, uint32_t const value ) {
					ostr
						<< ((count++ > 0) ? ", " :  "" )
						<< "\"" << name << "\""
						<< ": " << value ;
				}
			) ;
			return ostr.str() ;
		}

	private:
		std::vector< uint32_t > m_opCounts ;
		std::vector< uint32_t > m_opBaseTotals ;
		
		struct MDElt {
		public:
			enum Type { eMatch = '=', eMismatch = 'x', eDeletion = '^' } ;
		public:
			MDElt(
				uint32_t position,
				Type type,
				std::string const& reference_bases
			):
				m_position( position ),
				m_type( type ),
				m_reference_bases( reference_bases )
			{}

			MDElt( MDElt const& other ):
				m_position( other.m_position ),
				m_type( other.m_type ),
				m_reference_bases( other.m_reference_bases )
			{}

			MDElt operator=( MDElt const& other ) {
				m_position = other.m_position ;
				m_type = other.m_type ;
				m_reference_bases = other.m_reference_bases ;
				return *this ;
			}
			
			Type const type() const { return m_type ; }
			uint32_t const size() const { return m_reference_bases.size() ; }
			uint32_t const position() const { return m_position ; }
			std::string const& reference_bases() const { return m_reference_bases ; }
			
		private:
			uint32_t m_position ;
			Type m_type ;
			std::string m_reference_bases ;
		} ;
	
		std::vector< MDElt > parse_MD( std::string const& MD ) {
			// return a list of MDElts
			// These are either matches (strings of '='),
			// changes (nucleotides)
			// or deletions( string of nucleotides).
			// Each comes with a position which is the 
			// position in the aligned portion of the read,
			// identified as 'M' in the cigar string.
			//
			// Note: insertions do not appear in the MD tag
			// as they are not in the aligned portion.
			// Deletions do appear in the MD tag and the base is represented.
#if DEBUG > 1
			std::cerr << "PARSING: \"" << MD << "\".\n" ;
#endif
			std::vector< MDElt > result ;
			uint32_t position = 0 ;
			std::size_t last_pos = 0 ;
			std::size_t pos = 0 ;

			while(1) {
				// Try to find some number of matching bases
				pos = MD.find_first_not_of( "0123456789", last_pos ) ;
				if( pos > 0 ) {
					uint32_t match_length = std::stoi( MD.substr( last_pos, pos - last_pos )) ;
					result.push_back( MDElt( position, MDElt::eMatch, std::string( match_length, '=' ))) ;
					position += match_length ;
				}

				if( pos == std::string::npos ) {
					break ;
				}

				// Try to find a mismatch or deletion
				last_pos = pos ;
				pos = MD.find_first_not_of( "^ACGT", last_pos ) ;
				pos = ( pos == std::string::npos ) ? MD.size() : pos ;
				std::string const bases = MD.substr( last_pos, pos - last_pos ) ;
				assert( bases.size() > 0 ) ;
				if( bases[0] == '^' ) {
					// Deletion relative to reference.
					// Record the ref bases but no change in position in alignment
					result.push_back( MDElt( position, MDElt::eDeletion, bases.substr( 1, bases.size() ) )) ;
#if DEBUG > 1
					std::cerr << "FOUND Deletion of length " << bases.size()-1 << ".\n" ;
#endif
				} else {
					// Substitution.  Record the ref bases and update position
					result.push_back( MDElt( position, MDElt::eMismatch, bases )) ;
					position += bases.size() ;
#if DEBUG > 1
					std::cerr << "FOUND change of length " << bases.size() << ".\n" ;
#endif
				}
				last_pos = pos ;
			}
			return result ;
		}
	} ;
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		SvelteApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
