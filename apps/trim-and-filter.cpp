
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <unordered_map>
//#include <unordered_set>
//#include <set>
#include <memory>
#include <mutex>
#include <algorithm>
//#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <boost/timer.hpp>
//#include <boost/lockfree/queue.hpp>
#include <chrono>
#include <thread>

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/FileUtils.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/kmer/KmerHashIterator.hpp"
#include "statfile/BuiltInTypeStatSource.hpp"

#include "concurrentqueue/concurrentqueue.h"

/*
#include <sys/types.h>
#include <sys/sysinfo.h>
*/

#define DEBUG 0

namespace globals {
	std::string const program_name = "trim-and-filter" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct ClassifyKmersOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of fastq file of reads to load." )
			.set_takes_single_value()
			.set_is_required()
		;

		options[ "-read-tags" ]
			.set_description( "Path of a text file with two (named) columns.  The first column is the "
			" read id, the second is a string value to associate to the read.  Results will be split over the different tag values." )
			.set_takes_single_value()
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Template name of output file. Must contain '[tag'] which will be filled with the read tag." )
			.set_takes_single_value()
			.set_is_required()
		;

		options[ "-ot" ]
			.set_description( "Name of trimmed-read output file. Should contain '[tag'] which will be filled with the read tag, "
			"and '[side]' which will be filled with 'start' or 'end'." )
			.set_takes_single_value()
		;


		options.declare_group( "Algorithm options" ) ;
		options[ "-trim-start" ]
			.set_description( "Length to trim off start of read" )
			.set_takes_single_value()
			.set_default_value( 0 )
		;

		options[ "-trim-end" ]
			.set_description( "Length to trim off end of read" )
			.set_takes_single_value()
			.set_default_value( 0 )
		;

		options.option_implies_option( "-ot", "-trim-start" ) ;
		options.option_implies_option( "-ot", "-trim-end" ) ;
	}
} ;

namespace {
	typedef moodycamel::ConcurrentQueue< uint64_t > Queue ;


	struct Read {
		Read() {}

		Read( Read const& other ):
			id( other.id ),
			sequence( other.sequence ),
			qualities( other.qualities )
		{}

		Read& operator=( Read const& other ) {
			id = other.id ;
			sequence = other.sequence ;
			qualities = other.qualities ;
			return *this ;
		}

		std::size_t length() const { return sequence.size() ; }

		std::string id ;
		std::string sequence ;
		std::string qualities ;
	} ;

	typedef moodycamel::ConcurrentQueue< Read > ReadQueue ;
}
 
struct FilterAndTrimApplication: public appcontext::ApplicationContext
{
public:
	FilterAndTrimApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new ClassifyKmersOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	typedef std::unordered_map< std::string, std::string > ReadTags ;
	ReadTags m_read_tags ;
	std::vector< std::string > m_tags ;

	typedef std::unique_ptr< std::ostream > SinkPtr ;
	typedef std::map< std::string, SinkPtr > Sinks ;
	Sinks m_sinks ;

private:
	void unsafe_process() {
		load_read_tags(
			options().get< std::string >( "-read-tags" ),
			&m_read_tags,
			&m_tags
		) ;

		{
			ui().logger() << "++ Inspecting reads from \"" << options().get< std::string >( "-reads" ) << "\"...\n" ;
			boost::timer timer ;
			double start_time = timer.elapsed() ;

			using genfile::string_utils::replace_all ;

			// Construct sinks in reverse order.  If outputting to stdout, this makes them output
			// in the right order.
			{
				std::string const output_template = options().get< std::string >( "-o" ) ;

				if( replace_all( output_template, "[tag]", "" ).size() == output_template.size() ) {
					throw genfile::BadArgumentError(
						"FilterAndTrimApplication::unsafe_process()",
						"-o \"" + output_template + "\"",
						"Output filename template should contain '[tag]', which will be replaced with the read tag."
					) ;
				}

				bool const output_trimmed =  options().check( "-ot" ) ;
				std::string const trimmed_template = output_trimmed ? options().get< std::string >( "-ot" ) : "" ;
				if( output_trimmed ) {
					if(
						(replace_all( trimmed_template, "[tag]", "" ).size() == trimmed_template.size())
						||
						(replace_all( trimmed_template, "[side]", "" ).size() == trimmed_template.size())
					) {
						throw genfile::BadArgumentError(
							"FilterAndTrimApplication::unsafe_process()",
							"-o \"" + trimmed_template + "\"",
							"Output filename template should contain '[tag]' and '[side]', which will be replaced with the read tag and read side."
						) ;
					}
				}
				for( auto tag: m_tags ) {
					m_sinks.insert(
						std::make_pair(
							tag,
							SinkPtr(
								genfile::open_text_file_for_output(
									replace_all( output_template, "[tag]", tag )
								)
							)
						)
					) ;
					if( output_trimmed ) {
						m_sinks.insert(
							std::make_pair(
								tag + "-trimmed-start",
								SinkPtr(
									genfile::open_text_file_for_output(
										replace_all(
											replace_all( trimmed_template, "[tag]", tag ),
											"[side]",
											"start"
										)
									)
								)
							)
						) ;

						m_sinks.insert(
							std::make_pair(
								tag + "-trimmed-end",
								SinkPtr(
									genfile::open_text_file_for_output(
										replace_all(
											replace_all( trimmed_template, "[tag]", tag ),
											"[side]",
											"end"
										)
									)
								)
							)
						) ;
					}
				}
			}

			std::auto_ptr< std::istream >
				fastq = genfile::open_text_file_for_input( options().get< std::string >( "-reads" ) ) ;
		
			std::size_t number_of_reads = process_reads(
				*fastq
			) ;
			double end_time = timer.elapsed() ;
			ui().logger() << "++ Ok, processed " << number_of_reads << " reads in " << (end_time - start_time) << " seconds.\n" ;
		}
	}

	void load_read_tags(
		std::string const& filename,
		ReadTags* read_tags,
		std::vector< std::string >* distinct_tags
	 ) const {
		auto source = statfile::BuiltInTypeStatSource::open( filename ) ;
		std::string read_id, read_tag ;
		std::size_t count = 0 ;
		std::set< std::string > sorted_tags ;
		while( (*source) >> read_id >> read_tag ) {
			auto where = read_tags->find( read_id ) ;
			if( where != read_tags->end() ) {
				if( read_tag != where->second ) {
					throw genfile::BadArgumentError(
						"FilterAndTrimApplication::load_read_tags()",
						"filename=\"" + filename + "\"",
						(
							"Read id \""
							+ read_id
							+ "\" appears at least twice with differenct tags."
						)
					) ;
				}
			} else {
				if( !read_tags->insert( std::make_pair( read_id, read_tag )).second ) {
					throw genfile::BadArgumentError(
						"FilterAndTrimApplication::load_read_tags()",
						"filename=\"" + filename + "\"",
						(
							"Could not insert read id \""
							+ read_id
							+ "\", for unknown reasons."
						)
					) ;
				}
				sorted_tags.insert( read_tag ) ;
				//std::cerr << "++ Inserted: " << read_id << ": " << read_tag << ".\n" ;
			}
				
			(*source) >> statfile::ignore_all() ;
			++count ;
		}
		distinct_tags->assign( sorted_tags.begin(), sorted_tags.end() ) ;
	}

	std::size_t process_reads(
		std::istream& input
	) {
		auto progress = ui().get_progress_context( "Filtering reads" ) ;
		std::size_t count = 0 ;

		ReadQueue read_queue( 4096 ) ;
		std::atomic< int > quit(0) ;

		std::thread output_thread(
			&FilterAndTrimApplication::process_read,
			this,
			&read_queue,
			options().get< std::size_t >( "-trim-start" ),
			options().get< std::size_t >( "-trim-end" ),
			options().check( "-ot" ),
			&quit
		) ;

		{
			Read read ;
			std::string line ;
			std::size_t l = 0 ;
			while( std::getline( input, line )) {
				switch(l) {
					case 0:
						read.id = line.substr(1,line.size() ) ;
						break ;
					case 1:
						read.sequence = line ;
						break ;
					case 2:
						break ;
					case 3:
						read.qualities = line ;
						break ;
				} ;

				if( (++l) == 4 ) {
					while( !read_queue.try_enqueue( read )) {
#if DEBUG > 1
						std::cerr << "-- queue full after " << count << " reads, sleeping...\n" ;
#endif
						std::this_thread::sleep_for( std::chrono::microseconds(10) ) ;
					}
					
#if DEBUG
					std::cerr << "queued: " << read.id << ".\n" ;
#endif
					++count ;
					progress( count ) ;
					l = 0 ;
				}
			}

			ui().logger() << "++ Done, read " << count << " reads in total.\n" ;

			ui().logger() << "++ Waiting to finish...\n" ;
			while( (read_queue.size_approx() > 0) ) {
				std::this_thread::sleep_for( std::chrono::milliseconds(10)) ;
			}
			std::this_thread::sleep_for( std::chrono::milliseconds(100)) ;
			quit = 1 ;
			std::this_thread::sleep_for( std::chrono::milliseconds(100)) ;
			output_thread.join() ;
		}

		return count ;
	}
	
	void process_read(
		ReadQueue* read_queue,
		std::size_t const trim_start,
		std::size_t const trim_end,
		bool const output_trimmed,
		std::atomic< int >* quit
	) {
		Read read ;
		while( !(*quit) ) {
			bool popped = read_queue->try_dequeue( read ) ;
			if( popped ) {
				analyse_read( read, trim_start, trim_end, output_trimmed ) ;
			} else {
				// nothing to pop, sleep to allow queue to fill.
				std::this_thread::sleep_for( std::chrono::microseconds(10) ) ;
			}
		}
	}

	void analyse_read(
		Read const& read,
		std::size_t const trim_start,
		std::size_t const trim_end,
		bool output_trimmed
	) {
		std::string const tag = get_read_tag( read.id ) ;
		//std::cerr << "++ read.id = " << read.id << ", tag = [" << tag << "].\n" ;
		std::ostream* sink = get_sink( tag ) ;
		std::size_t const L = read.sequence.size() ;
		if( output_trimmed ) {
			std::ostream* l_sink = get_sink( tag + "-trimmed-start" ) ;
			std::ostream* r_sink = get_sink( tag + "-trimmed-end" ) ;
			{
				(*l_sink)
					<< "@" << read.id << "\n"
					<< read.sequence.substr(0,trim_start)
					<< "\n+\n"
					<< read.qualities.substr(0,trim_start)
					<< "\n" ;
			}
			if( L >= (trim_start+trim_end) ) {
				(*r_sink)
					<< "@" << read.id << "\n"
					<< read.sequence.substr( L-trim_end, trim_end )
					<< "\n+\n"
					<< read.qualities.substr( L-trim_end, trim_end )
					<< "\n" ;
			}
		}

		if( read.sequence.size() > (trim_start+trim_end) ) {
			(*sink)
				<< "@" << read.id << "\n"
				<< read.sequence.substr( trim_start, L - (trim_start+trim_end) )
				<< "\n+\n"
				<< read.qualities.substr( trim_start, L - (trim_start+trim_end) )
				<< "\n" ;
		}
	}

	std::string get_read_tag( std::string const& read_id ) const {
		std::string result = "NA" ;
		ReadTags::const_iterator where
			= m_read_tags.find( read_id ) ;
		if( where != m_read_tags.end() ) {
			result = where->second ;
		}
		return result ;
	}

	std::ostream* get_sink( std::string const& tag ) {
		Sinks::iterator where = m_sinks.find( tag ) ;
		if( where == m_sinks.end() ) {
			std::cerr << "!! Unable to find sink for read tag [" + tag + "].\n" ;
		}
		assert( where != m_sinks.end() ) ;
		return (where->second.get()) ;
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		FilterAndTrimApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
