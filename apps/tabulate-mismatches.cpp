
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <unordered_map>
#include <unordered_set>
#include <set>
#include <algorithm>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/icl/interval_map.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "appcontext/get_current_time_as_string.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/FastaMask.hpp"
#include "genfile/find_homopolymers_and_short_repeats.hpp"
#include "genfile/repeats/repeat_tracts.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "tabulate-mismatches" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct IorekOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description( "Genomic regions (expressed in the form <chromosome>:<start>-<end>)"
				" to process.  Regions are expressed in 1-based, right-closed coordinates."
				" (These regions should have few copy number variants)" 
				" Alternatively this can be the name of a file containing a list of regions."
			)
			.set_takes_single_value()
		;
		options[ "-include-mask" ]
			.set_description( "Specify a BED file of regions to include in the analysis."
			" If specified, only alignment locations within the given regions are analysed."
			" The file should have no column names and should have contig, start and end columns, "
			" expressed in 0-based right-closed form." )
			.set_takes_single_value()
		;
		options[ "-exclude-mask" ]
			.set_description( "Specify a BED file of regions to mask out of the analysis."
			" If specified, alignment locations within the given regions are omitted from the analysis."
			" The file should have no column names and should have contig, start and end columns, "
			" expressed in 0-based right-closed form." )
			.set_takes_single_value()
		;
		options[ "-fasta" ]
			.set_description( "Specify reference sequence" )
			.set_takes_single_value()
			.set_is_required() ;

		options.declare_group( "Model options" ) ;
		options[ "-mq" ]
			.set_description( "Ignore alignments below this mapping quality threshold" )
			.set_takes_single_value()
			.set_default_value( 0 ) ;

		options[ "-by-position" ]
			.set_description( "Specify that errors should be tabulated by position, not aggregated." ) ;

		options[ "-flank" ]
			.set_description( "Specify how much flanking sequence to classify by." )
			.set_takes_single_value()
			.set_default_value( 3 ) ;

		options.declare_group( "Miscellaneous options" ) ;
		options[ "-threads" ]
			.set_description( "Use this many extra threads for file reading" )
			.set_takes_single_value()
			.set_hidden()
			.set_default_value( 0 ) ;

	}
} ;

namespace {
	enum MismatchType {
		eMatch = '=',
		eMismatch = 'X',
		eDeletion = 'D',
		eInsertion = 'I'
	} ;

	// We use boost::icl::interval_map to store annotation file entries. This
	// efficiently handles a map from positions to annotations, internally
	// represented as intervvals

	// BED file entries might overlap, and so for each position we keep a set of
	// all annotations at that point.	(For short repeats, basically each
	// base could be in 0, 1, or 2 repeats, but for other BED files I guess there
	// might be more.)  A std::set works fine for this, as in the example:
	// www.boost.org/doc/libs/1_68_0/libs/icl/doc/html/boost_icl/examples/partys_height_average.html
	
	struct RepeatTract
	{
		RepeatTract(
			std::string const& name,
			genfile::Chromosome const& contig,
			genfile::Position start, // 0-based
			genfile::Position end    // 0-based, half-closed
		):
			m_repeat_unit( name ),
			m_contig( contig ),
			m_start( start ),
			m_end( end )
		{
			assert( m_start <= m_end ) ;
		}

		RepeatTract( RepeatTract const& other ):
			m_repeat_unit( other.m_repeat_unit ),
			m_contig( other.m_contig ),
			m_start( other.m_start ),
			m_end( other.m_end )
		{}
		
		RepeatTract& operator=( RepeatTract const& other ) {
			m_repeat_unit = other.m_repeat_unit ;
			m_contig = other.m_contig ;
			m_start = other.m_start ;
			m_end = other.m_end ;
			return *this ;
		}

		bool operator==( RepeatTract const& right ) const {
			RepeatTract const& left = *this ;
			return (left.m_repeat_unit == right.m_repeat_unit)
				&& (left.m_contig == right.m_contig)
				&& (left.m_start == right.m_start)
				&& (left.m_end == right.m_end) ;
		}

		bool operator<( RepeatTract const& right ) const {
			RepeatTract const& left = *this ;
			// This ordering is to ensure that when we choose two
			// elements for output below, we choose the longest ones.

			// order by genomic length (largest first)...
			if( left.length() > right.length() ) {
				return true ;
			} else if( left.length() < right.length() ) {
				return false ;
			}
			// ...then by the length of the annotation string, smallest first...
			if( left.m_repeat_unit.size() < right.m_repeat_unit.size() ) {
				return true ;
			} else if( left.m_repeat_unit.size() > right.m_repeat_unit.size() ) {
				return false ;
			}
			// ...then by the annotation string itself.
			if( left.m_repeat_unit < right.m_repeat_unit ) {
				return true ;
			} else if( left.m_repeat_unit > right.m_repeat_unit ) {
				return false ;
			}
			// ...then by the position
			if( left.m_contig < right.m_contig ) {
				return true ;
			} else if( left.m_contig > right.m_contig ) {
				return false ;
			}
			if( left.m_start < right.m_start ) {
				return true ;
			} else if( left.m_start > right.m_start ) {
				return false ;
			}
			if( left.m_end < right.m_end ) {
				return true ;
			} else if( left.m_end > right.m_end ) {
				return false ;
			}
			return false ;
		}

		std::string const& repeat_unit() const { return m_repeat_unit ; }
		// 0-based coords
		genfile::Chromosome contig() const { return m_contig ; }
		genfile::Position start() const { return m_start ; }
		genfile::Position end() const { return m_end ; }
		uint32_t length() const { return m_end - m_start ; }
		
	private:
		std::string m_repeat_unit ;
		genfile::Chromosome m_contig ;
		genfile::Position m_start ;
		genfile::Position m_end ;
	} ;
	
	// 
	struct RepeatTractClass
	{
		RepeatTractClass(
			std::string const& repeat_unit,
			std::size_t length
		):
			m_repeat_unit( repeat_unit ),
			m_length( length )
		{}

		RepeatTractClass( RepeatTract const& other ):
			m_repeat_unit( other.repeat_unit() ),
			m_length( other.length() )
		{}

		RepeatTractClass( RepeatTractClass const& other ):
			m_repeat_unit( other.m_repeat_unit ),
			m_length( other.m_length )
		{}
		
		RepeatTractClass& operator=( RepeatTractClass const& other ) {
			m_repeat_unit = other.m_repeat_unit ;
			m_length = other.m_length ;
			return *this ;
		}

		bool operator==( RepeatTractClass const& right ) const {
			RepeatTractClass const& left = *this ;
			return (left.m_repeat_unit == right.m_repeat_unit)
				&& (left.m_length == right.m_length) ;
		}

		bool operator<( RepeatTractClass const& right ) const {
			RepeatTractClass const& left = *this ;
			// order by RepeatTract length
			if( left.m_length > right.m_length ) {
				return true ;
			} else if( left.m_length < right.m_length ) {
				return false ;
			}
			// ...then by the length of the annotation string, smallest first...
			if( left.m_repeat_unit.size() < right.m_repeat_unit.size() ) {
				return true ;
			} else if( left.m_repeat_unit.size() > right.m_repeat_unit.size() ) {
				return false ;
			}
			// ...then by the annotation string itself.
			if( left.m_repeat_unit < right.m_repeat_unit ) {
				return true ;
			} else if( left.m_repeat_unit > right.m_repeat_unit ) {
				return false ;
			}
			return false ;
		}

		std::string const& repeat_unit() const { return m_repeat_unit ; }
		// 0-based coords
		uint32_t length() const { return m_length ; }
		
	private:
		std::string m_repeat_unit ;
		std::size_t m_length ;
	} ;

	struct MismatchClass
	{
		MismatchClass(
			std::string const& contig_id,
			uint32_t position,
			MismatchType const& type,
			std::string const& contig_sequence,
			std::string const& read_sequence,
			std::string const& left_flank,
			std::string const& right_flank,
			uint32_t const contig_bases_unmasked,
			uint32_t const edit_bases_unmasked
		):
			m_contig_id( contig_id ),
			m_position( position ),
			m_type( type ),
			m_contig_sequence( contig_sequence ),
			m_read_sequence( read_sequence ),
			m_left_flank( left_flank ),
			m_right_flank( right_flank ),
			m_contig_bases_unmasked( contig_bases_unmasked ),
			m_edit_bases_unmasked( edit_bases_unmasked )
		{}

		MismatchClass(
			MismatchClass const& other
		):
			m_contig_id( other.m_contig_id ),
			m_position( other.m_position ),
			m_type( other.m_type ),
			m_contig_sequence( other.m_contig_sequence ),
			m_read_sequence( other.m_read_sequence ),
			m_left_flank( other.m_left_flank ),
			m_right_flank( other.m_right_flank ),
			m_contig_bases_unmasked( other.m_contig_bases_unmasked ),
			m_edit_bases_unmasked( other.m_edit_bases_unmasked )
		{}

		MismatchClass& operator=(
				MismatchClass const& other
		) {
			m_contig_id = other.m_contig_id ;
			m_position = other.m_position ;
			m_type = other.m_type ;
			m_contig_sequence = other.m_contig_sequence ;
			m_read_sequence = other.m_read_sequence ;
			m_left_flank = other.m_left_flank ;
			m_right_flank = other.m_right_flank ;
			m_contig_bases_unmasked = other.m_contig_bases_unmasked ;
			m_edit_bases_unmasked = other.m_edit_bases_unmasked ;
			return *this ;
		}

		std::string const& contig_id() const { return m_contig_id ; }
		uint32_t position() const { return m_position ; }
		MismatchType const type() const { return m_type ; }
		std::string const& contig_sequence() const { return m_contig_sequence ; }
		std::string const& read_sequence() const { return m_read_sequence ; }
		std::string const& left_flank() const { return m_left_flank ; }
		std::string const& right_flank() const { return m_right_flank ; }
		uint32_t const contig_bases_unmasked() const { return m_contig_bases_unmasked ; }
		uint32_t const edit_bases_unmasked() const { return m_edit_bases_unmasked ; }
		
		friend bool operator<( MismatchClass const& left, MismatchClass const& right ) ;
		friend bool operator==( MismatchClass const& left, MismatchClass const& right ) ;
		friend std::ostream& operator<<( std::ostream& out, MismatchClass const& m ) ;
	private:
		std::string m_contig_id ;
		uint32_t m_position ;
		MismatchType m_type ;
		std::string m_contig_sequence ;
		std::string m_read_sequence ;
		std::string m_left_flank ;
		std::string m_right_flank ;
		uint32_t m_contig_bases_unmasked ;
		uint32_t m_edit_bases_unmasked ;
	} ;
	
	bool operator<( MismatchClass const& left, MismatchClass const& right ) {
		if( left.m_contig_id < right.m_contig_id ) {
			return true ;
		} else if( left.m_contig_id > right.m_contig_id ) {
			return false ;
		}
		if( left.m_position < right.m_position ) {
			return true ;
		} else if( left.m_position > right.m_position ) {
			return false ;
		}
		if( left.m_type < right.m_type ) {
			return true ;
		} else if( left.m_type > right.m_type ) {
			return false ;
		}
		if( left.m_contig_sequence < right.m_contig_sequence ) {
			return true ;
		} else if( left.m_contig_sequence > right.m_contig_sequence ) {
			return false ;
		}
		if( left.m_read_sequence < right.m_read_sequence ) {
			return true ;
		} else if( left.m_read_sequence > right.m_read_sequence ) {
			return false ;
		}
		if( left.m_left_flank < right.m_left_flank ) {
			return true ;
		} else if( left.m_left_flank > right.m_left_flank ) {
			return false ;
		}
		if( left.m_right_flank < right.m_right_flank ) {
			return true ;
		} else if( left.m_right_flank > right.m_right_flank ) {
			return false ;
		}
		if( left.m_contig_bases_unmasked < right.m_contig_bases_unmasked ) {
			return true ;
		} else if( left.m_contig_bases_unmasked > right.m_contig_bases_unmasked ) {
			return false ;
		}
		if( left.m_edit_bases_unmasked < right.m_edit_bases_unmasked ) {
			return true ;
		} else if( left.m_edit_bases_unmasked > right.m_edit_bases_unmasked ) {
			return false ;
		}
		return false ;
	}

	bool operator==( MismatchClass const& left, MismatchClass const& right ) {
		return
			( left.m_contig_id == right.m_contig_id )
			&& ( left.m_position == right.m_position )
			&& ( left.m_type == right.m_type )
			&&( left.m_contig_sequence == right.m_contig_sequence )
			&&( left.m_read_sequence == right.m_read_sequence )
			&&( left.m_left_flank == right.m_left_flank )
			&&( left.m_right_flank == right.m_right_flank )
			&&( left.m_contig_bases_unmasked == right.m_contig_bases_unmasked )
			&&( left.m_edit_bases_unmasked == right.m_edit_bases_unmasked )
		;
	}

	std::ostream& operator<<( std::ostream& out, MismatchClass const& m ) {
		out << m.m_contig_id << ":" << m.m_position << ": " << char( m.m_type ) << " "
			<< m.m_left_flank << "[" << m.m_contig_sequence << ">" << m.m_read_sequence << "]" << m.m_right_flank ;
		return out ;
	}

	void classify_alignment_mismatches(
		seqlib::BamRecord const& alignment,
		seqlib::BamHeader const& header,
		genfile::Fasta const& fasta,
		std::function<
			void(
				MismatchType const& type,
				std::string const& contig_id,
				genfile::Fasta::ConstSequenceRange const& contig,
				std::size_t begin_in_contig,
				std::size_t end_in_contig,
				std::string const& read,
				std::size_t begin_in_read,
				std::size_t end_in_read
			)
		> callback,
		uint32_t const flank = 3
	) {
		// Note: this function classifies read-reference mismatches by parsing the
		// CIGAR string and comparing to the reference bases.
		
		// The CIGAR string alone does not contain enough information to reconstruct
		// the mismatching bases.	Thus it is necessary to inspect the reference
		// sequence at the same time.
	
		// Although CIGAR supports 'X' (mismatch) and '=' (identical match), many
		// aligners (such as bwa or minimap2) just output 'M' for mismatches by
		// default.	(Minimap2 does outputs X/= when given the -eqx flag; pbmm2 also
		// seems to do this by default.)

		// Aligners may also output additional information complementing the CIGAR
		// string in the 'MD' tag, and minimap2 can also output a CS tag containing
		// full information about the mismatches.	Use of these would avoid need to
		// parse the reference sequence, but they're not found in every BAM file.
	
		// On balance it therefore seems simplest to work with the CIGAR string and
		// the reference, and to treat 'M', 'X', and '=' as
		// synonymous - which is what we do here.
		
		seqlib::Cigar const& cigar = alignment.GetCigar() ;

		std::string const& read_sequence = alignment.Sequence() ;
		std::string const contig_id = header.IDtoName( alignment.ChrID() ) ;
		genfile::Fasta::ContigRange const contig = fasta.get_sequence( contig_id ) ;

		//bool const count_matches = options().check( "-count-matches" ) ;

		uint32_t read_position = 0;
		uint32_t aligned_position = alignment.Position() ; // 0-based
#if DEBUG
		std::cerr << "\n++ Inspecting read: " << alignment.Qname() << ", CIGAR = \"" << cigar << "\".\n" ;
#endif

		seqlib::Cigar::const_iterator i = cigar.begin(), end_i = cigar.end() ;
		for( ; i != end_i; ++i ) {
			char const type = i->Type() ;
#if DEBUG
			std::cerr << "  : read position = " << read_position << "; alignment pos = " << aligned_position << "; cigar elt = \"" << *i << "\".\n" ;
#endif
			// The cigar ops are:
			// M    Alignment match (can be a sequence match or mismatch)
			// I    Insertion to the reference
			// D    Deletion from the reference
			// N    Skipped region from the reference
			// S    Soft clip on the read (clipped sequence present in <seq>)
			// H    Hard clip on the read (clipped sequence NOT present in <seq>)
			// P    Padding (silent deletion from the padded reference sequence)
			// =    Sequence match
			// X    Sequence mismatch

			// We treat mismatching aligned bases (M/X/=), deleted bases (D) and
			// inserted bases (I) as mismatches. Soft-clipped, hard-clipped and
			// 'skipped regions are handled to keep track of position but do not count
			// as mismatches.

			// sanity check

			switch( type ) {
				case 'M':
				case 'X':
				case '=':
					// matching or mismatching bases. Iterate bases and test for mismatch.
					for( int k = 0; k < i->Length(); ++k, ++aligned_position, ++read_position ) {
						MismatchType mismatch_type = eMatch ;
						if( std::toupper(*(contig.sequence().begin() + aligned_position)) != std::toupper( read_sequence[read_position] )) {
							mismatch_type = eMismatch ;
						}
						callback(
							mismatch_type,
							contig_id,
							contig.sequence(),
							aligned_position,
							aligned_position + 1,
							read_sequence,
							read_position,
							read_position+1
						) ;
					}
					break ;
				case 'D':
					callback(
						eDeletion,
						contig_id,
						contig.sequence(),
						aligned_position,
						aligned_position + i->Length(),
						read_sequence,
						read_position,
						read_position
					) ;
					aligned_position += i->Length() ;
					// purely deleted bases so no change to read position
					break ;
				case 'I':
					callback(
						eInsertion,
						contig_id,
						contig.sequence(),
						aligned_position,
						aligned_position,
						read_sequence,
						read_position,
						read_position + i->Length()
					) ;
					read_position += i->Length() ;
					// purely inserted bases so no change to aligned position
					break ;
				case 'N':
					// no coverage but need to skip over part of reference.
					read_position += i->Length() ;
					aligned_position += i->Length() ;
					break ;
				case 'S':
					// soft-clipped bases; skip this part of the read.
					read_position += i->Length() ;
					break ;
				case 'H':
					// hard-clipped bases not in the read sequence: nothing to do.
				default:
					// nothing to do for other cases
					break ;
			}
		}
		if( aligned_position != alignment.PositionEnd() ) {
			std::cerr << "!! read alignment: " << alignment.Position() << "-" << alignment.PositionEnd() << ", but parsing ended at " << aligned_position << ".\n" ;
			std::cerr << "!! CIGAR is " << alignment.GetCigar() << ".\n" ;
		}
		assert( aligned_position == alignment.PositionEnd() ) ;
	}
}

struct IorekApplication: public appcontext::ApplicationContext
{
public:
	IorekApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new IorekOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	typedef std::map< MismatchClass, int > Result ;

	typedef std::set< RepeatTract > Payload ;
	typedef boost::icl::interval_map< genfile::GenomePosition, Payload > Annotation ;
	Annotation m_repeat_tracts ;
	std::vector< std::string > m_annotation_names ;

	genfile::Fasta::UniquePtr m_fasta ;
	genfile::FastaMask::UniquePtr m_mask ;

private:
	void unsafe_process() {
		m_fasta = genfile::Fasta::create() ;
		{
			std::string const& fasta_filename = options().get< std::string >( "-fasta" ) ;
			auto progress_context = ui().get_progress_context( "Loading sequences from \"" + fasta_filename + "\"" ) ;
			m_fasta->add_sequences_from_file( fasta_filename, progress_context ) ;
		}
		
		m_mask = genfile::FastaMask::create( *m_fasta, genfile::FastaMask::eUnmasked ) ;
		if( options().check( "-include-mask" )) {
			std::string const filename = options().get< std::string >( "-include-mask" ) ;
			auto progress_context = ui().get_progress_context( "Loading mask from \"" + filename + "\"" ) ;
			m_mask->set( genfile::FastaMask::eMasked ) ;
			m_mask->set_from_bed3_file( filename, genfile::FastaMask::eUnmasked, progress_context ) ;
		}

		if( options().check( "-exclude-mask" )) {
			std::string const filename = options().get< std::string >( "-exclude-mask" ) ;
			auto progress_context = ui().get_progress_context( "Loading mask from \"" + filename + "\"" ) ;
			m_mask->set_from_bed3_file( filename, genfile::FastaMask::eMasked, progress_context ) ;
		}

		statfile::BuiltInTypeStatSink::UniquePtr sink = open_results_sink( options().get< std::string >( "-o" )) ;
		unsafe_process(
			options().get_values< std::string >( "-reads" ),
			*sink
		) ;
	}

	statfile::BuiltInTypeStatSink::UniquePtr open_results_sink(std::string const& filename ) const {
		statfile::BuiltInTypeStatSink::UniquePtr result = statfile::BuiltInTypeStatSink::open( filename ) ;
		result->write_metadata(
			"Computed by tabulate-mismatches " + appcontext::get_current_time_as_string() + "\n"
			+ "Coordinates are 1-based, closed."
		) ;
		bool const by_position = options().check( "-by-position" ) ;
		(*result) | "count" ;
		if( by_position ) {
			(*result) | "contig_id" | "position" ;
		}
		(*result) | "type" | "contig_sequence" | "read_sequence" | "left_flank" | "right_flank" | "contig_bases_unmasked" | "edit_bases_unmasked" ;
		return result ;
	}

	void unsafe_process(
		std::vector< std::string > const& filenames,
		statfile::BuiltInTypeStatSink& sink
	) {
		Result result ;
		
		for( std::size_t file_i = 0; file_i < filenames.size(); ++file_i ) {
			process_reads(
				filenames[file_i],
				&result,
				sink
			) ;
		}
		
		output_all_results( result, sink ) ;
	}

	void output_one_result(
		MismatchClass const& m,
		int count,
		statfile::BuiltInTypeStatSink& sink,
		bool by_position
	) const {
		sink << count ; // count
		if( by_position ) {
			sink << m.contig_id() << (m.position()+1) ; // convert back to 1-based coords
		}
		sink
			<< std::string( 1, m.type() )
			<< m.contig_sequence() << m.read_sequence()
			<< m.left_flank() << m.right_flank()
			<< m.contig_bases_unmasked() << m.edit_bases_unmasked()
		;

		sink << statfile::end_row() ;
	}

	void process_reads(
		std::string const& filename,
		Result* result,
		statfile::BuiltInTypeStatSink& sink
	) {
		seqlib::BamReader reader;
		std::unique_ptr< seqlib::ThreadPool > thread_pool ;
		if( options().get< uint32_t >( "-threads" ) > 0 ) {
			thread_pool.reset( new seqlib::ThreadPool( options().get< int >( "-threads" ) )) ;
			reader.SetThreadPool( *thread_pool ) ;
		}
		if( options().check( "-fasta" )) {
			reader.SetCramReference( options().get< std::string >( "-fasta" )) ;
		}
		if( !reader.Open( filename )) {
			assert( "Failed to open file" ) ;
		}
		seqlib::BamHeader const& header = reader.Header() ;
		if( options().check( "-range" )) {
			genfile::GenomePositionRange range = genfile::GenomePositionRange::parse( options().get< std::string >( "-range" )) ;
			try {
				// note:  SeqLib is a bit weird on positions.
				// htslib uses 0-based, half-open positions throughout.  See e.g. the hts_parse_reg function which SeqLib uses here under the hood.
				// However, SeqLib changes this back into a 1-based, closed position internally.
				// The upshot is we pass in 1-based coords and that's how SeqLib treats them.
				// (But when we use this region below, the alignments come back 0-based).
				if( !reader.SetRegion( seqlib::GenomicRegion( range.toString(), header ))) {
					throw genfile::BadArgumentError(
						"iorekApplication::process_reads()",
						"-range",
						"Unable to set the range, does a BAM index file exist?"
					) ;
				} ;
			} catch( std::invalid_argument const& e ) {
				throw genfile::BadArgumentError(
					"seqlib::GenomicRegion()",
					"region=\"" + range.toString() + "\"",
					"Failed for file \"" + filename + "\""
				) ;
			}
		}
		
		auto progress_context = ui().get_progress_context( "Processing \"" + filename + "\"" ) ;
		process_reads( reader, header, result, sink, [&] ( std::size_t count ) { progress_context( count ) ; } ) ;
	}
	
	void process_reads(
		seqlib::BamReader reader,
		seqlib::BamHeader header,
		Result* result,
		statfile::BuiltInTypeStatSink& sink,
		std::function< void( std::size_t ) > progress_callback
	) {
		int32_t const mq_threshold = options().get< int32_t >( "-mq" ) ;
		bool const by_position = options().check( "-by-position" ) ;
		
		bool use_range = options().check( "-range" ) ;
		genfile::GenomePositionRange const range
			= use_range
			? genfile::GenomePositionRange::parse( options().get<std::string>( "-range" ))
			: genfile::GenomePositionRange( 0,0 )
		;
		
		std::size_t const flank = options().get< std::size_t >( "-flank" ) ;
		
		seqlib::BamRecord alignment ;
		std::size_t count = 0 ;
		while( reader.GetNextRecord( alignment ) ) {
			if( 
				!alignment.SecondaryFlag()
				&& !alignment.SupplementaryFlag()
				&& !alignment.DuplicateFlag()
				&& !alignment.QCFailFlag()
				&& alignment.MappedFlag()
				&& alignment.MapQuality() >= mq_threshold
			) {
				classify_alignment_mismatches(
					alignment,
					header,
					*m_fasta,
					[&](
						MismatchType const& type,
						std::string const& contig_id,
						genfile::Fasta::ConstSequenceRange const& contig,
						std::size_t begin_in_contig,
						std::size_t end_in_contig,
						std::string const& read_sequence,
						std::size_t begin_in_read,
						std::size_t end_in_read
					) {
						// Ignore if out of specified range
						if( use_range ) {
							if(
								(end_in_contig < (range.start().position()-1)) // here using 0 based coords, range is in 1-based
								|| (begin_in_contig > range.end().position() )
							) {
								return ;
							}
						}
						// otherwise process...
						process_mismatch(
							type,
							contig_id,
							contig,
							begin_in_contig,
							end_in_contig,
							read_sequence,
							begin_in_read,
							end_in_read,
							flank,
							by_position,
							result
						) ;
					},
					flank
				) ; 
			}

			if( by_position ) {
				output_results_so_far(
					*result,
					sink,
					header.IDtoName( alignment.ChrID() ),
					std::max( alignment.AlignmentPosition() - 1, 0 )
				) ;
			}

			++count ;
			if( progress_callback ) {
				progress_callback( count ) ;
			}
		}
	}

	void process_mismatch(
		MismatchType const& type,
		std::string const& contig_id,
		genfile::Fasta::ConstSequenceRange const& contig,
		std::size_t begin_in_contig,
		std::size_t end_in_contig,
		std::string const& read_sequence,
		std::size_t begin_in_read,
		std::size_t end_in_read,
		std::size_t const flank,
		bool by_position,
		Result* result
	) const {
#if DEBUG
		std::cerr << "++ Mismatch: " << contig_id << ": " << begin_in_contig << "-" << end_in_contig << ".\n" ;
#endif
		
		// find flanking sequence beginning and end
		genfile::Fasta::ConstSequenceIterator const begin_in_contig_i = contig.begin() + begin_in_contig ;
		genfile::Fasta::ConstSequenceIterator const end_in_contig_i = contig.begin() + end_in_contig ;
		genfile::Fasta::ConstSequenceIterator contig_flank_begin_i = begin_in_contig_i ;
		genfile::Fasta::ConstSequenceIterator contig_flank_end_i = end_in_contig_i ;

		for( std::size_t i = 0; contig_flank_begin_i != contig.begin() && i < flank; --contig_flank_begin_i, ++i ) ;
		for( std::size_t i = 0; contig_flank_end_i != contig.end() && i < flank; ++contig_flank_end_i, ++i ) ;

		std::string::const_iterator const begin_in_read_i = read_sequence.begin() + begin_in_read ;
		std::string::const_iterator const end_in_read_i = read_sequence.begin() + end_in_read ;
		
		std::string left_flank( contig_flank_begin_i, begin_in_contig_i ) ;
		std::string sequence_in_contig( begin_in_contig_i, end_in_contig_i ) ;
		std::string right_flank( end_in_contig_i, contig_flank_end_i ) ;
		std::string sequence_in_read( begin_in_read_i, end_in_read_i ) ;
		std::transform( left_flank.begin(), left_flank.end(), left_flank.begin(), ::toupper ) ;
		std::transform( sequence_in_contig.begin(), sequence_in_contig.end(), sequence_in_contig.begin(), ::toupper ) ;
		std::transform( right_flank.begin(), right_flank.end(), right_flank.begin(), ::toupper ) ;

#if DEBUG
		std::cerr
			<< "++ sequence in contig: " << sequence_in_contig << "; sequence in read: " << sequence_in_read << "\n"
			<< "++ begin_in_contig: " << begin_in_contig << ", end_in_contig: " << end_in_contig << ".\n"
			<< "++ begin_in_read: " << begin_in_read << ", end_in_read: " << end_in_read << "\n"
			<< "++ type: " << std::string( 1, type ) << ".\n" ;
#endif

		std::size_t contig_bases_unmasked = 0 ;
		std::size_t edit_bases_unmasked = 0 ;
		switch( type ) {
			case eMatch:
			case eMismatch:
			case eDeletion:
				for( std::size_t pos = begin_in_contig; pos < end_in_contig; ++pos ) {
					contig_bases_unmasked += (m_mask->at_zero_based( contig_id, pos ) == genfile::FastaMask::eUnmasked) ;
				}
				edit_bases_unmasked = contig_bases_unmasked * ( (type == eMatch) ? 0 : 1 ) ;
				break ;
			case eInsertion:
				contig_bases_unmasked = 0 ;
				if(
					(m_mask->at_zero_based( contig_id, begin_in_contig ) == genfile::FastaMask::eUnmasked)
					|| ((begin_in_contig > 0) && (m_mask->at_zero_based( contig_id, begin_in_contig-1 ) == genfile::FastaMask::eUnmasked))
				) {
					edit_bases_unmasked = (end_in_read - begin_in_read) ;
				}
				break ;
		} ;

		MismatchClass e(
			by_position ? contig_id  : "",
			by_position ? begin_in_contig : 0ul,
			type,
			sequence_in_contig,
			sequence_in_read,
			left_flank,
			right_flank,
			contig_bases_unmasked,
			edit_bases_unmasked
		) ;
		++(*result)[e] ;		
	}

	void output_results_so_far(
		Result& result,
		statfile::BuiltInTypeStatSink& sink,
		std::string const& contig_id,
		std::size_t until_position
	) {
		bool const by_position = options().check( "-by-position" ) ;
		std::size_t count = 0 ;
		Result::iterator i = result.begin() ;
		Result::const_iterator end_i = result.end() ;
		while( i != end_i ) {
			if( i->first.contig_id() == contig_id && i->first.position() <= until_position ) {
				output_one_result(
					i->first,
					i->second,
					sink,
					by_position
				) ;
				// Now delete the result as already output.
				Result::iterator j = i++ ;
				result.erase( j ) ;
			} else {
				++i ;
			}
		}
	}

	void output_all_results(
		Result const& result,
		statfile::BuiltInTypeStatSink& sink
	) {
		bool const by_position = options().check( "-by-position" ) ;
		auto progress_context = ui().get_progress_context( "Storing remaining results" ) ;
		std::size_t count = 0 ;
		for( auto& kv: result ) {
			output_one_result(
				kv.first,
				kv.second,
				sink,
				by_position
			) ;
			progress_context( ++count, result.size() ) ;
		}
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		IorekApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
