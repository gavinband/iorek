
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <unordered_map>
#include <unordered_set>
#include <set>
#include <algorithm>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#define DEBUG 0

namespace globals {
	std::string const program_name = "tabulate-mismatches" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct SvelteOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description( "Genommic regions (expressed in the form <chromosome>:<start>-<end>)"
				" to process.  Regions are expressed in 1-based, right-closed coordinates."
				" (These regions should have few copy number variants)" 
				" Alternatively this can be the name of a file containing a list of regions."
			)
			.set_takes_single_value()
		;
		options[ "-reference" ]
			.set_description( "Specify reference sequence" )
			.set_takes_single_value()
			.set_is_required() ;

		options.declare_group( "Model options" ) ;
		options[ "-mq" ]
			.set_description( "Mapping quality threshold" )
			.set_takes_single_value()
			.set_default_value( 0 ) ;

		options[ "-by-position" ]
			.set_description( "Specify that errors should be tabulated by position, not aggregated." ) ;

		options.declare_group( "Miscellaneous options" ) ;
		options[ "-threads" ]
			.set_description( "Use this many extra threads for file reading" )
			.set_takes_single_value()
			.set_default_value( 0 ) ;

	}
} ;

namespace {
	
	enum MismatchType {
		eMatch = '=',
		eMismatch = 'X',
		eDeletion = 'D',
		eInsertion = 'I'
	} ;
	
	struct MismatchClass
	{
		MismatchClass(
			std::string const& contig_id,
			uint32_t position,
			MismatchType const& type,
			std::string const& contig_sequence,
			std::string const& read_sequence,
			std::string const& left_flank,
			std::string const& right_flank
		):
			m_contig_id( contig_id ),
			m_position( position ),
			m_type( type ),
			m_contig_sequence( contig_sequence ),
			m_read_sequence( read_sequence ),
			m_left_flank( left_flank ),
			m_right_flank( right_flank )
		{}

		MismatchClass(
			MismatchClass const& other
		):
			m_contig_id( other.m_contig_id ),
			m_position( other.m_position ),
			m_type( other.m_type ),
			m_contig_sequence( other.m_contig_sequence ),
			m_read_sequence( other.m_read_sequence ),
			m_left_flank( other.m_left_flank ),
			m_right_flank( other.m_right_flank )
		{}

		MismatchClass& operator=(
				MismatchClass const& other
		) {
			m_contig_id = other.m_contig_id ;
			m_position = other.m_position ;
			m_type = other.m_type ;
			m_contig_sequence = other.m_contig_sequence ;
			m_read_sequence = other.m_read_sequence ;
			m_left_flank = other.m_left_flank ;
			m_right_flank = other.m_right_flank ;
			return *this ;
		}

		std::string const& contig_id() const { return m_contig_id ; }
		uint32_t position() const { return m_position ; }
		MismatchType const type() const { return m_type ; }
		std::string const& contig_sequence() const { return m_contig_sequence ; }
		std::string const& read_sequence() const { return m_read_sequence ; }
		std::string const& left_flank() const { return m_left_flank ; }
		std::string const& right_flank() const { return m_right_flank ; }
		
		friend bool operator<( MismatchClass const& left, MismatchClass const& right ) ;
		friend std::ostream& operator<<( std::ostream& out, MismatchClass const& m ) ;
	private:
		std::string m_contig_id ;
		uint32_t m_position ;
		MismatchType m_type ;
		std::string m_contig_sequence ;
		std::string m_read_sequence ;
		std::string m_left_flank ;
		std::string m_right_flank ;
	} ;
	
	bool operator<( MismatchClass const& left, MismatchClass const& right ) {
		if( left.m_contig_id < right.m_contig_id ) {
			return true ;
		} else if( left.m_contig_id > right.m_contig_id ) {
			return false ;
		}
		if( left.m_position < right.m_position ) {
			return true ;
		} else if( left.m_position > right.m_position ) {
			return false ;
		}
		if( left.m_type < right.m_type ) {
			return true ;
		} else if( left.m_type > right.m_type ) {
			return false ;
		}
		if( left.m_contig_sequence < right.m_contig_sequence ) {
			return true ;
		} else if( left.m_contig_sequence > right.m_contig_sequence ) {
			return false ;
		}
		if( left.m_read_sequence < right.m_read_sequence ) {
			return true ;
		} else if( left.m_read_sequence > right.m_read_sequence ) {
			return false ;
		}
		if( left.m_left_flank < right.m_left_flank ) {
			return true ;
		} else if( left.m_left_flank > right.m_left_flank ) {
			return false ;
		}
		if( left.m_right_flank < right.m_right_flank ) {
			return true ;
		} else if( left.m_right_flank > right.m_right_flank ) {
			return false ;
		}
		return false ;
	}

	std::ostream& operator<<( std::ostream& out, MismatchClass const& m ) {
		out << m.m_contig_id << ":" << m.m_position << ": " << char( m.m_type ) << " "
			<< m.m_left_flank << "[" << m.m_contig_sequence << ">" << m.m_read_sequence << "]" << m.m_right_flank ;
		return out ;
	}

	template< typename Iterator >
	struct SequenceRange
	{
		SequenceRange( Iterator begin, Iterator end ):
			m_begin( begin ),
			m_end( end )
		{}
		SequenceRange( SequenceRange const& other ):
			m_begin( other.m_begin ),
			m_end( other.m_end )
		{}
		SequenceRange& operator=( SequenceRange const& other ) {
			m_begin = other.m_begin ;
			m_end = other.m_end ;
			return *this ;
		}
	private:
		Iterator m_begin ;
		Iterator m_end ;
	} ;

	template< typename Iterator >
	SequenceRange<Iterator> sequence_range( Iterator begin, Iterator end ) {
		return SequenceRange<Iterator>( begin, end ) ;
	}

	void classify_alignment_mismatches(
		seqlib::BamRecord const& alignment,
		seqlib::BamHeader const& header,
		genfile::Fasta const& fasta,
		std::function<
			void(
				std::string const& contig_id,
				int position,
				MismatchType const& type,
				genfile::Fasta::ConstSequenceIterator flank_begin,
				genfile::Fasta::ConstSequenceIterator contig_begin,
				genfile::Fasta::ConstSequenceIterator contig_end,
				genfile::Fasta::ConstSequenceIterator flank_end,
				std::string::const_iterator read_begin,
				std::string::const_iterator read_end
			)
		> callback,
		uint32_t const flank = 3
	) {
		// walk Cigar string, accumulate on mismatches
		seqlib::Cigar const& cigar = alignment.GetCigar() ;

		std::string const& read_sequence = alignment.Sequence() ;
		std::string const contig_id = header.IDtoName( alignment.ChrID() ) ;
		genfile::Fasta::PositionedSequenceRange const contig = fasta.get_sequence( contig_id ) ;

		uint32_t read_position = 0;
		uint32_t aligned_position = alignment.Position() ; // 0-based
#if DEBUG
		//std::cerr << "Inspecting read: " << alignment.Qname() << ", CIGAR = \"" << cigar << "\".\n" ;
#endif
		seqlib::Cigar::const_iterator i = cigar.begin(), end_i = cigar.end() ;
		for( ; i != end_i; ++i ) {
			char const type = i->Type() ;
#if DEBUG
			std::cerr << "II: read position = " << read_position << "; alignment pos = " << aligned_position << "; cigar elt = \"" << *i << "\".\n" ;
#endif
			// The cigar ops are:
			// M    Alignment match (can be a sequence match or mismatch)
			// I    Insertion to the reference
			// D    Deletion from the reference
			// N    Skipped region from the reference
			// S    Soft clip on the read (clipped sequence present in <seq>)
			// H    Hard clip on the read (clipped sequence NOT present in <seq>)
			// P    Padding (silent deletion from the padded reference sequence)
			// =    Sequence match
			// X    Sequence mismatch
			//
			// ...so we only need to handle aligned bases and skipped/deleted bases here.
			// (NB. 'skipped' bases probably only turn up in spliced RNA alignments).
			//

			switch( type ) {
				case 'M':
				case 'X':
				case '=':
					// match or mismatch.  Compare bases
					for( int k = 0; k < i->Length(); ++k, ++aligned_position, ++read_position ) {
						if( std::toupper(*(contig.sequence().begin() + aligned_position)) != std::toupper( read_sequence[read_position] )) {
							callback(
								contig_id,
								aligned_position,
								eMismatch,
								(contig.sequence().begin() + (aligned_position - std::min(aligned_position,flank))),
								(contig.sequence().begin() + aligned_position),
								(contig.sequence().begin() + aligned_position + 1),
								(contig.sequence().begin() + std::min( aligned_position+flank+1, uint32_t(contig.size()))),
								read_sequence.begin() + read_position,
								read_sequence.begin() + read_position + 1
							) ;
						}
					}
					break ;
				case 'D':
					callback(
						contig_id,
						aligned_position,
						eDeletion,
						(contig.sequence().begin() + (aligned_position - std::min(aligned_position,flank))),
						(contig.sequence().begin() + aligned_position),
						(contig.sequence().begin() + aligned_position + i->Length() ),
						(contig.sequence().begin() + std::min( aligned_position+i->Length()+flank, uint32_t(contig.size()) )),
						read_sequence.begin() + read_position,
						read_sequence.begin() + read_position
					) ;
					aligned_position += i->Length() ;
					// no change to read position
					break ;
				case 'I':
					callback(
						contig_id,
						aligned_position,
						eInsertion,
						(contig.sequence().begin() + aligned_position - std::min( flank, aligned_position + 1 )),
						(contig.sequence().begin() + aligned_position),
						(contig.sequence().begin() + aligned_position),
						(contig.sequence().begin() + std::min( aligned_position+flank, uint32_t(contig.size()) )),
						read_sequence.begin() + read_position,
						read_sequence.begin() + read_position + i->Length()
					) ;
					read_position += i->Length() ;
					// no change to aligned position
					break ;
				case 'N':
					// no coverage but need to skip over part of reference.
					read_position += i->Length() ;
					aligned_position += i->Length() ;
					break ;
				case 'S':
					// no coverage but need to skip over part of reference.
					read_position += i->Length() ;
					break ;
				case 'H':
				default:
					// nothing to do for other cases
					break ;
			}
		}
		if( aligned_position != alignment.PositionEnd() ) {
			std::cerr << "!! read alignment: " << alignment.Position() << "-" << alignment.PositionEnd() << ", but parsing ended at " << aligned_position << ".\n" ;
			std::cerr << "!! CIGAR is " << alignment.GetCigar() << ".\n" ;
		}
		assert( aligned_position == alignment.PositionEnd() ) ;
	}
}

struct SvelteApplication: public appcontext::ApplicationContext
{
public:
	SvelteApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new SvelteOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	typedef std::map< MismatchClass, int > Result ;
	
	void unsafe_process() {
		unsafe_process(
			options().get_values< std::string >( "-reads" ),
			options().get< std::string >( "-reference" )
		) ;
	}

	void unsafe_process(
		std::vector< std::string > const& filenames,
		std::string const& fasta_filename
	) {
		Result result ;

		statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open(
			options().get< std::string >( "-o" )
		) ;
		
		genfile::Fasta::UniquePtr fasta = genfile::Fasta::create() ;
		{
			auto progress_context = ui().get_progress_context( "Loading sequences from \"" + fasta_filename + "\"" ) ;
			fasta->add_sequences_from_file( fasta_filename, progress_context ) ;
		}
		
		for( std::size_t file_i = 0; file_i < filenames.size(); ++file_i ) {
			process_reads(
				filenames[file_i],
				*fasta,
				&result
			) ;
		}
		
		output_results( result, *sink ) ;
	}
	
	void process_reads(
		std::string const& filename,
		genfile::Fasta const& fasta,
		Result* result
	) {
		seqlib::BamReader reader;
		std::unique_ptr< seqlib::ThreadPool > thread_pool ;
		if( options().get< uint32_t >( "-threads" ) > 0 ) {
			thread_pool.reset( new seqlib::ThreadPool( options().get< int >( "-threads" ) )) ;
			reader.SetThreadPool( *thread_pool ) ;
		}
		if( options().check( "-reference" )) {
			reader.SetCramReference( options().get< std::string >( "-reference" )) ;
		}
		if( !reader.Open( filename )) {
			assert( "Failed to open file" ) ;
		}
		seqlib::BamHeader const& header = reader.Header() ;
		if( options().check( "-range" )) {
			genfile::GenomePositionRange range = genfile::GenomePositionRange::parse( options().get< std::string >( "-range" )) ;
			try {
				// note:  SeqLib is a bit weird on positions.
				// htslib uses 0-based, half-open positions throughout.  See e.g. the hts_parse_reg function which SeqLib uses here under the hood.
				// However, SeqLib changes this back into a 1-based, closed position internally.
				// The upshot is we pass in 1-based coords and that's how SeqLib treats them.
				// But when we use this region below, the alignments come back 0-based.
				reader.SetRegion( seqlib::GenomicRegion( range.toString(), header )) ;
			} catch( std::invalid_argument const& e ) {
				throw genfile::BadArgumentError(
					"seqlib::GenomicRegion()",
					"region=\"" + range.toString() + "\"",
					"Failed for file \"" + filename + "\""
				) ;
			}
		}
		
		auto progress_context = ui().get_progress_context( "Processing \"" + filename + "\"" ) ;
		process_reads( reader, header, fasta, result, [&] ( std::size_t count ) { progress_context( count ) ; } ) ;
	}

	void process_reads(
		seqlib::BamReader reader,
		seqlib::BamHeader header,
		genfile::Fasta const& fasta,
		Result* result,
		std::function< void( std::size_t ) > progress_callback
	) {
		int32_t const mq_threshold = options().get< int32_t >( "-mq" ) ;
		bool const by_position = options().check( "-by-position" ) ;
		
		seqlib::BamRecord alignment ;
		std::size_t count = 0 ;
		while( reader.GetNextRecord( alignment ) ) {
			if( 
				!alignment.SecondaryFlag()
				&& !alignment.SupplementaryFlag()
				&& !alignment.DuplicateFlag()
				&& !alignment.QCFailFlag()
				&& alignment.MappedFlag()
				&& alignment.MapQuality() >= mq_threshold
			) {
				classify_alignment_mismatches(
					alignment,
					header,
					fasta,
					[&](
						std::string const& contig_id,
						int position,
						MismatchType const& type,
						genfile::Fasta::ConstSequenceIterator flank_begin,
						genfile::Fasta::ConstSequenceIterator contig_begin,
						genfile::Fasta::ConstSequenceIterator contig_end,
						genfile::Fasta::ConstSequenceIterator flank_end,
						std::string::const_iterator read_begin,
						std::string::const_iterator read_end
					) {
						std::string left_flank( flank_begin, contig_begin ) ;
						std::string contig_sequence( contig_begin, contig_end ) ;
						std::string right_flank( contig_end, flank_end ) ;
						std::string read_sequence( read_begin, read_end ) ;
						std::transform( left_flank.begin(), left_flank.end(), left_flank.begin(), ::toupper ) ;
						std::transform( contig_sequence.begin(), contig_sequence.end(), contig_sequence.begin(), ::toupper ) ;
						std::transform( right_flank.begin(), right_flank.end(), right_flank.begin(), ::toupper ) ;
						//std::transform( read_sequence.begin(), read_sequence.end(), std::toupper ) ;
						MismatchClass e(
							by_position ? contig_id  : "",
							by_position ? position : 0ul,
							type,
							contig_sequence,
							read_sequence,
							left_flank,
							right_flank
						) ;
#if DEBUG
						std::cerr << "mismatch: (" << contig_id << ":" << (position+1) << "): " << e << "\n"  ;
#endif
						++(*result)[e] ;
					}
				) ; 
			}
			++count ;
			if( progress_callback ) {
				progress_callback( count ) ;
			}
		}
	}

	void output_results( Result const& result, statfile::BuiltInTypeStatSink& sink ) {
		bool const by_position = options().check( "-by-position" ) ;
		sink | "count" ;
		if( by_position ) {
			sink | "contig_id" | "position" ;
		}
		sink | "type" | "contig_sequence" | "read_sequence" | "left_flank" | "right_flank" ;
		auto progress_context = ui().get_progress_context( "Storing results" ) ;
		std::size_t count = 0 ;
		for( auto& kv: result ) {
			MismatchClass const& m = kv.first ;
			sink << kv.second ; // count
			if( by_position ) {
				sink << m.contig_id() << (m.position()+1) ; // convert back to 1-based coords
			}
			sink << std::string( 1, m.type() ) << m.contig_sequence() << m.read_sequence() << m.left_flank() << m.right_flank() << statfile::end_row() ;
			progress_context( ++count, result.size() ) ;
		}
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		SvelteApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
