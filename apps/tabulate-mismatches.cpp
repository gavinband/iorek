
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <unordered_map>
#include <unordered_set>
#include <set>
#include <algorithm>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/icl/interval_map.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "appcontext/get_current_time_as_string.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/FastaMask.hpp"
#include "genfile/find_homopolymers_and_short_repeats.hpp"
#include "genfile/repeats/repeat_tracts.hpp"
#include "genfile/repeats/HomopolymerTractWalker.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "tabulate-mismatches" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct IorekOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description( "Genomic regions (expressed in the form <chromosome>:<start>-<end>)"
				" to process.  Regions are expressed in 1-based, right-closed coordinates."
				" (These regions should have few copy number variants)" 
				" Alternatively this can be the name of a file containing a list of regions."
			)
			.set_takes_single_value()
		;
		options[ "-mask" ]
			.set_description( "Specify a BED file of regions to mask out of the analysis."
			" The file should have no column names and should have contig, start and end columns, "
			" expressed in 0-based right-closed form." )
			.set_takes_single_value()
		;
		options[ "-reference" ]
			.set_description( "Specify reference sequence" )
			.set_takes_single_value()
			.set_is_required() ;

		options[ "-annotate-homopolymers" ]
			.set_description( "Load short repeat repeat tracts from the reference file." )
		;
		options[ "-min-homopolymer-length" ]
			.set_description( "minimum length of repeat repeat tract to report." )
			.set_default_value( 2 )
		;

		options.option_implies_option( "-min-homopolymer-length", "-annotate-homopolymers" ) ;
		
		options.declare_group( "Model options" ) ;
		options[ "-mq" ]
			.set_description( "Ignore alignments below this mapping quality threshold" )
			.set_takes_single_value()
			.set_default_value( 20 ) ;

		options[ "-by-position" ]
			.set_description( "Specify that errors should be tabulated by position, not aggregated." ) ;

		options[ "-flank" ]
			.set_description( "Specify how much flanking sequence to classify by." )
			.set_takes_single_value()
			.set_default_value( 3 ) ;

		options.declare_group( "Miscellaneous options" ) ;
		options[ "-threads" ]
			.set_description( "Use this many extra threads for file reading" )
			.set_takes_single_value()
			.set_hidden()
			.set_default_value( 0 ) ;

	}
} ;

namespace {
	enum MismatchType {
		eMatch = '=',
		eMismatch = 'X',
		eDeletion = 'D',
		eInsertion = 'I'
	} ;

	// We use boost::icl::interval_map to store annotation file entries. This
	// efficiently handles a map from positions to annotations, internally
	// represented as intervvals

	// BED file entries might overlap, and so for each position we keep a set of
	// all annotations at that point.	(For short repeats, basically each
	// base could be in 0, 1, or 2 repeats, but for other BED files I guess there
	// might be more.)  A std::set works fine for this, as in the example:
	// www.boost.org/doc/libs/1_68_0/libs/icl/doc/html/boost_icl/examples/partys_height_average.html
	
	struct RepeatTract
	{
		RepeatTract(
			std::string const& name,
			genfile::Chromosome const& contig,
			genfile::Position start, // 0-based
			genfile::Position end    // 0-based, half-closed
		):
			m_repeat_unit( name ),
			m_contig( contig ),
			m_start( start ),
			m_end( end )
		{
			assert( m_start <= m_end ) ;
		}

		RepeatTract( RepeatTract const& other ):
			m_repeat_unit( other.m_repeat_unit ),
			m_contig( other.m_contig ),
			m_start( other.m_start ),
			m_end( other.m_end )
		{}
		
		RepeatTract& operator=( RepeatTract const& other ) {
			m_repeat_unit = other.m_repeat_unit ;
			m_contig = other.m_contig ;
			m_start = other.m_start ;
			m_end = other.m_end ;
			return *this ;
		}

		bool operator==( RepeatTract const& right ) const {
			RepeatTract const& left = *this ;
			return (left.m_repeat_unit == right.m_repeat_unit)
				&& (left.m_contig == right.m_contig)
				&& (left.m_start == right.m_start)
				&& (left.m_end == right.m_end) ;
		}

		bool operator<( RepeatTract const& right ) const {
			RepeatTract const& left = *this ;
			// This ordering is to ensure that when we choose two
			// elements for output below, we choose the longest ones.

			// order by genomic length (largest first)...
			if( left.length() > right.length() ) {
				return true ;
			} else if( left.length() < right.length() ) {
				return false ;
			}
			// ...then by the length of the annotation string, smallest first...
			if( left.m_repeat_unit.size() < right.m_repeat_unit.size() ) {
				return true ;
			} else if( left.m_repeat_unit.size() > right.m_repeat_unit.size() ) {
				return false ;
			}
			// ...then by the annotation string itself.
			if( left.m_repeat_unit < right.m_repeat_unit ) {
				return true ;
			} else if( left.m_repeat_unit > right.m_repeat_unit ) {
				return false ;
			}
			// ...then by the position
			if( left.m_contig < right.m_contig ) {
				return true ;
			} else if( left.m_contig > right.m_contig ) {
				return false ;
			}
			if( left.m_start < right.m_start ) {
				return true ;
			} else if( left.m_start > right.m_start ) {
				return false ;
			}
			if( left.m_end < right.m_end ) {
				return true ;
			} else if( left.m_end > right.m_end ) {
				return false ;
			}
			return false ;
		}

		std::string const& repeat_unit() const { return m_repeat_unit ; }
		// 0-based coords
		genfile::Chromosome contig() const { return m_contig ; }
		genfile::Position start() const { return m_start ; }
		genfile::Position end() const { return m_end ; }
		uint32_t length() const { return m_end - m_start ; }
		
	private:
		std::string m_repeat_unit ;
		genfile::Chromosome m_contig ;
		genfile::Position m_start ;
		genfile::Position m_end ;
	} ;
	
	// 
	struct RepeatTractClass
	{
		RepeatTractClass(
			std::string const& repeat_unit,
			std::size_t length
		):
			m_repeat_unit( repeat_unit ),
			m_length( length )
		{}

		RepeatTractClass( RepeatTract const& other ):
			m_repeat_unit( other.repeat_unit() ),
			m_length( other.length() )
		{}

		RepeatTractClass( RepeatTractClass const& other ):
			m_repeat_unit( other.m_repeat_unit ),
			m_length( other.m_length )
		{}
		
		RepeatTractClass& operator=( RepeatTractClass const& other ) {
			m_repeat_unit = other.m_repeat_unit ;
			m_length = other.m_length ;
			return *this ;
		}

		bool operator==( RepeatTractClass const& right ) const {
			RepeatTractClass const& left = *this ;
			return (left.m_repeat_unit == right.m_repeat_unit)
				&& (left.m_length == right.m_length) ;
		}

		bool operator<( RepeatTractClass const& right ) const {
			RepeatTractClass const& left = *this ;
			// order by RepeatTract length
			if( left.m_length > right.m_length ) {
				return true ;
			} else if( left.m_length < right.m_length ) {
				return false ;
			}
			// ...then by the length of the annotation string, smallest first...
			if( left.m_repeat_unit.size() < right.m_repeat_unit.size() ) {
				return true ;
			} else if( left.m_repeat_unit.size() > right.m_repeat_unit.size() ) {
				return false ;
			}
			// ...then by the annotation string itself.
			if( left.m_repeat_unit < right.m_repeat_unit ) {
				return true ;
			} else if( left.m_repeat_unit > right.m_repeat_unit ) {
				return false ;
			}
			return false ;
		}

		std::string const& repeat_unit() const { return m_repeat_unit ; }
		// 0-based coords
		uint32_t length() const { return m_length ; }
		
	private:
		std::string m_repeat_unit ;
		std::size_t m_length ;
	} ;

	struct MismatchClass
	{
		MismatchClass(
			std::string const& contig_id,
			uint32_t position,
			MismatchType const& type,
			std::string const& contig_sequence,
			std::string const& read_sequence,
			std::string const& left_flank,
			std::string const& right_flank,
			std::set< RepeatTractClass > const& repeat_classes
		):
			m_contig_id( contig_id ),
			m_position( position ),
			m_type( type ),
			m_contig_sequence( contig_sequence ),
			m_read_sequence( read_sequence ),
			m_left_flank( left_flank ),
			m_right_flank( right_flank ),
			m_repeat_classes( repeat_classes )
		{}

		MismatchClass(
			MismatchClass const& other
		):
			m_contig_id( other.m_contig_id ),
			m_position( other.m_position ),
			m_type( other.m_type ),
			m_contig_sequence( other.m_contig_sequence ),
			m_read_sequence( other.m_read_sequence ),
			m_left_flank( other.m_left_flank ),
			m_right_flank( other.m_right_flank ),
			m_repeat_classes( other.m_repeat_classes )
		{}

		MismatchClass& operator=(
				MismatchClass const& other
		) {
			m_contig_id = other.m_contig_id ;
			m_position = other.m_position ;
			m_type = other.m_type ;
			m_contig_sequence = other.m_contig_sequence ;
			m_read_sequence = other.m_read_sequence ;
			m_left_flank = other.m_left_flank ;
			m_right_flank = other.m_right_flank ;
			m_repeat_classes = other.m_repeat_classes ;
			return *this ;
		}

		std::string const& contig_id() const { return m_contig_id ; }
		uint32_t position() const { return m_position ; }
		MismatchType const type() const { return m_type ; }
		std::string const& contig_sequence() const { return m_contig_sequence ; }
		std::string const& read_sequence() const { return m_read_sequence ; }
		std::string const& left_flank() const { return m_left_flank ; }
		std::string const& right_flank() const { return m_right_flank ; }
		std::set< RepeatTractClass > const& repeat_tract_classes() const { return m_repeat_classes ; }
		
		friend bool operator<( MismatchClass const& left, MismatchClass const& right ) ;
		friend bool operator==( MismatchClass const& left, MismatchClass const& right ) ;
		friend std::ostream& operator<<( std::ostream& out, MismatchClass const& m ) ;
	private:
		std::string m_contig_id ;
		uint32_t m_position ;
		MismatchType m_type ;
		std::string m_contig_sequence ;
		std::string m_read_sequence ;
		std::string m_left_flank ;
		std::string m_right_flank ;
		std::set< RepeatTractClass > m_repeat_classes ;
	} ;
	
	bool operator<( MismatchClass const& left, MismatchClass const& right ) {
		if( left.m_contig_id < right.m_contig_id ) {
			return true ;
		} else if( left.m_contig_id > right.m_contig_id ) {
			return false ;
		}
		if( left.m_position < right.m_position ) {
			return true ;
		} else if( left.m_position > right.m_position ) {
			return false ;
		}
		if( left.m_type < right.m_type ) {
			return true ;
		} else if( left.m_type > right.m_type ) {
			return false ;
		}
		if( left.m_contig_sequence < right.m_contig_sequence ) {
			return true ;
		} else if( left.m_contig_sequence > right.m_contig_sequence ) {
			return false ;
		}
		if( left.m_read_sequence < right.m_read_sequence ) {
			return true ;
		} else if( left.m_read_sequence > right.m_read_sequence ) {
			return false ;
		}
		if( left.m_left_flank < right.m_left_flank ) {
			return true ;
		} else if( left.m_left_flank > right.m_left_flank ) {
			return false ;
		}
		if( left.m_right_flank < right.m_right_flank ) {
			return true ;
		} else if( left.m_right_flank > right.m_right_flank ) {
			return false ;
		}
		if( left.m_repeat_classes < right.m_repeat_classes ) {
			return true ;
		} else if( left.m_repeat_classes > right.m_repeat_classes ) {
			return false ;
		}
		return false ;
	}

	bool operator==( MismatchClass const& left, MismatchClass const& right ) {
		return
			( left.m_contig_id == right.m_contig_id )
			&& ( left.m_position == right.m_position )
			&& ( left.m_type == right.m_type )
			&&( left.m_contig_sequence == right.m_contig_sequence )
			&&( left.m_read_sequence == right.m_read_sequence )
			&&( left.m_left_flank == right.m_left_flank )
			&&( left.m_right_flank == right.m_right_flank )
			&&( left.m_repeat_classes == right.m_repeat_classes )
		;
	}

	std::ostream& operator<<( std::ostream& out, MismatchClass const& m ) {
		out << m.m_contig_id << ":" << m.m_position << ": " << char( m.m_type ) << " "
			<< m.m_left_flank << "[" << m.m_contig_sequence << ">" << m.m_read_sequence << "]" << m.m_right_flank ;
		return out ;
	}

	void classify_alignment_mismatches(
		seqlib::BamRecord const& alignment,
		seqlib::BamHeader const& header,
		genfile::Fasta const& fasta,
		std::function<
			void(
				MismatchType const& type,
				std::string const& contig_id,
				genfile::Fasta::ConstSequenceRange const& contig,
				std::size_t begin_in_contig,
				std::size_t end_in_contig,
				std::string const& read,
				std::size_t begin_in_read,
				std::size_t end_in_read,
				genfile::repeats::HomopolymerTractWalker< genfile::Fasta::ConstSequenceIterator > walker
			)
		> callback,
		uint32_t const flank = 3
	) {
		// Note: this function classifies read-reference mismatches by parsing the
		// CIGAR string and comparing to the reference bases.
		
		// The CIGAR string alone does not contain enough information to reconstruct
		// the mismatching bases.	Thus it is necessary to inspect the reference
		// sequence at the same time.
	
		// Although CIGAR supports 'X' (mismatch) and '=' (identical match), many
		// aligners (such as bwa or minimap2) just output 'M' for mismatches by
		// default.	(Minimap2 does outputs X/= when given the -eqx flag; pbmm2 also
		// seems to do this by default.)

		// Aligners may also output additional information complementing the CIGAR
		// string in the 'MD' tag, and minimap2 can also output a CS tag containing
		// full information about the mismatches.	Use of these would avoid need to
		// parse the reference sequence, but they're not found in every BAM file.
	
		// On balance it therefore seems simplest to work with the CIGAR string and
		// the reference, and to treat 'M', 'X', and '=' as
		// synonymous - which is what we do here.
		
		seqlib::Cigar const& cigar = alignment.GetCigar() ;

		std::string const& read_sequence = alignment.Sequence() ;
		std::string const contig_id = header.IDtoName( alignment.ChrID() ) ;
		genfile::Fasta::ContigRange const contig = fasta.get_sequence( contig_id ) ;

		//bool const count_matches = options().check( "-count-matches" ) ;

		uint32_t read_position = 0;
		uint32_t aligned_position = alignment.Position() ; // 0-based
		genfile::repeats::HomopolymerTractWalker< genfile::Fasta::ConstSequenceIterator > walker(
			contig.sequence().begin(),
			contig.sequence().end(),
			contig.sequence().begin() + aligned_position
		) ;
#if DEBUG
		std::cerr << "\n++ Inspecting read: " << alignment.Qname() << ", CIGAR = \"" << cigar << "\".\n" ;
#endif

		seqlib::Cigar::const_iterator i = cigar.begin(), end_i = cigar.end() ;
		for( ; i != end_i; ++i ) {
			char const type = i->Type() ;
#if DEBUG
			std::cerr << "  : read position = " << read_position << "; alignment pos = " << aligned_position << "; cigar elt = \"" << *i << "\".\n" ;
#endif
			// The cigar ops are:
			// M    Alignment match (can be a sequence match or mismatch)
			// I    Insertion to the reference
			// D    Deletion from the reference
			// N    Skipped region from the reference
			// S    Soft clip on the read (clipped sequence present in <seq>)
			// H    Hard clip on the read (clipped sequence NOT present in <seq>)
			// P    Padding (silent deletion from the padded reference sequence)
			// =    Sequence match
			// X    Sequence mismatch

			// We treat mismatching aligned bases (M/X/=), deleted bases (D) and
			// inserted bases (I) as mismatches. Soft-clipped, hard-clipped and
			// 'skipped regions are handled to keep track of position but do not count
			// as mismatches.

			// sanity check
#if DEBUG
			std::cerr << std::string( 1, type ) << ":" << std::distance( contig.sequence().begin(), walker.position() ) << " - " << aligned_position << ".\n" ;
#endif
			assert( walker.position() == contig.sequence().begin() + aligned_position ) ;

			switch( type ) {
				case 'M':
				case 'X':
				case '=':
					// matching or mismatching bases. Iterate bases and test for mismatch.
					for( int k = 0; k < i->Length(); ++k, ++aligned_position, ++read_position, ++walker ) {
						MismatchType mismatch_type = eMatch ;
						if( std::toupper(*(contig.sequence().begin() + aligned_position)) != std::toupper( read_sequence[read_position] )) {
							mismatch_type = eMismatch ;
						}
						callback(
							mismatch_type,
							contig_id,
							contig.sequence(),
							aligned_position,
							aligned_position + 1,
							read_sequence,
							read_position,
							read_position+1,
							walker
						) ;
					}
					break ;
				case 'D':
					callback(
						eDeletion,
						contig_id,
						contig.sequence(),
						aligned_position,
						aligned_position + i->Length(),
						read_sequence,
						read_position,
						read_position,
						walker
					) ;
					aligned_position += i->Length() ;
					walker += i->Length() ;
					// purely deleted bases so no change to read position
					break ;
				case 'I':
					callback(
						eInsertion,
						contig_id,
						contig.sequence(),
						aligned_position,
						aligned_position,
						read_sequence,
						read_position,
						read_position + i->Length(),
						walker
					) ;
					read_position += i->Length() ;
					// purely inserted bases so no change to aligned position
					break ;
				case 'N':
					// no coverage but need to skip over part of reference.
					read_position += i->Length() ;
					aligned_position += i->Length() ;
					walker += i->Length() ;
					break ;
				case 'S':
					// soft-clipped bases; skip this part of the read.
					read_position += i->Length() ;
					break ;
				case 'H':
					// hard-clipped bases not in the read sequence: nothing to do.
				default:
					// nothing to do for other cases
					break ;
			}
		}
		if( aligned_position != alignment.PositionEnd() ) {
			std::cerr << "!! read alignment: " << alignment.Position() << "-" << alignment.PositionEnd() << ", but parsing ended at " << aligned_position << ".\n" ;
			std::cerr << "!! CIGAR is " << alignment.GetCigar() << ".\n" ;
		}
		assert( aligned_position == alignment.PositionEnd() ) ;
	}
}

struct IorekApplication: public appcontext::ApplicationContext
{
public:
	IorekApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new IorekOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	typedef std::map< MismatchClass, int > Result ;

	typedef std::set< RepeatTract > Payload ;
	typedef boost::icl::interval_map< genfile::GenomePosition, Payload > Annotation ;
	Annotation m_repeat_tracts ;
	std::vector< std::string > m_annotation_names ;

	genfile::Fasta::UniquePtr m_fasta ;
	genfile::FastaMask::UniquePtr m_mask ;

	void unsafe_process() {
		m_fasta = genfile::Fasta::create() ;
		{
			std::string const& fasta_filename = options().get< std::string >( "-reference" ) ;
			auto progress_context = ui().get_progress_context( "Loading sequences from \"" + fasta_filename + "\"" ) ;
			m_fasta->add_sequences_from_file( fasta_filename, progress_context ) ;
		}
		
		if( options().check( "-mask" )) {
			std::string const filename = options().get< std::string >( "-mask" ) ;
			auto progress_context = ui().get_progress_context( "Loading mask from \"" + filename + "\"" ) ;
			m_mask = genfile::FastaMask::load_from_bed3_file(
				*m_fasta,
				filename,
				progress_context
			) ;
		}

		unsafe_process(
			options().get_values< std::string >( "-reads" )
		) ;
	}

	void unsafe_process(
		std::vector< std::string > const& filenames
	) {
		Result result ;

		statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open(
			options().get< std::string >( "-o" )
		) ;
		sink->write_metadata(
			"Computed by tabulate-mismatches " + appcontext::get_current_time_as_string() + "\n"
			+ "Coordinates are 1-based, closed."
		) ;
		
		for( std::size_t file_i = 0; file_i < filenames.size(); ++file_i ) {
			process_reads(
				filenames[file_i],
				&result
			) ;
		}
		
		output_results( result, *sink ) ;
	}
	
	void process_reads(
		std::string const& filename,
		Result* result
	) {
		seqlib::BamReader reader;
		std::unique_ptr< seqlib::ThreadPool > thread_pool ;
		if( options().get< uint32_t >( "-threads" ) > 0 ) {
			thread_pool.reset( new seqlib::ThreadPool( options().get< int >( "-threads" ) )) ;
			reader.SetThreadPool( *thread_pool ) ;
		}
		if( options().check( "-reference" )) {
			reader.SetCramReference( options().get< std::string >( "-reference" )) ;
		}
		if( !reader.Open( filename )) {
			assert( "Failed to open file" ) ;
		}
		seqlib::BamHeader const& header = reader.Header() ;
		if( options().check( "-range" )) {
			genfile::GenomePositionRange range = genfile::GenomePositionRange::parse( options().get< std::string >( "-range" )) ;
			try {
				// note:  SeqLib is a bit weird on positions.
				// htslib uses 0-based, half-open positions throughout.  See e.g. the hts_parse_reg function which SeqLib uses here under the hood.
				// However, SeqLib changes this back into a 1-based, closed position internally.
				// The upshot is we pass in 1-based coords and that's how SeqLib treats them.
				// (But when we use this region below, the alignments come back 0-based).
				reader.SetRegion( seqlib::GenomicRegion( range.toString(), header )) ;
			} catch( std::invalid_argument const& e ) {
				throw genfile::BadArgumentError(
					"seqlib::GenomicRegion()",
					"region=\"" + range.toString() + "\"",
					"Failed for file \"" + filename + "\""
				) ;
			}
		}
		
		auto progress_context = ui().get_progress_context( "Processing \"" + filename + "\"" ) ;
		process_reads( reader, header, result, [&] ( std::size_t count ) { progress_context( count ) ; } ) ;
	}
	
	void process_reads(
		seqlib::BamReader reader,
		seqlib::BamHeader header,
		Result* result,
		std::function< void( std::size_t ) > progress_callback
	) {
		int32_t const mq_threshold = options().get< int32_t >( "-mq" ) ;
		bool const by_position = options().check( "-by-position" ) ;
		
		bool use_range = options().check( "-range" ) ;
		bool annotate_repeats = options().check( "-annotate-homopolymers" ) ;
		genfile::GenomePositionRange const range
			= use_range
			? genfile::GenomePositionRange::parse( options().get<std::string>( "-range" ))
			: genfile::GenomePositionRange( 0,0 )
		;
		
		std::size_t const flank = options().get< std::size_t >( "-flank" ) ;
		
		seqlib::BamRecord alignment ;
		std::size_t count = 0 ;
		while( reader.GetNextRecord( alignment ) ) {
			if( 
				!alignment.SecondaryFlag()
				&& !alignment.SupplementaryFlag()
				&& !alignment.DuplicateFlag()
				&& !alignment.QCFailFlag()
				&& alignment.MappedFlag()
				&& alignment.MapQuality() >= mq_threshold
			) {
				classify_alignment_mismatches(
					alignment,
					header,
					*m_fasta,
					[&](
						MismatchType const& type,
						std::string const& contig_id,
						genfile::Fasta::ConstSequenceRange const& contig,
						std::size_t begin_in_contig,
						std::size_t end_in_contig,
						std::string const& read_sequence,
						std::size_t begin_in_read,
						std::size_t end_in_read,
						genfile::repeats::HomopolymerTractWalker< genfile::Fasta::ConstSequenceIterator > walker
					) {
						// Ignore if out of specified range
						if( use_range ) {
							if(
								(end_in_contig < (range.start().position()-1)) // here using 0 based coords, range is in 1-based
								|| (begin_in_contig > range.end().position() )
							) {
								return ;
							}
						}
						// Ignore if any position covered is masked out
						{
							std::size_t pos = begin_in_contig ;
							for( ; pos < end_in_contig; ++pos ) {
								if( m_mask && m_mask->at_zero_based( contig_id, pos ) == genfile::FastaMask::eMasked ) {
									return ;
								}
							}
						}

						process_mismatch( type, contig_id, contig, begin_in_contig, end_in_contig, read_sequence, begin_in_read, end_in_read, walker, flank, annotate_repeats, by_position, result ) ;
					},
					flank
				) ; 
			}
			++count ;
			if( progress_callback ) {
				progress_callback( count ) ;
			}
		}
	}

	void process_mismatch(
		MismatchType const& type,
		std::string const& contig_id,
		genfile::Fasta::ConstSequenceRange const& contig,
		std::size_t begin_in_contig,
		std::size_t end_in_contig,
		std::string const& read_sequence,
		std::size_t begin_in_read,
		std::size_t end_in_read,
		genfile::repeats::HomopolymerTractWalker< genfile::Fasta::ConstSequenceIterator > walker,
		std::size_t const flank,
		bool const annotate_repeats,
		bool by_position,
		Result* result
	) const {
#if DEBUG
		std::cerr << "++ Mismatch: " << contig_id << ": " << begin_in_contig << "-" << end_in_contig << ".\n" ;
#endif
		assert( walker.position() == contig.begin() + begin_in_contig ) ;
		
		// find flanking sequence beginning and end
		genfile::Fasta::ConstSequenceIterator const begin_in_contig_i = contig.begin() + begin_in_contig ;
		genfile::Fasta::ConstSequenceIterator const end_in_contig_i = contig.begin() + end_in_contig ;
		genfile::Fasta::ConstSequenceIterator contig_flank_begin_i = begin_in_contig_i ;
		genfile::Fasta::ConstSequenceIterator contig_flank_end_i = end_in_contig_i ;

		for( std::size_t i = 0; contig_flank_begin_i != contig.begin() && i < flank; --contig_flank_begin_i, ++i ) ;
		for( std::size_t i = 0; contig_flank_end_i != contig.end() && i < flank; ++contig_flank_end_i, ++i ) ;

		std::string::const_iterator const begin_in_read_i = read_sequence.begin() + begin_in_read ;
		std::string::const_iterator const end_in_read_i = read_sequence.begin() + end_in_read ;
		
		std::string left_flank( contig_flank_begin_i, begin_in_contig_i ) ;
		std::string sequence_in_contig( begin_in_contig_i, end_in_contig_i ) ;
		std::string right_flank( end_in_contig_i, contig_flank_end_i ) ;
		std::string sequence_in_read( begin_in_read_i, end_in_read_i ) ;
		std::transform( left_flank.begin(), left_flank.end(), left_flank.begin(), ::toupper ) ;
		std::transform( sequence_in_contig.begin(), sequence_in_contig.end(), sequence_in_contig.begin(), ::toupper ) ;
		std::transform( right_flank.begin(), right_flank.end(), right_flank.begin(), ::toupper ) ;

#if DEBUG
		std::cerr
			<< "++ sequence in contig: " << sequence_in_contig << "; sequence in read: " << sequence_in_read << "\n"
			<< "++ begin_in_contig: " << begin_in_contig << ", end_in_contig: " << end_in_contig << ".\n"
			<< "++ begin_in_read: " << begin_in_read << ", end_in_read: " << end_in_read << "\n"
			<< "++ type: " << std::string( 1, type ) << ".\n" ;
#endif

		std::set< RepeatTractClass > repeatTractClasses ;
		if( annotate_repeats ) {
			if( type == eInsertion ) {
				// Extent in contig is zero length.
				// Catch homopolymers before or after the insertion
				if( walker.left_tract().size() > 1 ) {
					repeatTractClasses.insert(
						RepeatTractClass(
							std::string( 1, *walker.left_tract().begin() ),
							walker.left_tract().size()
						)
					) ;
				}
				if( walker.right_tract().size() > 1 ) {
					repeatTractClasses.insert(
						RepeatTractClass(
							std::string( 1, *walker.right_tract().begin() ),
							walker.right_tract().size()
						)
					) ;
				}
			} else {
				// catch homopolymers containing the deleted or mismatched bases.
				for( std::size_t i = begin_in_contig; i < end_in_contig; ++i, ++walker ) {
					if( walker.right_tract().size() > 1 ) {
						repeatTractClasses.insert(
							RepeatTractClass(
								std::string( 1, *walker.right_tract().begin() ),
								walker.right_tract().size()
							)
						) ;
					}
				}
			}
		}

		MismatchClass e(
			by_position ? contig_id  : "",
			by_position ? begin_in_contig : 0ul,
			type,
			sequence_in_contig,
			sequence_in_read,
			left_flank,
			right_flank,
			repeatTractClasses
		) ;
		++(*result)[e] ;		
	}

	void output_results( Result const& result, statfile::BuiltInTypeStatSink& sink ) {
		bool const by_position = options().check( "-by-position" ) ;
		bool const with_annotations = options().check( "-annotate-homopolymers" ) ;
		sink | "count" ;
		if( by_position ) {
			sink | "contig_id" | "position" ;
		}
		sink | "type" | "contig_sequence" | "read_sequence" | "left_flank" | "right_flank" ;
		if( with_annotations ) {
			sink | "tract1" | "tract1_length"
			| "tract2" | "tract2_length" ;
		}
		auto progress_context = ui().get_progress_context( "Storing results" ) ;
		std::size_t count = 0 ;
		for( auto& kv: result ) {
			MismatchClass const& m = kv.first ;
			sink << kv.second ; // count
			if( by_position ) {
				sink << m.contig_id() << (m.position()+1) ; // convert back to 1-based coords
			}
			sink << std::string( 1, m.type() ) << m.contig_sequence() << m.read_sequence() << m.left_flank() << m.right_flank() ;

			if( with_annotations ) {
				std::set< RepeatTractClass >::const_iterator i = m.repeat_tract_classes().begin() ;
				std::size_t tract_count = 0 ;
				for( ; tract_count < 2 && i != m.repeat_tract_classes().end(); ++tract_count, ++i ) {
					sink << i->repeat_unit() << i->length() ;
				}
				for( ; tract_count < 2; ++tract_count ) {
					sink << genfile::MissingValue() << genfile::MissingValue() ;
				}
			}

			sink << statfile::end_row() ;
			progress_context( ++count, result.size() ) ;
		}
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		IorekApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
