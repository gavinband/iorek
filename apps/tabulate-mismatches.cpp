
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <unordered_map>
#include <unordered_set>
#include <set>
#include <algorithm>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/icl/interval_map.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "appcontext/get_current_time_as_string.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/Fasta.hpp"
#include "genfile/find_homopolymers_and_short_repeats.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "tabulate-mismatches" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct IorekOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-reads" ]
			.set_description( "Path of bam/cram files to operate on." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;
		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;

		options[ "-range" ]
			.set_description( "Genomic regions (expressed in the form <chromosome>:<start>-<end>)"
				" to process.  Regions are expressed in 1-based, right-closed coordinates."
				" (These regions should have few copy number variants)" 
				" Alternatively this can be the name of a file containing a list of regions."
			)
			.set_takes_single_value()
		;
		options[ "-reference" ]
			.set_description( "Specify reference sequence" )
			.set_takes_single_value()
			.set_is_required() ;

		options[ "-annotation" ]
			.set_description( "Specify a BED file or text file of annotations (for example, of homopolymer RepeatTracts.)"
				" If a .txt file, it must have columns \"contig_id\", \"start\", \"end\", \"repeat\", \"length\""
				" using a 1-based, closed interval coordinate system."
				" If a BED file, it must have 4 columns with no headers, representing sequence ID, start, end, and annotation,"
				" using a 0-based, right-open coordinate system." )
			.set_takes_single_value()
		;

		options[ "-annotate-repeat-tracts" ]
			.set_description( "Load short repeat RepeatTracts from the reference file." )
		;
		options[ "-minimum-RepeatTract-length" ]
			.set_description( "minimum length of repeat RepeatTract to report." )
			.set_default_value( 2 )
		;

		options.option_excludes_option( "-annotate-repeat-tracts", "-annotation" ) ;
		options.option_implies_option( "-minimum-RepeatTract-length", "-annotate-repeat-tracts" ) ;
		
		options.declare_group( "Model options" ) ;
		options[ "-mq" ]
			.set_description( "Ignore alignments below this mapping quality threshold" )
			.set_takes_single_value()
			.set_default_value( 20 ) ;

		options[ "-by-position" ]
			.set_description( "Specify that errors should be tabulated by position, not aggregated." ) ;

		options[ "-flank" ]
			.set_description( "Specify how much flanking sequence to classify by." )
			.set_takes_single_value()
			.set_default_value( 3 ) ;

		options.declare_group( "Miscellaneous options" ) ;
		options[ "-threads" ]
			.set_description( "Use this many extra threads for file reading" )
			.set_takes_single_value()
			.set_hidden()
			.set_default_value( 0 ) ;

	}
} ;

namespace {
	
	enum MismatchType {
		eMatch = '=',
		eMismatch = 'X',
		eDeletion = 'D',
		eInsertion = 'I'
	} ;

	// We use boost::icl::interval_map to store annotation file entries. This
	// efficiently handles a map from positions to annotations, internally
	// represented as intervvals

	// BED file entries might overlap, and so for each position we keep a set of
	// all annotations at that point.	(For short repeats, basically each
	// base could be in 0, 1, or 2 repeats, but for other BED files I guess there
	// might be more.)  A std::set works fine for this, as in the example:
	// www.boost.org/doc/libs/1_68_0/libs/icl/doc/html/boost_icl/examples/partys_height_average.html
	
	struct RepeatTract
	{
		RepeatTract(
			std::string const& name,
			genfile::Chromosome const& contig,
			genfile::Position start, // 0-based
			genfile::Position end    // 0-based, half-closed
		):
			m_repeat_unit( name ),
			m_contig( contig ),
			m_start( start ),
			m_end( end )
		{
			assert( m_start <= m_end ) ;
		}

		RepeatTract( RepeatTract const& other ):
			m_repeat_unit( other.m_repeat_unit ),
			m_contig( other.m_contig ),
			m_start( other.m_start ),
			m_end( other.m_end )
		{}
		
		RepeatTract& operator=( RepeatTract const& other ) {
			m_repeat_unit = other.m_repeat_unit ;
			m_contig = other.m_contig ;
			m_start = other.m_start ;
			m_end = other.m_end ;
			return *this ;
		}

		bool operator==( RepeatTract const& right ) const {
			RepeatTract const& left = *this ;
			return (left.m_repeat_unit == right.m_repeat_unit)
				&& (left.m_contig == right.m_contig)
				&& (left.m_start == right.m_start)
				&& (left.m_end == right.m_end) ;
		}

		bool operator<( RepeatTract const& right ) const {
			RepeatTract const& left = *this ;
			// This ordering is to ensure that when we choose two
			// elements for output below, we choose the longest ones.

			// order by genomic length (largest first)...
			if( left.length() > right.length() ) {
				return true ;
			} else if( left.length() < right.length() ) {
				return false ;
			}
			// ...then by the length of the annotation string, smallest first...
			if( left.m_repeat_unit.size() < right.m_repeat_unit.size() ) {
				return true ;
			} else if( left.m_repeat_unit.size() > right.m_repeat_unit.size() ) {
				return false ;
			}
			// ...then by the annotation string itself.
			if( left.m_repeat_unit < right.m_repeat_unit ) {
				return true ;
			} else if( left.m_repeat_unit > right.m_repeat_unit ) {
				return false ;
			}
			// ...then by the position
			if( left.m_contig < right.m_contig ) {
				return true ;
			} else if( left.m_contig > right.m_contig ) {
				return false ;
			}
			if( left.m_start < right.m_start ) {
				return true ;
			} else if( left.m_start > right.m_start ) {
				return false ;
			}
			if( left.m_end < right.m_end ) {
				return true ;
			} else if( left.m_end > right.m_end ) {
				return false ;
			}
			return false ;
		}

		std::string const& repeat_unit() const { return m_repeat_unit ; }
		// 0-based coords
		genfile::Chromosome contig() const { return m_contig ; }
		genfile::Position start() const { return m_start ; }
		genfile::Position end() const { return m_end ; }
		uint32_t length() const { return m_end - m_start ; }
		
	private:
		std::string m_repeat_unit ;
		genfile::Chromosome m_contig ;
		genfile::Position m_start ;
		genfile::Position m_end ;
	} ;
	
	// 
	struct RepeatTractClass
	{
		RepeatTractClass(
			std::string const& name,
			std::size_t length
		):
			m_repeat_unit( name ),
			m_length( length )
		{}

		RepeatTractClass( RepeatTract const& other ):
			m_repeat_unit( other.repeat_unit() ),
			m_length( other.length() )
		{}

		RepeatTractClass( RepeatTractClass const& other ):
			m_repeat_unit( other.m_repeat_unit ),
			m_length( other.m_length )
		{}
		
		RepeatTractClass& operator=( RepeatTractClass const& other ) {
			m_repeat_unit = other.m_repeat_unit ;
			m_length = other.m_length ;
			return *this ;
		}

		bool operator==( RepeatTractClass const& right ) const {
			RepeatTractClass const& left = *this ;
			return (left.m_repeat_unit == right.m_repeat_unit)
				&& (left.m_length == right.m_length) ;
		}

		bool operator<( RepeatTractClass const& right ) const {
			RepeatTractClass const& left = *this ;
			// order by RepeatTract length
			if( left.m_length > right.m_length ) {
				return true ;
			} else if( left.m_length < right.m_length ) {
				return false ;
			}
			// ...then by the length of the annotation string, smallest first...
			if( left.m_repeat_unit.size() < right.m_repeat_unit.size() ) {
				return true ;
			} else if( left.m_repeat_unit.size() > right.m_repeat_unit.size() ) {
				return false ;
			}
			// ...then by the annotation string itself.
			if( left.m_repeat_unit < right.m_repeat_unit ) {
				return true ;
			} else if( left.m_repeat_unit > right.m_repeat_unit ) {
				return false ;
			}
			return false ;
		}

		std::string const& repeat_unit() const { return m_repeat_unit ; }
		// 0-based coords
		uint32_t length() const { return m_length ; }
		
	private:
		std::string m_repeat_unit ;
		std::size_t m_length ;
	} ;

	struct MismatchClass
	{
		MismatchClass(
			std::string const& contig_id,
			uint32_t position,
			MismatchType const& type,
			std::string const& contig_sequence,
			std::string const& read_sequence,
			std::string const& left_flank,
			std::string const& right_flank,
			std::set< RepeatTractClass > const& repeat_classes
		):
			m_contig_id( contig_id ),
			m_position( position ),
			m_type( type ),
			m_contig_sequence( contig_sequence ),
			m_read_sequence( read_sequence ),
			m_left_flank( left_flank ),
			m_right_flank( right_flank ),
			m_repeat_classes( repeat_classes )
		{}

		MismatchClass(
			MismatchClass const& other
		):
			m_contig_id( other.m_contig_id ),
			m_position( other.m_position ),
			m_type( other.m_type ),
			m_contig_sequence( other.m_contig_sequence ),
			m_read_sequence( other.m_read_sequence ),
			m_left_flank( other.m_left_flank ),
			m_right_flank( other.m_right_flank ),
			m_repeat_classes( other.m_repeat_classes )
		{}

		MismatchClass& operator=(
				MismatchClass const& other
		) {
			m_contig_id = other.m_contig_id ;
			m_position = other.m_position ;
			m_type = other.m_type ;
			m_contig_sequence = other.m_contig_sequence ;
			m_read_sequence = other.m_read_sequence ;
			m_left_flank = other.m_left_flank ;
			m_right_flank = other.m_right_flank ;
			m_repeat_classes = other.m_repeat_classes ;
			return *this ;
		}

		std::string const& contig_id() const { return m_contig_id ; }
		uint32_t position() const { return m_position ; }
		MismatchType const type() const { return m_type ; }
		std::string const& contig_sequence() const { return m_contig_sequence ; }
		std::string const& read_sequence() const { return m_read_sequence ; }
		std::string const& left_flank() const { return m_left_flank ; }
		std::string const& right_flank() const { return m_right_flank ; }
		std::set< RepeatTractClass > const& repeat_tract_classes() const { return m_repeat_classes ; }
		
		friend bool operator<( MismatchClass const& left, MismatchClass const& right ) ;
		friend bool operator==( MismatchClass const& left, MismatchClass const& right ) ;
		friend std::ostream& operator<<( std::ostream& out, MismatchClass const& m ) ;
	private:
		std::string m_contig_id ;
		uint32_t m_position ;
		MismatchType m_type ;
		std::string m_contig_sequence ;
		std::string m_read_sequence ;
		std::string m_left_flank ;
		std::string m_right_flank ;
		std::set< RepeatTractClass > m_repeat_classes ;
	} ;
	
	bool operator<( MismatchClass const& left, MismatchClass const& right ) {
		if( left.m_contig_id < right.m_contig_id ) {
			return true ;
		} else if( left.m_contig_id > right.m_contig_id ) {
			return false ;
		}
		if( left.m_position < right.m_position ) {
			return true ;
		} else if( left.m_position > right.m_position ) {
			return false ;
		}
		if( left.m_type < right.m_type ) {
			return true ;
		} else if( left.m_type > right.m_type ) {
			return false ;
		}
		if( left.m_contig_sequence < right.m_contig_sequence ) {
			return true ;
		} else if( left.m_contig_sequence > right.m_contig_sequence ) {
			return false ;
		}
		if( left.m_read_sequence < right.m_read_sequence ) {
			return true ;
		} else if( left.m_read_sequence > right.m_read_sequence ) {
			return false ;
		}
		if( left.m_left_flank < right.m_left_flank ) {
			return true ;
		} else if( left.m_left_flank > right.m_left_flank ) {
			return false ;
		}
		if( left.m_right_flank < right.m_right_flank ) {
			return true ;
		} else if( left.m_right_flank > right.m_right_flank ) {
			return false ;
		}
		if( left.m_repeat_classes < right.m_repeat_classes ) {
			return true ;
		} else if( left.m_repeat_classes > right.m_repeat_classes ) {
			return false ;
		}
		return false ;
	}

	bool operator==( MismatchClass const& left, MismatchClass const& right ) {
		return
			( left.m_contig_id == right.m_contig_id )
			&& ( left.m_position == right.m_position )
			&& ( left.m_type == right.m_type )
			&&( left.m_contig_sequence == right.m_contig_sequence )
			&&( left.m_read_sequence == right.m_read_sequence )
			&&( left.m_left_flank == right.m_left_flank )
			&&( left.m_right_flank == right.m_right_flank )
			&&( left.m_repeat_classes == right.m_repeat_classes )
		;
	}

	std::ostream& operator<<( std::ostream& out, MismatchClass const& m ) {
		out << m.m_contig_id << ":" << m.m_position << ": " << char( m.m_type ) << " "
			<< m.m_left_flank << "[" << m.m_contig_sequence << ">" << m.m_read_sequence << "]" << m.m_right_flank ;
		return out ;
	}
	
	void classify_alignment_mismatches(
		seqlib::BamRecord const& alignment,
		seqlib::BamHeader const& header,
		genfile::Fasta const& fasta,
		std::function<
			void(
				std::string const& contig_id,
				int position,
				MismatchType const& type,
				genfile::Fasta::ConstSequenceIterator contig_flank_begin,
				genfile::Fasta::ConstSequenceIterator contig_begin,
				genfile::Fasta::ConstSequenceIterator contig_end,
				genfile::Fasta::ConstSequenceIterator contig_flank_end,
				std::string::const_iterator read_begin,
				std::string::const_iterator read_end
			)
		> callback,
		uint32_t const flank = 3
	) {
		// Note: this function classifies read-reference mismatches by parsing the
		// CIGAR string and comparing to the reference bases.
		
		// The CIGAR string alone does not contain enough information to reconstruct
		// the mismatching bases.	Thus it is necessary to inspect the reference
		// sequence at the same time.
	
		// Although CIGAR supports 'X' (mismatch) and '=' (identical match), many
		// aligners (such as bwa or minimap2) just output 'M' for mismatches by
		// default.	(Minimap2 does outputs X/= when given the -eqx flag; pbmm2 also
		// seems to do this by default.)

		// Aligners may also output additional information complementing the CIGAR
		// string in the 'MD' tag, and minimap2 can also output a CS tag containing
		// full information about the mismatches.	Use of these would avoid need to
		// parse the reference sequence, but they're not found in every BAM file.
	
		// On balance it therefore seems simplest to work with the CIGAR string and
		// the reference, and to treat 'M', 'X', and '=' as
		// synonymous - which is what we do here.
		
		seqlib::Cigar const& cigar = alignment.GetCigar() ;

		std::string const& read_sequence = alignment.Sequence() ;
		std::string const contig_id = header.IDtoName( alignment.ChrID() ) ;
		genfile::Fasta::PositionedSequenceRange const contig = fasta.get_sequence( contig_id ) ;

		uint32_t read_position = 0;
		uint32_t aligned_position = alignment.Position() ; // 0-based
		
#if DEBUG
		std::cerr << "++ Inspecting read: " << alignment.Qname() << ", CIGAR = \"" << cigar << "\".\n" ;
#endif

		seqlib::Cigar::const_iterator i = cigar.begin(), end_i = cigar.end() ;
		for( ; i != end_i; ++i ) {
			char const type = i->Type() ;
#if DEBUG
			std::cerr << "  : read position = " << read_position << "; alignment pos = " << aligned_position << "; cigar elt = \"" << *i << "\".\n" ;
#endif
			// The cigar ops are:
			// M    Alignment match (can be a sequence match or mismatch)
			// I    Insertion to the reference
			// D    Deletion from the reference
			// N    Skipped region from the reference
			// S    Soft clip on the read (clipped sequence present in <seq>)
			// H    Hard clip on the read (clipped sequence NOT present in <seq>)
			// P    Padding (silent deletion from the padded reference sequence)
			// =    Sequence match
			// X    Sequence mismatch

			// We treat mismatching aligned bases (M/X/=), deleted bases (D) and
			// inserted bases (I) as mismatches. Soft-clipped, hard-clipped and
			// 'skipped regions are handled to keep track of position but do not count
			// as mismatches.

			switch( type ) {
				case 'M':
				case 'X':
				case '=':
					// matching or mismatching bases. Iterate bases and test for mismatch.
					for( int k = 0; k < i->Length(); ++k, ++aligned_position, ++read_position ) {
						if( std::toupper(*(contig.sequence().begin() + aligned_position)) != std::toupper( read_sequence[read_position] )) {
							callback(
								contig_id,
								aligned_position,
								eMismatch,
								(contig.sequence().begin() + (aligned_position - std::min(aligned_position,flank))),
								(contig.sequence().begin() + aligned_position),
								(contig.sequence().begin() + aligned_position + 1),
								(contig.sequence().begin() + std::min( aligned_position+flank+1, uint32_t(contig.size()))),
								read_sequence.begin() + read_position,
								read_sequence.begin() + read_position + 1
							) ;
						}
					}
					break ;
				case 'D':
					callback(
						contig_id,
						aligned_position,
						eDeletion,
						(contig.sequence().begin() + (aligned_position - std::min(aligned_position,flank))),
						(contig.sequence().begin() + aligned_position),
						(contig.sequence().begin() + aligned_position + i->Length() ),
						(contig.sequence().begin() + std::min( aligned_position+i->Length()+flank, uint32_t(contig.size()) )),
						read_sequence.begin() + read_position,
						read_sequence.begin() + read_position
					) ;
					aligned_position += i->Length() ;
					// purely deleted bases so no change to read position
					break ;
				case 'I':
					callback(
						contig_id,
						aligned_position,
						eInsertion,
						(contig.sequence().begin() + aligned_position - std::min( flank, aligned_position + 1 )),
						(contig.sequence().begin() + aligned_position),
						(contig.sequence().begin() + aligned_position),
						(contig.sequence().begin() + std::min( aligned_position+flank, uint32_t(contig.size()) )),
						read_sequence.begin() + read_position,
						read_sequence.begin() + read_position + i->Length()
					) ;
					read_position += i->Length() ;
					// purely inserted bases so no change to aligned position
					break ;
				case 'N':
					// no coverage but need to skip over part of reference.
					read_position += i->Length() ;
					aligned_position += i->Length() ;
					break ;
				case 'S':
					// soft-clipped bases; skip this part of the read.
					read_position += i->Length() ;
					break ;
				case 'H':
				default:
					// nothing to do for other cases
					break ;
			}
		}
		if( aligned_position != alignment.PositionEnd() ) {
			std::cerr << "!! read alignment: " << alignment.Position() << "-" << alignment.PositionEnd() << ", but parsing ended at " << aligned_position << ".\n" ;
			std::cerr << "!! CIGAR is " << alignment.GetCigar() << ".\n" ;
		}
		assert( aligned_position == alignment.PositionEnd() ) ;
	}
}

struct IorekApplication: public appcontext::ApplicationContext
{
public:
	IorekApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new IorekOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	typedef std::map< MismatchClass, int > Result ;

	typedef std::set< RepeatTract > Payload ;
	typedef boost::icl::interval_map< genfile::GenomePosition, Payload > Annotation ;
	Annotation m_repeat_tracts ;
	std::vector< std::string > m_annotation_names ;

	void unsafe_process() {
		genfile::Fasta::UniquePtr fasta = genfile::Fasta::create() ;
		{
			std::string const& fasta_filename = options().get< std::string >( "-reference" ) ;
			auto progress_context = ui().get_progress_context( "Loading sequences from \"" + fasta_filename + "\"" ) ;
			fasta->add_sequences_from_file( fasta_filename, progress_context ) ;
		}
		
		if( options().check( "-annotation" )) {
			std::string const& filename = options().get< std::string >( "-annotation" ) ;
			auto progress_context = ui().get_progress_context( "Loading annotations from \"" + filename + "\"" ) ;
			load_annotations( filename, progress_context ) ;
			std::cerr << "++ Annotations loaded.\n" ;
#if 0
			std::cerr << "++ Annotations are:\n" ;
			for( const auto& kv: m_repeat_tracts ) {
				std::cerr << "  \"" << k.first < "\":\n" ;
				for( Annotation::const_iterator i = kv.second.begin(); i != kv.second.end(); ++i ) {
					std::cerr << "    " << i->second << ".\n" ;
				}
			}
#endif
			
		} else if( options().check( "-annotate-repeat-tracts" )) {
			load_short_repeat_RepeatTracts( *fasta ) ;
		}
		
		unsafe_process(
			options().get_values< std::string >( "-reads" ),
			*fasta
		) ;
	}

	void load_annotations(
		std::string const& filename,
		std::function< void( std::size_t ) > progress_callback
	) {
		using genfile::string_utils::slice ;
		using genfile::string_utils::to_repr ;

		std::auto_ptr< std::istream > in = genfile::open_text_file_for_input( filename ) ;
		std::string line ;
		std::getline( *in, line ) ;
		// We handle both bed format and find-homopolymers output format.
		// First skip a BED track definition line if present
		if( (line.size() >= 7 && line.substr( 0, 7 ) == "browser") || (line.size() >= 5 && line.substr(0,5) == "track" )) {
			// skip this header line
			std::getline( *in, line ) ;
		}
		// skip comments
		while( line.size() > 0 && line[0] == '#' ) {
			std::getline( *in, line ) ;
		}
		std::string separator( 1, '\t' ) ;
		bool oneBased = false ;
		if(
			(line.size() >= 28)
			&& (line.substr( 0, 11 ) == "sequence_id")
			&& (line.substr( 12, 5 ) == "start")
			&& (line.substr( 18, 3 ) == "end")
			&& (line.substr( 22, 6 ) == "repeat")
		) {
			separator[0] = line[11] ;
			oneBased = true ;
			std::getline( *in, line ) ;
		}

		std::cerr << "Parsing " << filename << ".\n" ;
		std::vector< slice > elts ;
		std::size_t lineCount = 1 ;
		while(*in) {
			elts.clear() ;
			slice( line ).split( separator, &elts ) ;
			if( elts.size() < 4 ) {
				throw genfile::MalformedInputError(
					filename,
					"Expected at least 4 columns in annotation / BED4 file",
					lineCount
				) ;
			}
			genfile::Chromosome chromosome( elts[0] ) ;
			uint32_t start( to_repr< uint32_t >( elts[1] ) ) ;

			// Bed file is 0-based, right-open.
			// We store annotations 0-based as well
			// Other files are treated as 1-based and must be converted here.
			if( oneBased ) {
				--start ;
			}
			uint32_t end( to_repr< uint32_t >( elts[2] ) ) ;
			std::set< RepeatTract > values ;
			values.insert( RepeatTract( elts[3], chromosome, start, end )) ;

			Annotation::interval_type interval(
				genfile::GenomePosition( chromosome, start ),
				genfile::GenomePosition( chromosome, end )
			) ;
			m_repeat_tracts.add( std::make_pair( interval, values )) ;
			std::getline( *in, line ) ;
			progress_callback( ++lineCount ) ;
		}
	}

	void load_short_repeat_RepeatTracts( genfile::Fasta const& fasta ) {
		std::vector< std::string > const& sequence_ids = fasta.sequence_ids() ;
		std::size_t const minimum_length = options().get< std::size_t >( "-minimum-RepeatTract-length" ) ;

		bool use_range = options().check( "-range" ) ;
		genfile::GenomePositionRange range
			= use_range
				? genfile::GenomePositionRange::parse( options().get< std::string >( "-range" ))
				: genfile::GenomePositionRange( 0, 0 )
		;

		// Repeat RepeatTracts get seen in position order.
		// For efficiency we therefore insert them using the previous insertion point
		// as a hint - this variable does that.
		Annotation::iterator last_i = m_repeat_tracts.end() ;

		for( auto sequence_id: sequence_ids ) {
			auto progress_context = ui().get_progress_context( "Loading repeat RepeatTracts from \"" + sequence_id + "\"" ) ;
			genfile::GenomePositionRange const sequence_range = fasta.get_range( sequence_id ) ;
			genfile::Fasta::PositionedSequenceRange const& contig = (
				use_range
				? fasta.get_sequence(
					sequence_id,
					// we look up to 10kb outside the range for a repeat RepeatTract
					range.start().position() - std::min( range.start().position()-1, 10000u ), 
					std::min( range.end().position() + 10000, sequence_range.end().position() )
				)
				: fasta.get_sequence( sequence_id )
			) ;
			genfile::find_homopolymers_and_short_repeats(
				contig.sequence().begin(),
				contig.sequence().end(),
				contig.positions().start().position()-1, // pass it as 0-based
				minimum_length,
				[&]( uint32_t start, uint32_t end, std::string const& repeat ) {
#if DEBUG
					std::cerr << "FOUND RepeatTract: " << sequence_id << ":" << start << "-" << end << ": " << repeat << ".\n" ;
#endif
					// uses 0-based, closed interval coords
					std::set< RepeatTract > values ;
					values.insert( RepeatTract( repeat, sequence_id, start, end )) ;
					Annotation::interval_type interval(
						genfile::GenomePosition( sequence_id, start ), 
						genfile::GenomePosition( sequence_id, end )
					) ;
					last_i = m_repeat_tracts.add( last_i, std::make_pair( interval, values )) ;
				},
				progress_context
			) ;
		}
	}

	void unsafe_process(
		std::vector< std::string > const& filenames,
		genfile::Fasta const& fasta
	) {
		Result result ;

		statfile::BuiltInTypeStatSink::UniquePtr sink = statfile::BuiltInTypeStatSink::open(
			options().get< std::string >( "-o" )
		) ;
		sink->write_metadata(
			"Computed by tabulate-mismatches " + appcontext::get_current_time_as_string() + "\n"
			+ "Coordinates are 1-based, closed."
		) ;
		
		for( std::size_t file_i = 0; file_i < filenames.size(); ++file_i ) {
			process_reads(
				filenames[file_i],
				fasta,
				&result
			) ;
		}
		
		output_results( result, *sink ) ;
	}
	
	void process_reads(
		std::string const& filename,
		genfile::Fasta const& fasta,
		Result* result
	) {
		seqlib::BamReader reader;
		std::unique_ptr< seqlib::ThreadPool > thread_pool ;
		if( options().get< uint32_t >( "-threads" ) > 0 ) {
			thread_pool.reset( new seqlib::ThreadPool( options().get< int >( "-threads" ) )) ;
			reader.SetThreadPool( *thread_pool ) ;
		}
		if( options().check( "-reference" )) {
			reader.SetCramReference( options().get< std::string >( "-reference" )) ;
		}
		if( !reader.Open( filename )) {
			assert( "Failed to open file" ) ;
		}
		seqlib::BamHeader const& header = reader.Header() ;
		if( options().check( "-range" )) {
			genfile::GenomePositionRange range = genfile::GenomePositionRange::parse( options().get< std::string >( "-range" )) ;
			try {
				// note:  SeqLib is a bit weird on positions.
				// htslib uses 0-based, half-open positions throughout.  See e.g. the hts_parse_reg function which SeqLib uses here under the hood.
				// However, SeqLib changes this back into a 1-based, closed position internally.
				// The upshot is we pass in 1-based coords and that's how SeqLib treats them.
				// (But when we use this region below, the alignments come back 0-based).
				reader.SetRegion( seqlib::GenomicRegion( range.toString(), header )) ;
			} catch( std::invalid_argument const& e ) {
				throw genfile::BadArgumentError(
					"seqlib::GenomicRegion()",
					"region=\"" + range.toString() + "\"",
					"Failed for file \"" + filename + "\""
				) ;
			}
		}
		
		auto progress_context = ui().get_progress_context( "Processing \"" + filename + "\"" ) ;
		process_reads( reader, header, fasta, result, [&] ( std::size_t count ) { progress_context( count ) ; } ) ;
	}

	void process_reads(
		seqlib::BamReader reader,
		seqlib::BamHeader header,
		genfile::Fasta const& fasta,
		Result* result,
		std::function< void( std::size_t ) > progress_callback
	) {
		int32_t const mq_threshold = options().get< int32_t >( "-mq" ) ;
		bool const by_position = options().check( "-by-position" ) ;
		
		bool use_range = options().check( "-range" ) ;
		genfile::GenomePositionRange const range
			= use_range
			? genfile::GenomePositionRange::parse( options().get<std::string>( "-range" ))
			: genfile::GenomePositionRange( 0,0 )
		;
		
		std::size_t const flank = options().get< std::size_t >( "-flank" ) ;
		
		seqlib::BamRecord alignment ;
		std::size_t count = 0 ;
		while( reader.GetNextRecord( alignment ) ) {
			if( 
				!alignment.SecondaryFlag()
				&& !alignment.SupplementaryFlag()
				&& !alignment.DuplicateFlag()
				&& !alignment.QCFailFlag()
				&& alignment.MappedFlag()
				&& alignment.MapQuality() >= mq_threshold
			) {
				classify_alignment_mismatches(
					alignment,
					header,
					fasta,
					[&](
						std::string const& contig_id,
						int position,
						MismatchType const& type,
						genfile::Fasta::ConstSequenceIterator contig_flank_begin,
						genfile::Fasta::ConstSequenceIterator contig_begin,
						genfile::Fasta::ConstSequenceIterator contig_end,
						genfile::Fasta::ConstSequenceIterator contig_flank_end,
						std::string::const_iterator read_begin,
						std::string::const_iterator read_end
					) {
#if DEBUG
						std::cerr << "++ Mismatch: " << contig_id << ": " << position << ".\n" ;
#endif
						std::string left_flank( contig_flank_begin, contig_begin ) ;
						std::string contig_sequence( contig_begin, contig_end ) ;
						std::string right_flank( contig_end, contig_flank_end ) ;
						std::string read_sequence( read_begin, read_end ) ;
						std::transform( left_flank.begin(), left_flank.end(), left_flank.begin(), ::toupper ) ;
						std::transform( contig_sequence.begin(), contig_sequence.end(), contig_sequence.begin(), ::toupper ) ;
						std::transform( right_flank.begin(), right_flank.end(), right_flank.begin(), ::toupper ) ;
						//std::transform( read_sequence.begin(), read_sequence.end(), std::toupper ) ;
						if( use_range ) {
							if(
								(position < (range.start().position()-1))
								|| ((position + read_sequence.size()) > range.end().position() )
							) {
								return ;
							}
						}

#if DEBUG
						std::cerr << "++ contig_sequence: " << contig_sequence << "; read sequence: " << read_sequence << ".\n" ;
#endif

						std::set< RepeatTract > repeat_tracts ;
						// look up annotation.
						if( m_repeat_tracts.size() > 0 ) {
							// Annotations are in [begin, end) format, 0-based.
							// So are positions.
							// An example:
							//
							// C A A A G
							// 0 1 2 3 4
							//
							// with the AAA at [1,4)]
							// Here is what we count as in the homopolymer:
							// - A mismatch at any of the positions 1-3
							// - A deletion that intersects positions 1-3
							// - An insertion between any of the positions 1-4.

							// Note there are 4 possible insertion positions but only three
							// substitution / deletion positions.

							if( type == eInsertion ) {
								// To account for insertions at the beginning / middle / end of
								// repeat RepeatTracts, we search if the insertion position is covered
								// by a RepeatTract, but also check for RepeatTracts ending at position-1.
								assert( contig_sequence.size() == 0 ) ; // sanity check.
								Annotation::const_iterator where = m_repeat_tracts.find( genfile::GenomePosition( contig_id, position )) ;
								if( where != m_repeat_tracts.end() ) {
									repeat_tracts.insert( where->second.begin(), where->second.end() ) ;
								}
								where = m_repeat_tracts.find( genfile::GenomePosition( contig_id, position-1 )) ;
								if( where != m_repeat_tracts.end() ) {
									std::set< RepeatTract >::const_iterator i = where->second.begin() ;
									std::set< RepeatTract >::const_iterator end = where->second.end() ;
									for( ; i != end; ++i ) {
										if( i->end() == position ) {
											repeat_tracts.insert( *i ) ;
										}
									}
								}
							} else {
								// Check for any RepeatTract intersecting any contig base of
								// the mismatch / deletion.
								assert( contig_sequence.size() > 0 ) ; // sanity check.
								for( genfile::Position base_i = 0 ; base_i < contig_sequence.size(); ++base_i ) {
									Annotation::const_iterator where = m_repeat_tracts.find( genfile::GenomePosition( contig_id, position + base_i )) ;
									if( where != m_repeat_tracts.end() ) {
										repeat_tracts.insert( where->second.begin(), where->second.end() ) ;
									}
								}
							}

#if DEBUG
							if( repeat_tracts.size() > 0 ) {
								std::cerr << "Annotations found at position " << position << "!  size is " << repeat_tracts.size() << ".\n" ;
							}
#endif
						}
						
#if DEBUG
						std::cerr << "repeat_tracts.size() == " << repeat_tracts.size() << ".\n" ;
#endif
						// remove position information from annotations
						// to avoid counting them seperately.
						// we also only take the first two annotations
						std::set< RepeatTractClass > repeatTractClasses ;
						{
							std::size_t count = 0 ;
							for(
								std::set< RepeatTract >::iterator i = repeat_tracts.begin() ;
								i != repeat_tracts.end() && count < 2;
								++i, ++count
							) {
								repeatTractClasses.insert( RepeatTractClass( *i ) ) ;
							}
						}
						
						MismatchClass e(
							by_position ? contig_id  : "",
							by_position ? position : 0ul,
							type,
							contig_sequence,
							read_sequence,
							left_flank,
							right_flank,
							repeatTractClasses
						) ;
#if DEBUG
						std::cerr << "mismatch: (" << contig_id << ":" << (position+1) << "): " << e << "\n"  ;
#endif
						++(*result)[e] ;
					},
					flank
				) ; 
			}
			++count ;
			if( progress_callback ) {
				progress_callback( count ) ;
			}
		}
	}

	void output_results( Result const& result, statfile::BuiltInTypeStatSink& sink ) {
		bool const by_position = options().check( "-by-position" ) ;
		bool const with_annotations = options().check( "-annotation" ) || options().check( "-annotate-repeat-tracts" ) ;
		sink | "count" ;
		if( by_position ) {
			sink | "contig_id" | "position" ;
		}
		sink | "type" | "contig_sequence" | "read_sequence" | "left_flank" | "right_flank" ;
		if( with_annotations ) {
			sink | "tract1" | "tract1_length"
			| "tract2" | "tract2_length" ;
		}
		auto progress_context = ui().get_progress_context( "Storing results" ) ;
		std::size_t count = 0 ;
		for( auto& kv: result ) {
			MismatchClass const& m = kv.first ;
			sink << kv.second ; // count
			if( by_position ) {
				sink << m.contig_id() << (m.position()+1) ; // convert back to 1-based coords
			}
			sink << std::string( 1, m.type() ) << m.contig_sequence() << m.read_sequence() << m.left_flank() << m.right_flank() ;

			if( with_annotations ) {
#if DEBUG
				std::cerr << "++ outputting annotations with length: " << m.annotations().size() << ".\n" ;
#endif
				std::set< RepeatTractClass >::const_iterator i = m.repeat_tract_classes().begin() ;
				std::size_t tract_count = 0 ;
				for( ; tract_count < 2 && i != m.repeat_tract_classes().end(); ++tract_count, ++i ) {
					sink << i->repeat_unit() << i->length() ;
				}
				for( ; tract_count < 2; ++tract_count ) {
					sink << genfile::MissingValue() << genfile::MissingValue() ;
				}
			}

			sink << statfile::end_row() ;
			progress_context( ++count, result.size() ) ;
		}
	}
} ;

int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		IorekApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
