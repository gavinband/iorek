
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <boost/unordered_map.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

#include <jellyfish/jellyfish.hpp>

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/kmer/KmerHashIterator.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#include "parallel_hashmap/phmap.h"

// #define DEBUG 1

namespace globals {
	std::string const program_name = "classify-kmers" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct AssessPositionOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-jf" ]
			.set_description( "Path of jellyfish file to load kmers from." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options[ "-breaks" ]
			.set_description( "Lower and upper limits of heterozygous and homozygous kmers"
				" E.g 10 100 1000 treats kmers wth multiplicity < 10 as error, 10-100 as heterozygous, "
				"100-1000 as homozygous and everything above as high multiplicity." )
			.set_takes_values( 3 )
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
	}
} ;

struct ClassifyKmerApplication: public appcontext::ApplicationContext
{
public:
	ClassifyKmerApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new AssessPositionOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	// kmer multiplicities are encoded as:
	// multiplicity (encoded in lower 8 bits).
	// k value (encoded in top 8 bits)
	//typedef boost::unordered_map< uint64_t, uint16_t > MultiplicityMap ;
	typedef phmap::flat_hash_map< uint64_t, uint16_t > MultiplicityMap ;
	MultiplicityMap m_map ;
	
	template< typename Iterator >
	void classify(
		Iterator it,
		std::vector< uint64_t > const limits
	) {
		std::string kmer ;
		uint16_t encoded_multiplicity ;
		std::size_t count = 0 ;
		while(it.next()) {
			unsigned int const k = it.key().k() ;
			kmer.resize( k + 1 ) ;
			it.key().to_str( &kmer[0] ) ;
			uint64_t const multiplicity = it.val() ;
			genfile::kmer::KmerHashIterator< char const* > hash( &kmer[0], &kmer[0] + k, k ) ;
			std::vector< uint64_t >::const_iterator where = std::lower_bound( limits.begin(), limits.end(), multiplicity ) ;
			pack_multiplicity( k, multiplicity, encoded_multiplicity ) ;
			m_map[ hash.minimum_hash() ] = encoded_multiplicity ;
			//std::cerr << std::dec << k << " " << multiplicity << " " << std::hex << encoded_multiplicity << "\n" ;
			std::cerr << ++count << "\n" ;
		}
	}

	void unsafe_process() {
		std::string jf_filename = options().get< std::string >( "-jf" ) ;
		std::ifstream ifs( jf_filename ) ;
		jellyfish::file_header header( ifs ) ;
		std::cerr << "Loaded header with size " << header.size() << " and nb_hashes() = " << header.nb_hashes() << ".\n" ;
		
		jellyfish::mer_dna::k(header.key_len() / 2);
		
		std::vector< uint64_t > limits = options().get_values< uint64_t >( "-breaks" ) ;
		assert( limits.size() == 3 ) ;
		if( limits[1] <= limits[0] || limits[2] <= limits[1] ) {
			throw genfile::BadArgumentError(
				"ClassifyKmerApplication::unsafe_process()",
				"-limits",
				"Expected a sorted list of integers."
			) ;
		}
		limits.push_back( std::numeric_limits< uint64_t >::max() ) ;

		if( header.format() == binary_dumper::format ) {
			binary_reader reader(ifs, &header);
			classify( reader, limits ) ;
		} else if( header.format() == text_dumper::format ) {
			text_reader reader(ifs, &header);
			classify( reader, limits ) ;
		}
		
		output( m_map ) ;
	}
	
	void pack_multiplicity( int k, int multiplicity, uint16_t& result ) {
		result = multiplicity | (uint16_t(k) << 8) ;
	}

	void unpack_multiplicity( uint16_t encoded, int& k, int& multiplicity ) {

		multiplicity = int( encoded & 0xFF ) ;
		k = int( (encoded >> 8) & 0xFF ) ;
	}
	
	void output( MultiplicityMap const& map ) {
		int multiplicity ;
		int k ;
		for( auto& elt: map ) {
			unpack_multiplicity( elt.second, k, multiplicity ) ;
			std::cout << genfile::kmer::decode_hash( elt.first, k )
				<< " " << k << " " << multiplicity << "\n" ;
		}
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		ClassifyKmerApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
