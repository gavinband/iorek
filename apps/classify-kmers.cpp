
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <thread>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/kmer/KmerHashIterator.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#include "parallel_hashmap/phmap.h"
#include "parallel_hashmap/meminfo.h"
#include <jellyfish/jellyfish.hpp>
/*
#include <sys/types.h>
#include <sys/sysinfo.h>
*/

#define DEBUG 1

namespace globals {
	std::string const program_name = "classify-kmers" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

namespace {
	typedef phmap::flat_hash_map< uint64_t, uint16_t > ParallelHashMap ;
	typedef jellyfish::cooperative::hash_counter<jellyfish::mer_dna> JellyfishHashMap ; 

	template< typename HashMap >
	struct HashMapTraits {
		typedef HashMap hashmap_t ;
		static bool add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) ;
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) ;
	} ;

	template<>
	struct HashMapTraits< ParallelHashMap > {
		typedef ParallelHashMap hashmap_t ;
		static void add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) {
			(*result)[ key.get_bits( 0, 2*jellyfish::mer_dna::k() ) ] += value ;
		}
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) {
			return 0 ;
		}
	} ;

	template<>
	struct HashMapTraits< JellyfishHashMap > {
		typedef JellyfishHashMap hashmap_t ;
		static void add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) {
			return result->add( key, value ) ;
		}
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) {
			return hashmap.ary()->size_bytes() ;
		}
	} ;
	
	template< typename HashMap >
	void classify_threaded(
		std::string const& filename,
		HashMap* result,
		std::vector< uint64_t > const limits,
		std::size_t const thread_index,
		uint64_t const thread_mask,
		std::size_t const max_kmers = std::numeric_limits< std::size_t >::max()
	) {
		std::ifstream ifs( filename ) ;
		jellyfish::file_header header( ifs ) ;
		binary_reader it(ifs, &header);
		
		unsigned int const k = header.key_len() / 2 ;
		std::size_t count = 0 ;
		uint64_t const lowerLimit = limits[0] ;
		uint64_t const upperLimit = limits[2] ;
		while( it.next() && count < max_kmers ) {
			uint64_t hash = it.key().get_bits( 0, 2*k ) ;
			if( (hash & thread_mask) == thread_index ) {
				uint64_t const multiplicity = it.val() ;
				if( it.val() >= lowerLimit && it.val() <= upperLimit ) {
					HashMapTraits< HashMap >::add( result, it.key(), multiplicity ) ;
				}
			}
			if( ((count++) & 0xFFFFFFF) == 0 ) {
				std::cerr
					<< "(thread " << thread_index << ") ++ Read " << count << " kmers.  Last was: "
					<< it.key() << " - " << std::hex << it.key().get_bits(0,2*k) << std::dec << " " 
					<< " (" << (spp::GetProcessMemoryUsed()/1000000) << "Mb used)\n" ;
			}
		}
		std::cerr << "(thread " << thread_index << "): ++ Read " << count << " kmers in total.\n" ;
	}
}

struct AssessPositionOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-jf" ]
			.set_description( "Path of jellyfish file to load kmers from." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options[ "-breaks" ]
			.set_description( "Lower and upper limits of heterozygous and homozygous kmers"
				" E.g 10 100 1000 treats kmers wth multiplicity < 10 as error, 10-100 as heterozygous, "
				"100-1000 as homozygous and everything above as high multiplicity." )
			.set_takes_values( 3 )
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
		
		options.declare_group( "Algorithm options" ) ;
		options[ "-hashmap-implementation" ]
			.set_description( "Type of hashmap to use internally.  Possible values are: "
				"\"jellyfish\" or \"parallel-hashmap\".  These have difference space/speed "
				"tradeoffs and it is worth experimenting."
			)
			.set_takes_single_value()
			.set_default_value( "jellyfish" )
		;
		options[ "-max-kmers" ]
			.set_description( "Only read a maximum of this many kmers.  This is useful for testing." )
			.set_takes_single_value()
			.set_default_value( std::numeric_limits< uint32_t >::max() )
		;
		options[ "-threads" ]
			.set_description( "Number of threads to use to load kmers with. "
				"The default value (0) means \"do all work in the main thread\"."
			)
			.set_takes_single_value()
			.set_default_value( 0 )
		;
	}
} ;

struct ClassifyKmerApplication: public appcontext::ApplicationContext
{
public:
	ClassifyKmerApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new AssessPositionOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	void unsafe_process() {
		std::string jf_filename = options().get< std::string >( "-jf" ) ;
		std::ifstream ifs( jf_filename ) ;
		jellyfish::file_header header( ifs ) ;
		ui().logger()
			<< "++ Loaded header:\n"
			<< "    size: " << header.size() << "\n"
			<< "    nb_hashes: " << header.nb_hashes() << "\n"
			<< "    key_len: " << header.key_len() << ".\n" ;

		// This is 
		
		std::vector< uint64_t > limits = options().get_values< uint64_t >( "-breaks" ) ;
		assert( limits.size() == 3 ) ;
		if( limits[1] <= limits[0] || limits[2] <= limits[1] ) {
			throw genfile::BadArgumentError(
				"ClassifyKmerApplication::unsafe_process()",
				"-limits",
				"Expected a sorted list of integers."
			) ;
		}
		limits.push_back( std::numeric_limits< uint64_t >::max() ) ;
		std::size_t const max_kmers = options().get< std::size_t >( "-max-kmers" ) ;

		if( header.format() != binary_dumper::format ) {
			throw genfile::BadArgumentError( "ClassifyKmerApplication::unsafe_process()", "-jf", "Expected a binary-format jellyfish count file." ) ;
		}
		
		std::pair< std::size_t, std::size_t > count = count_kmers( jf_filename, limits ) ;
		ui().logger() << "++ Statistics for \"" << jf_filename << "\":\n"
			<< "     total kmers: " << count.first << "\n"
			<< "  in-range kmers: " << count.second << "\n" ;
		
		binary_reader reader(ifs, &header);
		jellyfish::mer_dna::k( header.key_len() / 2 ) ;
		std::string const implementation = options().get< std::string >( "-hashmap-implementation" ) ;
		if( implementation == "parallel-hashmap" ) {
			ParallelHashMap map ;
			classify_singlethreaded< binary_reader, ParallelHashMap >( header, reader, &map, limits, max_kmers ) ;

			ui().logger() << "++ Total memory usage is:\n" ;
			ui().logger() << "              (process) : " << (spp::GetProcessMemoryUsed()/1000000) << "Mb\n" ;
		} else if( implementation == "jellyfish" ) {
			std::size_t const numberOfThreads = options().get< std::size_t >( "-threads" ) ;
			JellyfishHashMap map( count.second, jellyfish::mer_dna::k()*2, 16, numberOfThreads ) ;
			if( numberOfThreads == 0 ) {
				classify_singlethreaded< binary_reader, JellyfishHashMap >( header, reader, &map, limits, max_kmers ) ;
			} else {
				uint64_t const threadMask = (numberOfThreads - 1) ;

				if( (numberOfThreads & threadMask) != 0 ) {
					throw genfile::BadArgumentError(
						"ClassifyKmerApplication::unsafe_process()",
						"-threads",
						"Number of threads must be zero or a power of two."
					) ;
				}

				std::vector< std::thread > threads ;
				for( std::size_t i = 0; i < numberOfThreads; ++i ) {
					threads.push_back(
						std::thread(
							classify_threaded< JellyfishHashMap >,
							jf_filename, &map, limits, i, threadMask, max_kmers
						)
					) ;
				}
				for( auto& thread: threads ) {
					thread.join() ;
				}
			}

			ui().logger() << "++ Total memory usage is:\n" ;
			ui().logger() << "              (process) : " << (spp::GetProcessMemoryUsed()/1000000) << "Mb\n" ;

		} else {
			throw genfile::BadArgumentError(
				"ClassifyKmerApplication::unsafe_process()",
				"-hashmap-implementation",
				"Value must be \"jellyfish\" or \"parallel-hashmap\""
			) ;
		}
	}
	
	std::pair< std::size_t, std::size_t > count_kmers(
		std::string const& filename,
		std::vector< uint64_t > const limits
	) {
		std::ifstream ifs( filename ) ;
		jellyfish::file_header header( ifs ) ;
		binary_reader it(ifs, &header);
		
		unsigned int const k = header.key_len() / 2 ;
		jellyfish::mer_dna::k( k );
		
		std::size_t total = 0 ;
		std::size_t included = 0 ;
		auto progress = ui().get_progress_context( "Counting kmers" ) ;
		uint64_t const lowerLimit = limits[0] ;
		uint64_t const upperLimit = limits[2] ;

		while( it.next() ) {
			uint64_t const value = it.val() ;
			if( value >= lowerLimit && value <= upperLimit ) {
				++included ;
			}
			++total ;
			if( total % 100000 == 0 ) {
				progress( total, boost::optional< std::size_t >() ) ;
			}
		}
		return std::make_pair( total, included ) ;
	}
	
	template< typename Iterator, typename HashMap >
	void classify_singlethreaded(
		jellyfish::file_header const& header,
		Iterator it,
		HashMap* result,
		std::vector< uint64_t > const limits,
		std::size_t const max_kmers = std::numeric_limits< std::size_t >::max()
	) {
		unsigned int const k = header.key_len() / 2 ;
		jellyfish::mer_dna::k( k );
		std::size_t count = 0 ;
		auto progress = ui().get_progress_context( "Loading kmers" ) ;
		uint64_t const lowerLimit = limits[0] ;
		uint64_t const upperLimit = limits[2] ;
		while( it.next() && count < max_kmers ) {
			uint64_t const multiplicity = it.val() ;
			if( it.val() >= lowerLimit && it.val() <= upperLimit ) {
				HashMapTraits< HashMap >::add( result, it.key(), multiplicity ) ;
			}

			if( (count++) % 25000000 == 0 ) {
				std::cerr
					<< "++ Read " << count << " kmers.  Last was: "
					<< it.key() << " - " << std::hex << it.key().get_bits(0,2*k) << std::dec << " " 
					<< " (" << (spp::GetProcessMemoryUsed()/1000000) << "Mb used)\n" ;
			}
			progress( count, boost::optional< std::size_t >() ) ;
		}
		std::cerr << "++ Read " << count << " kmers in total, quitting.\n" ;
	}
	

} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		ClassifyKmerApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
