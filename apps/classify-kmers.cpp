
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <boost/unordered_map.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/kmer/KmerHashIterator.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#include "parallel_hashmap/phmap.h"
#include "parallel_hashmap/meminfo.h"
#include "jellyfish/jellyfish.hpp"
#include "jellyfish/large_hash_iterator.hpp"
#include "jellyfish/hash_counter.hpp"

/*
#include <sys/types.h>
#include <sys/sysinfo.h>
*/

#define DEBUG 1
#define MODE 2


namespace globals {
	std::string const program_name = "classify-kmers" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

struct AssessPositionOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-jf" ]
			.set_description( "Path of jellyfish file to load kmers from." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options[ "-breaks" ]
			.set_description( "Lower and upper limits of heterozygous and homozygous kmers"
				" E.g 10 100 1000 treats kmers wth multiplicity < 10 as error, 10-100 as heterozygous, "
				"100-1000 as homozygous and everything above as high multiplicity." )
			.set_takes_values( 3 )
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
	}
} ;

struct ClassifyKmerApplication: public appcontext::ApplicationContext
{
public:
	ClassifyKmerApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new AssessPositionOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	// kmer multiplicities are encoded as:
	// multiplicity (encoded in lower 8 bits).
	// k value (encoded in top 8 bits)
	//typedef boost::unordered_map< uint64_t, uint16_t > MultiplicityMap ;
#if MODE == 2
	typedef phmap::flat_hash_map< uint64_t, uint16_t > MultiplicityMap ;
#elif MODE == 3
	typedef mer_hash MultiplicityMap ;
#endif
	
	template< typename Iterator >
	void classify(
		jellyfish::file_header const& header,
		Iterator it,
		std::vector< uint64_t > const limits
	) {
		unsigned int const k = header.key_len() / 2 ;
		jellyfish::mer_dna::k( k );
#if MODE == 2
		MultiplicityMap map ;
#elif MODE == 3
		MultiplicityMap map( 10000000, k*2, 64, 1 ) ;
#endif

		auto progress_context = ui().get_progress_context( "Reading kmers" ) ;

		std::size_t count = 0 ;
		while(it.next() && count < 500000000 ) {
#if MODE > 0
			uint64_t hash = it.key().get_bits( 0, 2*k ) ;
			uint64_t const multiplicity = it.val() ;
#endif
#if MODE == 2
			map[ hash ] = multiplicity ;
#elif MODE == 3
			map.add( it.key(), multiplicity ) ;
#endif
#if DEBUG
			if( count % 10000000 == 0 ) {
				uint64_t hash = it.key().get_bits( 0, 2*k ) ;
				std::cerr << "\n++ Read " << std::dec << count << " kmers.  Last was:\n" ;
				std::cerr
					<< it.key() << ": "
						<< std::hex << it.key()
						<< " - " << hash
						<< " : " << genfile::kmer::decode_hash( hash, k ) << "\n" ;
				std::cerr << "++ Total memory usage is:\n" ;
				std::cerr << "              (process) : " << std::dec << (spp::GetProcessMemoryUsed()/1000) << "kb\n" ;
			}
#endif
			progress_context( ++count, boost::optional< std::size_t >() ) ;
		}
#if DEBUG
		std::cerr << "Read " << count << " kmers.\n" ;
#endif
		std::cerr << "++ Total memory usage is:\n" ;
		std::cerr << "              (process) : " << std::dec << (spp::GetProcessMemoryUsed()/1000) << "kb\n" ;
#if MODE == 3
		std::cerr << "            (mer_array) : " << std::dec << (map.ary()->size_bytes()/1000) << "kb.\n" ;
#endif
#if MODE == 2
		std::cerr << "++ First few map values are:\n" ;
		MultiplicityMap::const_iterator iterator = map.begin() ;
		MultiplicityMap::const_iterator const end = map.end() ;
		for( std::size_t n = 0; iterator != end && n < 100; ++iterator, ++n ) {
			std::cerr << "  " << iterator->first << ": " << iterator->second << "\n" ;
		}
#elif MODE == 3
		std::cerr << "++ First few map values are:\n" ;
		mer_array::const_iterator iterator = map.ary()->begin() ;
		mer_array::const_iterator const end = map.ary()->end() ;
		for( std::size_t n = 0; iterator!= end && n < 100; ++iterator, ++n ) {
			std::cerr << "  " << iterator->first << ": " << iterator->second << "\n" ;
		}
#endif
	}

	void unsafe_process() {
		std::string jf_filename = options().get< std::string >( "-jf" ) ;
		std::ifstream ifs( jf_filename ) ;
		jellyfish::file_header header( ifs ) ;
		ui().logger()
			<< "++ Loaded header:\n"
			<< "    size: " << header.size() << "\n"
			<< "    nb_hashes: " << header.nb_hashes() << "\n"
			<< "    key_len: " << header.key_len() << ".\n" ;

		// This is 
		
		
		std::vector< uint64_t > limits = options().get_values< uint64_t >( "-breaks" ) ;
		assert( limits.size() == 3 ) ;
		if( limits[1] <= limits[0] || limits[2] <= limits[1] ) {
			throw genfile::BadArgumentError(
				"ClassifyKmerApplication::unsafe_process()",
				"-limits",
				"Expected a sorted list of integers."
			) ;
		}
		limits.push_back( std::numeric_limits< uint64_t >::max() ) ;

		if( header.format() == binary_dumper::format ) {
			binary_reader reader(ifs, &header);
			classify( header, reader, limits ) ;
		} else if( header.format() == text_dumper::format ) {
			text_reader reader(ifs, &header);
			classify( header, reader, limits ) ;
		}
		
		//output( m_map ) ;
	}
	
	void pack_multiplicity( int k, int multiplicity, uint16_t& result ) {
		result = multiplicity | (uint16_t(k) << 8) ;
	}

	void unpack_multiplicity( uint16_t encoded, int& k, int& multiplicity ) {

		multiplicity = int( encoded & 0xFF ) ;
		k = int( (encoded >> 8) & 0xFF ) ;
	}

#if 0	
	void output( MultiplicityMap const& map ) {
		int multiplicity ;
		int k ;
		for( auto& elt: map ) {
			unpack_multiplicity( elt.second, k, multiplicity ) ;
			std::cout << genfile::kmer::decode_hash( elt.first, k )
				<< " " << k << " " << multiplicity << "\n" ;
		}
	}
#endif
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		ClassifyKmerApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
