
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <boost/lockfree/queue.hpp>
#include <chrono>
#include <thread>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/kmer/KmerHashIterator.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#include "parallel_hashmap/phmap.h"
#include "parallel_hashmap/meminfo.h"
#include "jellyfish/jellyfish.hpp"
#include "concurrentqueue/concurrentqueue.h"

/*
#include <sys/types.h>
#include <sys/sysinfo.h>
*/

#define DEBUG 1

namespace globals {
	std::string const program_name = "classify-kmers" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

namespace {
	typedef phmap::flat_hash_map< uint64_t, uint16_t > ParallelHashMap ;
	typedef jellyfish::cooperative::hash_counter<jellyfish::mer_dna> JellyfishHashMap ; 

	template< typename HashMap >
	struct HashMapTraits {
		typedef HashMap hashmap_t ;
		static bool add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) ;
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) ;
	} ;

	template<>
	struct HashMapTraits< ParallelHashMap > {
		typedef ParallelHashMap hashmap_t ;
		static void add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) {
			(*result)[ key.get_bits( 0, 2*jellyfish::mer_dna::k() ) ] += value ;
		}
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) {
			return 0 ;
		}
	} ;

	template<>
	struct HashMapTraits< JellyfishHashMap > {
		typedef JellyfishHashMap hashmap_t ;
		static void add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) {
			return result->add( key, value ) ;
		}
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) {
			return hashmap.ary()->size_bytes() ;
		}
	} ;

	/*
	typedef boost::lockfree::queue<
		std::pair< jellyfish::mer_dna, uint64_t >,
		boost::lockfree::capacity< 2048 >
	> Queue ;
*/
	typedef moodycamel::ConcurrentQueue<
		std::pair< jellyfish::mer_dna, uint64_t >
	> Queue ;
	
	template< typename HashMap, typename HetMap >
	void classify_threaded(
		std::size_t const k,
		Queue* queue,
		HashMap* result,
		HetMap* hets,
		std::vector< uint64_t > const limits,
		std::size_t const thread_index,
		uint64_t const thread_mask,
		std::atomic< int >* quit
	) {
		std::size_t count = 0 ;
		std::size_t het_count = 0 ;
		uint64_t const lowerLimit = limits[0] ;
		uint64_t const hetLimit = limits[1] ;
		uint64_t const upperLimit = limits[2] ;
		assert( hetLimit >= lowerLimit ) ;
		assert( upperLimit >= hetLimit ) ;
		bool popped = false;
		std::pair< jellyfish::mer_dna, uint64_t > elt ;
		while( !(*quit) ) {
			bool popped = queue->try_dequeue( elt ) ;
			if( popped ) {
				std::cerr << "(thread " << thread_index << ") ++ Got " << elt.first << "!\n" ;
			} else {
				std::cerr << "(thread " << thread_index << ") ++ no pop.\n" ;
			}
			if( popped ) {
				uint64_t hash = elt.first.get_bits( 0, 2*k ) ;
				if( (hash & thread_mask) == thread_index ) {
					uint64_t const& multiplicity = elt.second ;
					if( elt.second >= lowerLimit ) {
						if( elt.second <= upperLimit ) {
							++count ;
							HashMapTraits< HashMap >::add( result, elt.first, multiplicity ) ;
						}
						if( elt.second <= hetLimit ) {
							++het_count ;
							HashMapTraits< HetMap >::add( hets, elt.first, multiplicity ) ;
						}
					}
				}
				if( (count & 0xFFFFFFF) == 0 ) {
					std::cerr << "(thread " << thread_index << ") ++ Added " << count << " kmers.\n" ;
				}
			} else {
				// nothing to pop, sleep to allow queue to fill.
				std::this_thread::sleep_for( std::chrono::milliseconds(1) ) ;
			}
		}
		std::cerr << "(thread " << thread_index << "): ++ Added "
			<< count << " kmers in total, including "
			<< het_count << " probable hets.\n" ;
		std::cerr << "(thread " << thread_index << "): ++ Thread ending...\n" ;
	}
}

struct AssessPositionOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-jf" ]
			.set_description( "Path of jellyfish file to load kmers from." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options[ "-breaks" ]
			.set_description( "Lower and upper limits of heterozygous and homozygous kmers"
				" E.g 10 100 1000 treats kmers wth multiplicity < 10 as error, 10-100 as heterozygous, "
				"100-1000 as homozygous and everything above as high multiplicity." )
			.set_takes_values( 3 )
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
		
		options.declare_group( "Algorithm options" ) ;
		options[ "-hashmap-implementation" ]
			.set_description( "Type of hashmap to use internally.  Possible values are: "
				"\"jellyfish\" or \"parallel-hashmap\".  These have difference space/speed "
				"tradeoffs and it is worth experimenting."
			)
			.set_takes_single_value()
			.set_default_value( "jellyfish" )
		;
		options[ "-max-kmers" ]
			.set_description( "Only read a maximum of this many kmers.  This is useful for testing." )
			.set_takes_single_value()
			.set_default_value( std::numeric_limits< uint32_t >::max() )
		;
		options[ "-threads" ]
			.set_description( "Number of threads to use to load kmers with. " )
			.set_takes_single_value()
			.set_default_value( 1 )
		;
	}
} ;

struct ClassifyKmerApplication: public appcontext::ApplicationContext
{
public:
	ClassifyKmerApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new AssessPositionOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	void unsafe_process() {
		std::string jf_filename = options().get< std::string >( "-jf" ) ;
		std::ifstream ifs( jf_filename ) ;
		jellyfish::file_header header( ifs ) ;
		ui().logger()
			<< "++ Loaded header:\n"
			<< "    size: " << header.size() << "\n"
			<< "    nb_hashes: " << header.nb_hashes() << "\n"
			<< "    key_len: " << header.key_len() << ".\n" ;

		// This is 
		
		std::vector< uint64_t > limits = options().get_values< uint64_t >( "-breaks" ) ;
		assert( limits.size() == 3 ) ;
		if( limits[1] <= limits[0] || limits[2] <= limits[1] ) {
			throw genfile::BadArgumentError(
				"ClassifyKmerApplication::unsafe_process()",
				"-limits",
				"Expected a sorted list of integers."
			) ;
		}
		limits.push_back( std::numeric_limits< uint64_t >::max() ) ;
		std::size_t const max_kmers = options().get< std::size_t >( "-max-kmers" ) ;

		if( header.format() != binary_dumper::format ) {
			throw genfile::BadArgumentError( "ClassifyKmerApplication::unsafe_process()", "-jf", "Expected a binary-format jellyfish count file." ) ;
		}
		
		std::pair< std::size_t, std::size_t > count = count_kmers( jf_filename, limits ) ;
		ui().logger() << "++ Statistics for \"" << jf_filename << "\":\n"
			<< "     total kmers: " << count.first << "\n"
			<< "  in-range kmers: " << count.second << "\n" ;
		
		binary_reader reader(ifs, &header);
		std::size_t const k = header.key_len() / 2 ;
		jellyfish::mer_dna::k( k ) ;
		std::string const implementation = options().get< std::string >( "-hashmap-implementation" ) ;


		{
			std::size_t const numberOfThreads = options().get< std::size_t >( "-threads" ) ;
			JellyfishHashMap all( count.second, jellyfish::mer_dna::k()*2, 16, numberOfThreads ) ;
			ParallelHashMap hets ;
			{
				uint64_t const threadMask = (numberOfThreads - 1) ;

				if( (numberOfThreads & threadMask) != 0 ) {
					throw genfile::BadArgumentError(
						"ClassifyKmerApplication::unsafe_process()",
						"-threads",
						"Number of threads must be zero or a power of two."
					) ;
				}

				Queue queue( 2048 ) ;
				std::atomic< int > quit(0) ;
				std::vector< std::thread > threads ;
				for( std::size_t i = 0; i < numberOfThreads; ++i ) {
					threads.push_back(
						std::thread(
							classify_threaded< JellyfishHashMap, ParallelHashMap >,
							k, &queue, &all, &hets, limits, i, threadMask, &quit
						)
					) ;
				}
				
				read_into_queue( header, reader, queue, max_kmers ) ;
				
				while( queue.size_approx() > 0 ) {
					std::cerr << "Queue size = " << queue.size_approx() << ".\n" ;
					std::this_thread::sleep_for( std::chrono::milliseconds(10)) ;
				}

				quit = 1 ;

				for( auto& thread: threads ) {
					thread.join() ;
				}
			}

			ui().logger() << "++ Total memory usage is:\n" ;
			ui().logger() << "              (process) : " << (spp::GetProcessMemoryUsed()/1000000) << "Mb\n" ;
		}
	}
	
	std::pair< std::size_t, std::size_t > count_kmers(
		std::string const& filename,
		std::vector< uint64_t > const limits
	) {
		std::ifstream ifs( filename ) ;
		jellyfish::file_header header( ifs ) ;
		unsigned int const k = header.key_len() / 2 ;
		std::cerr << "k = " << k << ".\n" ;
		jellyfish::mer_dna::k( k );
		binary_reader it(ifs, &header);
		
		
		std::size_t total = 0 ;
		std::size_t included = 0 ;
		auto progress = ui().get_progress_context( "Counting kmers" ) ;
		uint64_t const lowerLimit = limits[0] ;
		uint64_t const upperLimit = limits[2] ;

		while( it.next() ) {
			uint64_t const value = it.val() ;
			if( value >= lowerLimit && value <= upperLimit ) {
				++included ;
			}
			++total ;
			if( total % 100000 == 0 ) {
				progress( total, boost::optional< std::size_t >() ) ;
			}
		}
		return std::make_pair( total, included ) ;
	}
	
	template< typename Iterator >
	void read_into_queue(
		jellyfish::file_header const& header,
		Iterator it,
		Queue& queue,
		std::size_t const max_kmers = std::numeric_limits< std::size_t >::max()
	) {
		unsigned int const k = header.key_len() / 2 ;
		jellyfish::mer_dna::k( k ) ;
		std::size_t count = 0 ;
		auto progress = ui().get_progress_context( "Loading kmers" ) ;
		while( it.next() && count < max_kmers ) {
			std::pair< jellyfish::mer_dna, uint64_t > elt( it.key(), it.val() ) ;
			while( !queue.try_enqueue( elt )) {
				std::this_thread::sleep_for( std::chrono::milliseconds(1) ) ;
			}
		}
		std::cerr << "++ read_into_queue(): Read " << count << " kmers in totalquitting.\n" ;
	}
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		ClassifyKmerApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
