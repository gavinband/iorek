
//					Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//		(See accompanying file LICENSE_1_0.txt or copy at
//					http://www.boost.org/LICENSE_1_0.txt)

#include "../package_revision_autogenerated.hpp"

#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/unordered_set.hpp>
#include <boost/filesystem.hpp>
#include <boost/noncopyable.hpp>
#include <boost/unordered_map.hpp>

// seqlib
#include "SeqLib/RefGenome.h"
#include "SeqLib/BamReader.h"
#include "SeqLib/GenomicRegionCollection.h"
#include "SeqLib/GenomicRegion.h"
//#include "SeqLib/BWAWrapper.h"

namespace seqlib = SeqLib;
// namespace bt = BamTools ;

#include "appcontext/appcontext.hpp"
#include "genfile/GenomePositionRange.hpp"
#include "genfile/string_utils/string_utils.hpp"
#include "genfile/string_utils/slice.hpp"
#include "genfile/Error.hpp"
#include "genfile/kmer/KmerHashIterator.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"

#include "parallel_hashmap/phmap.h"
#include "parallel_hashmap/meminfo.h"
#include <jellyfish/jellyfish.hpp>
/*
#include <sys/types.h>
#include <sys/sysinfo.h>
*/

#define DEBUG 1

namespace globals {
	std::string const program_name = "classify-kmers" ;
	std::string const program_version = package_version ;
	std::string const program_revision = std::string( package_revision ).substr( 0, 7 ) ;
}

namespace {
	typedef phmap::flat_hash_map< uint64_t, uint16_t > ParallelHashMap ;
	typedef jellyfish::cooperative::hash_counter<jellyfish::mer_dna> JellyfishHashMap ; 

	template< typename HashMap >
	struct HashMapTraits {
		typedef HashMap hashmap_t ;
		static bool add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) ;
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) ;
	} ;

	template<>
	struct HashMapTraits< ParallelHashMap > {
		typedef ParallelHashMap hashmap_t ;
		static void add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) {
			(*result)[ key.get_bits( 0, 2*jellyfish::mer_dna::k() ) ] += value ;
		}
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) {
			return 0 ;
		}
	} ;

	template<>
	struct HashMapTraits< JellyfishHashMap > {
		typedef JellyfishHashMap hashmap_t ;
		static void add( hashmap_t* result, jellyfish::mer_dna const& key, uint64_t value ) {
			return result->add( key, value ) ;
		}
		static std::size_t size_in_bytes( hashmap_t const& hashmap ) {
			return hashmap.ary()->size_bytes() ;
		}
	} ;
}

struct AssessPositionOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		
		options.declare_group( "Input / output file options" ) ;
		options[ "-jf" ]
			.set_description( "Path of jellyfish file to load kmers from." )
			.set_takes_values_until_next_option()
			.set_is_required()
		;

		options[ "-breaks" ]
			.set_description( "Lower and upper limits of heterozygous and homozygous kmers"
				" E.g 10 100 1000 treats kmers wth multiplicity < 10 as error, 10-100 as heterozygous, "
				"100-1000 as homozygous and everything above as high multiplicity." )
			.set_takes_values( 3 )
			.set_is_required()
		;

		options[ "-o" ]
			.set_description( "Path of output file." )
			.set_takes_single_value()
			.set_default_value( "-" ) ;
		
		options.declare_group( "Algorithm options" ) ;
		options[ "-hashmap-implementation" ]
			.set_description( "Type of hashmap to use internally.  Possible values are: "
				"\"jellyfish\" or \"parallel-hashmap\".  These have difference space/speed "
				"tradeoffs and it is worth experimenting."
			)
			.set_takes_single_value()
			.set_default_value( "parallel-hashmap" )
		;
		options[ "-max-kmers" ]
			.set_description( "Only read a maximum of this many kmers.  This is useful for testing." )
			.set_takes_single_value()
			.set_default_value( std::numeric_limits< uint32_t >::max() )
		;
	}
} ;

struct ClassifyKmerApplication: public appcontext::ApplicationContext
{
public:
	ClassifyKmerApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new AssessPositionOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{}
	
	void run() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			ui().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}

private:
	// kmer multiplicities are encoded as:
	// multiplicity (encoded in lower 8 bits).
	// k value (encoded in top 8 bits)
	//typedef boost::unordered_map< uint64_t, uint16_t > MultiplicityMap ;
	void unsafe_process() {
		std::string jf_filename = options().get< std::string >( "-jf" ) ;
		std::ifstream ifs( jf_filename ) ;
		jellyfish::file_header header( ifs ) ;
		ui().logger()
			<< "++ Loaded header:\n"
			<< "    size: " << header.size() << "\n"
			<< "    nb_hashes: " << header.nb_hashes() << "\n"
			<< "    key_len: " << header.key_len() << ".\n" ;

		// This is 
		
		std::vector< uint64_t > limits = options().get_values< uint64_t >( "-breaks" ) ;
		assert( limits.size() == 3 ) ;
		if( limits[1] <= limits[0] || limits[2] <= limits[1] ) {
			throw genfile::BadArgumentError(
				"ClassifyKmerApplication::unsafe_process()",
				"-limits",
				"Expected a sorted list of integers."
			) ;
		}
		limits.push_back( std::numeric_limits< uint64_t >::max() ) ;
		std::size_t const max_kmers = options().get< std::size_t >( "-max-kmers" ) ;

		if( header.format() != binary_dumper::format ) {
			throw genfile::BadArgumentError( "ClassifyKmerApplication::unsafe_process()", "-jf", "Expected a binary-format jellyfish count file." ) ;
		}
		binary_reader reader(ifs, &header);
		jellyfish::mer_dna::k( header.key_len() / 2 ) ;
		std::string const implementation = options().get< std::string >( "-hashmap-implementation" ) ;
		if( implementation == "parallel-hashmap" ) {
			ParallelHashMap map ;
			classify< binary_reader, ParallelHashMap >( header, reader, &map, limits, max_kmers ) ;
		} else if( implementation == "jellyfish" ) {
			JellyfishHashMap map( 10000000, jellyfish::mer_dna::k()*2, 64, 1 ) ;
			classify< binary_reader, JellyfishHashMap >( header, reader, &map, limits, max_kmers ) ;
		} else {
			throw genfile::BadArgumentError(
				"ClassifyKmerApplication::unsafe_process()",
				"-hashmap-implementation",
				"Value must be \"jellyfish\" or \"parallel-hashmap\""
			) ;
		}

		ui().logger() << "++ Total memory usage is:\n" ;
		ui().logger() << "              (process) : " << (spp::GetProcessMemoryUsed()/1000) << "kb\n" ;
	}
	
	template< typename Iterator, typename HashMap >
	void classify(
		jellyfish::file_header const& header,
		Iterator it,
		HashMap* result,
		std::vector< uint64_t > const limits,
		std::size_t max_kmers = std::numeric_limits< std::size_t >::max()
	) {
		unsigned int const k = header.key_len() / 2 ;
		jellyfish::mer_dna::k( k );
		std::size_t count = 0 ;
		while( it.next() && count < max_kmers ) {
			uint64_t const multiplicity = it.val() ;
			HashMapTraits< HashMap >::add( result, it.key(), multiplicity ) ;

			if( (count++) % 100000 == 0 ) {
				std::cerr << "Read " << count << " kmers.  Last was:\n" ;
				std::cerr
					<< it.key() << ": "
						<< it.key()
						<< " - " << std::hex << it.key().get_bits(0,2*k) << "\n" ;
			}
		}
		std::cerr << "++ Read " << count << " kmers in total.\n" ;
	}
	
} ;


int main( int argc, char** argv )
{
	std::ios_base::sync_with_stdio( false ) ;
	try {
		ClassifyKmerApplication app( argc, argv ) ;
		app.run() ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
	
